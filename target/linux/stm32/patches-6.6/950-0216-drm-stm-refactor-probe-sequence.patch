From 6a508bd6b305bbc5d569358ea3ab1f5ddf00befd Mon Sep 17 00:00:00 2001
From: Yannick Fertre <yannick.fertre@foss.st.com>
Date: Fri, 19 Jan 2024 13:15:11 +0100
Subject: [PATCH] drm/stm: refactor probe sequence

Add new functions ltdc_parse_device_tree & ltdc_get_clk

Change-Id: Ifff004e49333208863f877e742307ffbe21ffacf
Signed-off-by: Yannick Fertre <yannick.fertre@foss.st.com>
---
 drivers/gpu/drm/stm/drv.c  |  45 ++++++++----
 drivers/gpu/drm/stm/ltdc.c | 136 ++++++++++++++++++++++++-------------
 drivers/gpu/drm/stm/ltdc.h |   6 +-
 3 files changed, 123 insertions(+), 64 deletions(-)

diff --git a/drivers/gpu/drm/stm/drv.c b/drivers/gpu/drm/stm/drv.c
index f64232431ad9..a380ee291f0e 100644
--- a/drivers/gpu/drm/stm/drv.c
+++ b/drivers/gpu/drm/stm/drv.c
@@ -71,17 +71,10 @@ static const struct drm_driver drv_driver = {
 static int drv_load(struct drm_device *ddev)
 {
 	struct platform_device *pdev = to_platform_device(ddev->dev);
-	struct ltdc_device *ldev;
 	int ret;
 
 	DRM_DEBUG("%s\n", __func__);
 
-	ldev = devm_kzalloc(ddev->dev, sizeof(*ldev), GFP_KERNEL);
-	if (!ldev)
-		return -ENOMEM;
-
-	ddev->dev_private = (void *)ldev;
-
 	ret = drmm_mode_config_init(ddev);
 	if (ret)
 		return ret;
@@ -159,9 +152,10 @@ static __maybe_unused int drv_resume(struct device *dev)
 static __maybe_unused int drv_runtime_suspend(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct ltdc_device *ldev = ddev->dev_private;
 
 	DRM_DEBUG_DRIVER("\n");
-	ltdc_suspend(ddev);
+	ltdc_suspend(ldev);
 
 	return 0;
 }
@@ -169,9 +163,10 @@ static __maybe_unused int drv_runtime_suspend(struct device *dev)
 static __maybe_unused int drv_runtime_resume(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct ltdc_device *ldev = ddev->dev_private;
 
 	DRM_DEBUG_DRIVER("\n");
-	return ltdc_resume(ddev);
+	return ltdc_resume(ldev);
 }
 
 static const struct dev_pm_ops drv_pm_ops = {
@@ -184,11 +179,12 @@ static int stm_drm_platform_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct drm_device *ddev;
+	struct ltdc_device *ldev;
 	struct device *sfdev;
 	struct device_node *node;
 	int ret = 0;
 
-	DRM_DEBUG("%s\n", __func__);
+	DRM_DEBUG_DRIVER("\n");
 
 	/*
 	 * To avoid conflicts between the simple-framebuffer and the display-controller,
@@ -209,15 +205,36 @@ static int stm_drm_platform_probe(struct platform_device *pdev)
 			return ret;
 	}
 
-	ret = drm_aperture_remove_framebuffers(&drv_driver);
+	ldev = devm_kzalloc(dev, sizeof(*ldev), GFP_KERNEL);
+	if (!ldev)
+		return -ENOMEM;
+
+	ret = ltdc_parse_device_tree(dev);
+	if (ret)
+		return ret;
+
+	ret = ltdc_get_clk(dev, ldev);
+	if (ret)
+		return ret;
+
+	/* Resume device to enable the clocks */
+	ret = ltdc_resume(ldev);
 	if (ret)
 		return ret;
 
+	ret = drm_aperture_remove_framebuffers(&drv_driver);
+	if (ret)
+		goto err_suspend;
+
 	dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
 
 	ddev = drm_dev_alloc(&drv_driver, dev);
-	if (IS_ERR(ddev))
-		return PTR_ERR(ddev);
+	if (IS_ERR(ddev)) {
+		ret =  PTR_ERR(ddev);
+		goto err_suspend;
+	}
+
+	ddev->dev_private = (void *)ldev;
 
 	ret = drv_load(ddev);
 	if (ret)
@@ -233,6 +250,8 @@ static int stm_drm_platform_probe(struct platform_device *pdev)
 
 err_put:
 	drm_dev_put(ddev);
+err_suspend:
+	ltdc_suspend(ldev);
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/stm/ltdc.c b/drivers/gpu/drm/stm/ltdc.c
index 641b6f7f3464..139c0d394625 100644
--- a/drivers/gpu/drm/stm/ltdc.c
+++ b/drivers/gpu/drm/stm/ltdc.c
@@ -2229,19 +2229,17 @@ static int ltdc_get_caps(struct drm_device *ddev)
 	return 0;
 }
 
-void ltdc_suspend(struct drm_device *ddev)
+void ltdc_suspend(struct ltdc_device *ldev)
 {
-	struct ltdc_device *ldev = ddev->dev_private;
-
 	DRM_DEBUG_DRIVER("\n");
+
 	clk_disable_unprepare(ldev->pixel_clk);
 	if (ldev->bus_clk)
 		clk_disable_unprepare(ldev->bus_clk);
 }
 
-int ltdc_resume(struct drm_device *ddev)
+int ltdc_resume(struct ltdc_device *ldev)
 {
-	struct ltdc_device *ldev = ddev->dev_private;
 	int ret;
 
 	DRM_DEBUG_DRIVER("\n");
@@ -2253,10 +2251,9 @@ int ltdc_resume(struct drm_device *ddev)
 	}
 
 	if (ldev->bus_clk) {
-		ret = clk_prepare_enable(ldev->bus_clk);
-		if (ret) {
-			DRM_ERROR("failed to enable bus clock (%d)\n", ret);
-			return ret;
+		if (clk_prepare_enable(ldev->bus_clk)) {
+			DRM_ERROR("Unable to prepare bus clock\n");
+			return -ENODEV;
 		}
 	}
 
@@ -2285,18 +2282,6 @@ int ltdc_load(struct drm_device *ddev)
 	if (!nb_endpoints)
 		return -ENODEV;
 
-	ldev->pixel_clk = devm_clk_get(dev, "lcd");
-	if (IS_ERR(ldev->pixel_clk)) {
-		if (PTR_ERR(ldev->pixel_clk) != -EPROBE_DEFER)
-			DRM_ERROR("Unable to get lcd clock\n");
-		return PTR_ERR(ldev->pixel_clk);
-	}
-
-	if (clk_prepare_enable(ldev->pixel_clk)) {
-		DRM_ERROR("Unable to prepare pixel clock\n");
-		return -ENODEV;
-	}
-
 	if (of_device_is_compatible(np, "st,stm32mp25-ltdc")) {
 		/* Get max burst length */
 		ret = of_property_read_u32(np, "st,burstlen", &mbl);
@@ -2305,21 +2290,6 @@ int ltdc_load(struct drm_device *ddev)
 			ldev->max_burst_length = 0;
 		else
 			ldev->max_burst_length = mbl / 8;
-
-		ldev->ltdc_clk = devm_clk_get(dev, "ref");
-		if (IS_ERR(ldev->ltdc_clk))
-			return dev_err_probe(dev, PTR_ERR(ldev->ltdc_clk),
-					     "Unable to get ltdc clock\n");
-
-		ldev->bus_clk = devm_clk_get(dev, "bus");
-		if (IS_ERR(ldev->bus_clk))
-			return dev_err_probe(dev, PTR_ERR(ldev->bus_clk),
-					     "Unable to get bus clock\n");
-
-		if (clk_prepare_enable(ldev->bus_clk)) {
-			DRM_ERROR("Unable to prepare bus clock\n");
-			return -ENODEV;
-		}
 	}
 
 	/* Get endpoints if any */
@@ -2334,7 +2304,7 @@ int ltdc_load(struct drm_device *ddev)
 		if (ret == -ENODEV)
 			continue;
 		else if (ret)
-			goto err;
+			return ret;
 
 		if (panel) {
 			bridge = drm_panel_bridge_add_typed(panel,
@@ -2342,7 +2312,7 @@ int ltdc_load(struct drm_device *ddev)
 			if (IS_ERR(bridge)) {
 				DRM_ERROR("panel-bridge endpoint %d\n", i);
 				ret = PTR_ERR(bridge);
-				goto err;
+				return ret;
 			}
 		}
 
@@ -2351,7 +2321,7 @@ int ltdc_load(struct drm_device *ddev)
 			if (ret) {
 				if (ret != -EPROBE_DEFER)
 					DRM_ERROR("init encoder endpoint %d\n", i);
-				goto err;
+				return ret;
 			}
 		}
 	}
@@ -2435,11 +2405,6 @@ int ltdc_load(struct drm_device *ddev)
 		goto err;
 	}
 
-	clk_disable_unprepare(ldev->pixel_clk);
-
-	if (ldev->bus_clk)
-		clk_disable_unprepare(ldev->bus_clk);
-
 	pinctrl_pm_select_sleep_state(ddev->dev);
 
 	pm_runtime_enable(ddev->dev);
@@ -2460,11 +2425,6 @@ int ltdc_load(struct drm_device *ddev)
 	for (i = 0; i < nb_endpoints; i++)
 		drm_of_panel_bridge_remove(ddev->dev->of_node, 0, i);
 
-	clk_disable_unprepare(ldev->pixel_clk);
-
-	if (ldev->bus_clk)
-		clk_disable_unprepare(ldev->bus_clk);
-
 	return ret;
 }
 
@@ -2483,6 +2443,84 @@ void ltdc_unload(struct drm_device *ddev)
 	pm_runtime_disable(ddev->dev);
 }
 
+int ltdc_parse_device_tree(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct drm_bridge *bridge;
+	struct drm_panel *panel;
+	int i, nb_endpoints;
+	int ret = -ENODEV;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	/* Get number of endpoints */
+	nb_endpoints = of_graph_get_endpoint_count(np);
+	if (!nb_endpoints)
+		return -ENODEV;
+
+	/* Get endpoints if any */
+	for (i = 0; i < nb_endpoints; i++) {
+		ret = drm_of_find_panel_or_bridge(np, 0, i, &panel, &bridge);
+
+		/*
+		 * If at least one endpoint is -ENODEV, continue probing,
+		 * else if at least one endpoint returned an error
+		 * (ie -EPROBE_DEFER) then stop probing.
+		 */
+		if (ret == -ENODEV)
+			continue;
+		else if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int ltdc_get_clk(struct device *dev, struct ltdc_device *ldev)
+{
+	struct device_node *node;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	ldev->pixel_clk = devm_clk_get(dev, "lcd");
+	if (IS_ERR(ldev->pixel_clk)) {
+		if (PTR_ERR(ldev->pixel_clk) != -EPROBE_DEFER)
+			DRM_ERROR("Unable to get lcd clock\n");
+		return PTR_ERR(ldev->pixel_clk);
+	}
+
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc")) {
+		ldev->bus_clk = devm_clk_get(dev, "bus");
+		if (IS_ERR(ldev->bus_clk))
+			return dev_err_probe(dev, PTR_ERR(ldev->bus_clk),
+					     "Unable to get bus clock\n");
+
+		ldev->ltdc_clk = devm_clk_get(dev, "ref");
+		if (IS_ERR(ldev->ltdc_clk))
+			return dev_err_probe(dev, PTR_ERR(ldev->ltdc_clk),
+					     "Unable to get ltdc clock\n");
+
+		/*
+		 * The lvds output clock is not available if the lvds is not probed.
+		 * This is a usual case, it is necessary to check the node to avoid
+		 * looking for a clock that will never be available.
+		 */
+		node = of_find_compatible_node(NULL, NULL, "st,stm32mp25-lvds");
+		if (!IS_ERR(node)) {
+			if (of_device_is_available(node)) {
+				ldev->lvds_clk = devm_clk_get(dev, "lvds");
+				if (IS_ERR(ldev->lvds_clk)) {
+					return dev_err_probe(dev, PTR_ERR(ldev->lvds_clk),
+							     "Unable to get lvds clock\n");
+				}
+			}
+			of_node_put(node);
+		}
+	}
+
+	return 0;
+}
+
 MODULE_AUTHOR("Philippe Cornu <philippe.cornu@st.com>");
 MODULE_AUTHOR("Yannick Fertre <yannick.fertre@st.com>");
 MODULE_AUTHOR("Fabien Dessenne <fabien.dessenne@st.com>");
diff --git a/drivers/gpu/drm/stm/ltdc.h b/drivers/gpu/drm/stm/ltdc.h
index d44f7a6f710d..f6880ffdbe79 100644
--- a/drivers/gpu/drm/stm/ltdc.h
+++ b/drivers/gpu/drm/stm/ltdc.h
@@ -69,9 +69,11 @@ struct ltdc_device {
 	struct reserved_mem *rot_mem;
 };
 
+int ltdc_parse_device_tree(struct device *dev);
+int ltdc_get_clk(struct device *dev, struct ltdc_device *ldev);
 int ltdc_load(struct drm_device *ddev);
 void ltdc_unload(struct drm_device *ddev);
-void ltdc_suspend(struct drm_device *ddev);
-int ltdc_resume(struct drm_device *ddev);
+void ltdc_suspend(struct ltdc_device *ldev);
+int ltdc_resume(struct ltdc_device *ldev);
 
 #endif
-- 
2.39.5

