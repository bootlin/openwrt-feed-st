From 73c7bd9330662db1492a51a222dd3e662461d197 Mon Sep 17 00:00:00 2001
From: Yannick Fertre <yannick.fertre@foss.st.com>
Date: Thu, 5 Sep 2024 15:49:21 +0200
Subject: [PATCH] drm/stm: ltdc: remove mode_set_nofb callback

This reminder is optional& could be move to the crtc_atomic_enable
callback. Updating the plan should be done without using the bpcr
register which is set only when crtc is enabled.

Change-Id: Iff65c613d1536ade56794e8f7ce0c8e98b54d3e9
Signed-off-by: Yannick Fertre <yannick.fertre@foss.st.com>
Reviewed-on: https://gerrit.st.com/c/mpu/oe/st/linux-stm32/+/399596
ACI: CITOOLS <MDG-smet-aci-reviews@list.st.com>
ACI: CIBUILD <MDG-smet-aci-builds@list.st.com>
---
 drivers/gpu/drm/stm/ltdc.c | 276 ++++++++++++++++---------------------
 1 file changed, 115 insertions(+), 161 deletions(-)

diff --git a/drivers/gpu/drm/stm/ltdc.c b/drivers/gpu/drm/stm/ltdc.c
index 8ceca74a6680..480f71936881 100644
--- a/drivers/gpu/drm/stm/ltdc.c
+++ b/drivers/gpu/drm/stm/ltdc.c
@@ -799,6 +799,8 @@ static void ltdc_crtc_atomic_enable(struct drm_crtc *crtc,
 	struct drm_encoder *encoder = NULL, *en_iter;
 	struct drm_bridge *bridge = NULL, *br_iter;
 	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+	u32 hsync, vsync, accum_hbp, accum_vbp, accum_act_w, accum_act_h;
+	u32 total_width, total_height;
 	int orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
 	u32 bus_formats = MEDIA_BUS_FMT_RGB888_1X24;
 	u32 bus_flags = 0;
@@ -808,6 +810,9 @@ static void ltdc_crtc_atomic_enable(struct drm_crtc *crtc,
 
 	DRM_DEBUG_DRIVER("\n");
 
+	if (pm_runtime_active(ddev->dev))
+		pm_runtime_put_sync_suspend(ddev->dev);
+
 	/* get encoder from crtc */
 	drm_for_each_encoder(en_iter, ddev)
 		if (en_iter->crtc == crtc) {
@@ -841,14 +846,106 @@ static void ltdc_crtc_atomic_enable(struct drm_crtc *crtc,
 		orientation = connector->display_info.panel_orientation;
 	}
 
-	if (!pm_runtime_active(ddev->dev)) {
-		ret = pm_runtime_get_sync(ddev->dev);
-		if (ret) {
-			DRM_ERROR("Failed to set mode, cannot get sync\n");
-			return;
+	if (encoder->encoder_type == DRM_MODE_ENCODER_LVDS) {
+		if (ldev->lvds_clk) {
+			ret = clk_set_parent(ldev->pixel_clk, ldev->lvds_clk);
+			if (ret) {
+				DRM_ERROR("Could not set parent clock: %d\n", ret);
+				return;
+			}
+		}
+	} else {
+		if (ldev->ltdc_clk) {
+			ret = clk_set_parent(ldev->pixel_clk, ldev->ltdc_clk);
+			if (ret) {
+				DRM_ERROR("Could not set parent clock: %d\n", ret);
+				return;
+			}
 		}
 	}
 
+	if (clk_set_rate(ldev->pixel_clk, mode->clock * 1000) < 0) {
+		DRM_ERROR("Cannot set rate (%dHz) for pixel clk\n", mode->clock * 1000);
+		return;
+	}
+
+	/*
+	 * Set to default state the pinctrl only with DPI type.
+	 * Others types like DSI, don't need pinctrl due to
+	 * internal bridge (the signals do not come out of the chipset).
+	 */
+	if (encoder->encoder_type == DRM_MODE_ENCODER_DPI)
+		pinctrl_pm_select_default_state(ddev->dev);
+	else
+		pinctrl_pm_select_sleep_state(ddev->dev);
+
+	ret = pm_runtime_get_sync(ddev->dev);
+	if (ret) {
+		DRM_ERROR("Failed to set mode, cannot get sync\n");
+		return;
+	}
+
+	DRM_DEBUG_DRIVER("CRTC:%d mode:%s\n", crtc->base.id, mode->name);
+	DRM_DEBUG_DRIVER("Video mode: %dx%d", mode->hdisplay, mode->vdisplay);
+	DRM_DEBUG_DRIVER(" hfp %d hbp %d hsl %d vfp %d vbp %d vsl %d\n",
+			 mode->hsync_start - mode->hdisplay,
+			 mode->htotal - mode->hsync_end,
+			 mode->hsync_end - mode->hsync_start,
+			 mode->vsync_start - mode->vdisplay,
+			 mode->vtotal - mode->vsync_end,
+			 mode->vsync_end - mode->vsync_start);
+
+	/* Convert video timings to ltdc timings */
+	hsync = mode->hsync_end - mode->hsync_start - 1;
+	vsync = mode->vsync_end - mode->vsync_start - 1;
+	accum_hbp = mode->htotal - mode->hsync_start - 1;
+	accum_vbp = mode->vtotal - mode->vsync_start - 1;
+	accum_act_w = accum_hbp + mode->hdisplay;
+	accum_act_h = accum_vbp + mode->vdisplay;
+	total_width = mode->htotal - 1;
+	total_height = mode->vtotal - 1;
+
+	/* check that an output rotation is required */
+	if (ldev->caps.crtc_rotation &&
+	    (orientation == DRM_MODE_PANEL_ORIENTATION_LEFT_UP ||
+	     orientation == DRM_MODE_PANEL_ORIENTATION_RIGHT_UP)) {
+		/* Set Synchronization size */
+		val = (vsync << 16) | hsync;
+		regmap_update_bits(ldev->regmap, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
+
+		/* Set Accumulated Back porch */
+		val = (accum_vbp << 16) | accum_hbp;
+		regmap_update_bits(ldev->regmap, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
+
+		/* Set Accumulated Active Width */
+		val = (accum_act_h << 16) | accum_act_w;
+		regmap_update_bits(ldev->regmap, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
+
+		/* Set total width & height */
+		val = (total_height << 16) | total_width;
+		regmap_update_bits(ldev->regmap, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
+
+		regmap_write(ldev->regmap, LTDC_LIPCR, (accum_act_w + 1));
+	} else {
+		/* Set Synchronization size */
+		val = (hsync << 16) | vsync;
+		regmap_update_bits(ldev->regmap, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
+
+		/* Set Accumulated Back porch */
+		val = (accum_hbp << 16) | accum_vbp;
+		regmap_update_bits(ldev->regmap, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
+
+		/* Set Accumulated Active Width */
+		val = (accum_act_w << 16) | accum_act_h;
+		regmap_update_bits(ldev->regmap, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
+
+		/* Set total width & height */
+		val = (total_width << 16) | total_height;
+		regmap_update_bits(ldev->regmap, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
+
+		regmap_write(ldev->regmap, LTDC_LIPCR, (accum_act_h + 1));
+	}
+
 	/* Configures the HS, VS, DE and PC polarities. Default Active Low */
 	val = 0;
 
@@ -1019,149 +1116,6 @@ static void ltdc_crtc_atomic_disable(struct drm_crtc *crtc,
 	mutex_unlock(&ldev->err_lock);
 }
 
-static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
-{
-	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
-	struct drm_device *ddev = crtc->dev;
-	struct drm_connector_list_iter iter;
-	struct drm_connector *connector = NULL;
-	struct drm_encoder *encoder = NULL, *en_iter;
-	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
-	int orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
-	int rate = mode->clock * 1000;
-	u32 hsync, vsync, accum_hbp, accum_vbp, accum_act_w, accum_act_h;
-	u32 total_width, total_height;
-	u32 val;
-	int ret;
-
-	DRM_DEBUG_DRIVER("\n");
-
-	/* disable to stream frame if previous session is still alive */
-	if (pm_runtime_active(ddev->dev)) {
-		regmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);
-		pm_runtime_put_sync_suspend(ddev->dev);
-	}
-
-	/* get encoder from crtc */
-	drm_for_each_encoder(en_iter, ddev)
-		if (en_iter->crtc == crtc) {
-			encoder = en_iter;
-			break;
-		}
-
-	if (encoder) {
-		/* Get the connector from encoder */
-		drm_connector_list_iter_begin(ddev, &iter);
-		drm_for_each_connector_iter(connector, &iter)
-			if (connector->encoder == encoder)
-				break;
-		drm_connector_list_iter_end(&iter);
-	}
-
-	if (connector)
-		orientation = connector->display_info.panel_orientation;
-
-	if (encoder->encoder_type == DRM_MODE_ENCODER_LVDS) {
-		if (ldev->lvds_clk) {
-			ret = clk_set_parent(ldev->pixel_clk, ldev->lvds_clk);
-			if (ret) {
-				DRM_ERROR("Could not set parent clock: %d\n", ret);
-				return;
-			}
-		}
-	} else {
-		if (ldev->ltdc_clk) {
-			ret = clk_set_parent(ldev->pixel_clk, ldev->ltdc_clk);
-			if (ret) {
-				DRM_ERROR("Could not set parent clock: %d\n", ret);
-				return;
-			}
-		}
-	}
-
-	if (clk_set_rate(ldev->pixel_clk, rate) < 0) {
-		DRM_ERROR("Cannot set rate (%dHz) for pixel clk\n", rate);
-		return;
-	}
-
-	/*
-	 * Set to default state the pinctrl only with DPI type.
-	 * Others types like DSI, don't need pinctrl due to
-	 * internal bridge (the signals do not come out of the chipset).
-	 */
-	if (encoder->encoder_type == DRM_MODE_ENCODER_DPI)
-		pinctrl_pm_select_default_state(ddev->dev);
-	else
-		pinctrl_pm_select_sleep_state(ddev->dev);
-
-	ret = pm_runtime_get_sync(ddev->dev);
-	if (ret) {
-		DRM_ERROR("Failed to set mode, cannot get sync\n");
-		return;
-	}
-
-	DRM_DEBUG_DRIVER("CRTC:%d mode:%s\n", crtc->base.id, mode->name);
-	DRM_DEBUG_DRIVER("Video mode: %dx%d", mode->hdisplay, mode->vdisplay);
-	DRM_DEBUG_DRIVER(" hfp %d hbp %d hsl %d vfp %d vbp %d vsl %d\n",
-			 mode->hsync_start - mode->hdisplay,
-			 mode->htotal - mode->hsync_end,
-			 mode->hsync_end - mode->hsync_start,
-			 mode->vsync_start - mode->vdisplay,
-			 mode->vtotal - mode->vsync_end,
-			 mode->vsync_end - mode->vsync_start);
-
-	/* Convert video timings to ltdc timings */
-	hsync = mode->hsync_end - mode->hsync_start - 1;
-	vsync = mode->vsync_end - mode->vsync_start - 1;
-	accum_hbp = mode->htotal - mode->hsync_start - 1;
-	accum_vbp = mode->vtotal - mode->vsync_start - 1;
-	accum_act_w = accum_hbp + mode->hdisplay;
-	accum_act_h = accum_vbp + mode->vdisplay;
-	total_width = mode->htotal - 1;
-	total_height = mode->vtotal - 1;
-
-	/* check that an output rotation is required */
-	if (ldev->caps.crtc_rotation &&
-	    (orientation == DRM_MODE_PANEL_ORIENTATION_LEFT_UP ||
-	     orientation == DRM_MODE_PANEL_ORIENTATION_RIGHT_UP)) {
-		/* Set Synchronization size */
-		val = (vsync << 16) | hsync;
-		regmap_update_bits(ldev->regmap, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
-
-		/* Set Accumulated Back porch */
-		val = (accum_vbp << 16) | accum_hbp;
-		regmap_update_bits(ldev->regmap, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
-
-		/* Set Accumulated Active Width */
-		val = (accum_act_h << 16) | accum_act_w;
-		regmap_update_bits(ldev->regmap, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
-
-		/* Set total width & height */
-		val = (total_height << 16) | total_width;
-		regmap_update_bits(ldev->regmap, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
-
-		regmap_write(ldev->regmap, LTDC_LIPCR, (accum_act_w + 1));
-	} else {
-		/* Set Synchronization size */
-		val = (hsync << 16) | vsync;
-		regmap_update_bits(ldev->regmap, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
-
-		/* Set Accumulated Back porch */
-		val = (accum_hbp << 16) | accum_vbp;
-		regmap_update_bits(ldev->regmap, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
-
-		/* Set Accumulated Active Width */
-		val = (accum_act_w << 16) | accum_act_h;
-		regmap_update_bits(ldev->regmap, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
-
-		/* Set total width & height */
-		val = (total_width << 16) | total_height;
-		regmap_update_bits(ldev->regmap, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
-
-		regmap_write(ldev->regmap, LTDC_LIPCR, (accum_act_h + 1));
-	}
-}
-
 static void ltdc_crtc_atomic_flush(struct drm_crtc *crtc,
 				   struct drm_atomic_state *state)
 {
@@ -1255,7 +1209,6 @@ static bool ltdc_crtc_get_scanout_position(struct drm_crtc *crtc,
 }
 
 static const struct drm_crtc_helper_funcs ltdc_crtc_helper_funcs = {
-	.mode_set_nofb = ltdc_crtc_mode_set_nofb,
 	.atomic_flush = ltdc_crtc_atomic_flush,
 	.atomic_enable = ltdc_crtc_atomic_enable,
 	.atomic_disable = ltdc_crtc_atomic_disable,
@@ -1472,11 +1425,10 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	struct ltdc_device *ldev = plane_to_ltdc(plane);
 	struct drm_device *ddev = plane->dev;
 	struct device *dev = ddev->dev;
-	struct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state,
-									  plane);
+	struct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state, plane);
 	struct drm_framebuffer *fb = newstate->fb;
 	u32 lofs = plane->index * LAY_OFS;
-	u32 val, pitch_in_bytes, line_length, line_number, ahbp, avbp, bpcr;
+	u32 val, pitch_in_bytes, line_length, line_number, ahbp, avbp;
 	u32 paddr, paddr1, paddr2, lxcr;
 	enum ltdc_pix_fmt pf;
 	unsigned int plane_rotation = newstate->rotation;
@@ -1484,6 +1436,7 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	struct drm_connector *connector = NULL;
 	struct drm_encoder *encoder = NULL, *en_iter;
 	struct drm_rect dst, src;
+	struct drm_display_mode *mode;
 	int orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
 
 	if (!newstate->crtc || !fb) {
@@ -1520,17 +1473,21 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	DRM_DEBUG_DRIVER("plane:%d fb:%d src: " DRM_RECT_FMT " -> crtc: " DRM_RECT_FMT "\n",
 			 plane->base.id, fb->base.id, DRM_RECT_ARG(&src), DRM_RECT_ARG(&dst));
 
-	if (!pm_runtime_active(ddev->dev))
-		return;
+	if (!pm_runtime_active(ddev->dev)) {
+		if (pm_runtime_get_sync(ddev->dev)) {
+			DRM_ERROR("Failed to set plane, cannot get sync\n");
+			return;
+		}
+	}
 
-	regmap_read(ldev->regmap, LTDC_BPCR, &bpcr);
+	/* Get horizontal & vertical back porch values */
+	mode = &newstate->crtc->state->adjusted_mode;
+	avbp = mode->vtotal - mode->vsync_start - 1;
+	ahbp = mode->htotal - mode->hsync_start - 1;
 
 	if (ldev->caps.crtc_rotation &&
 	    (orientation == DRM_MODE_PANEL_ORIENTATION_RIGHT_UP ||
 	     orientation == DRM_MODE_PANEL_ORIENTATION_LEFT_UP)) {
-		avbp = (bpcr & BPCR_AHBP) >> 16;
-		ahbp = bpcr & BPCR_AVBP;
-
 		/* Configures the horizontal start and stop position */
 		val = (dst.x1 + 1 + ahbp) + ((dst.x2 + ahbp) << 16);
 		regmap_write_bits(ldev->regmap, LTDC_L1WHPCR + lofs,
@@ -1563,9 +1520,6 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 				plane_rotation |= DRM_MODE_REFLECT_Y;
 		}
 	} else {
-		ahbp = (bpcr & BPCR_AHBP) >> 16;
-		avbp = bpcr & BPCR_AVBP;
-
 		/* Configures the horizontal start and stop position */
 		val = ((dst.x2 + ahbp) << 16) + (dst.x1 + 1 + ahbp);
 		regmap_write_bits(ldev->regmap, LTDC_L1WHPCR + lofs,
-- 
2.39.5

