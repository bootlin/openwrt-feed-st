From b90306b377d394378689604a800547f73e2ce10e Mon Sep 17 00:00:00 2001
From: Yannick Fertre <yannick.fertre@foss.st.com>
Date: Fri, 26 Jan 2024 10:50:51 +0100
Subject: [PATCH] drm/stm: ltdc:  add property default-on

Add support of a new property 'default-on' to avoid reset
of LTDC at probe and keep the pm runtime active.

Change-Id: I0258c843ab17cfaa0377bc9a91c2b3002eda1d76
Signed-off-by: Yannick Fertre <yannick.fertre@foss.st.com>
---
 drivers/gpu/drm/stm/ltdc.c | 32 ++++++++++++++++++++++++++------
 1 file changed, 26 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/stm/ltdc.c b/drivers/gpu/drm/stm/ltdc.c
index fd07a16db3c2..807452eb2dfe 100644
--- a/drivers/gpu/drm/stm/ltdc.c
+++ b/drivers/gpu/drm/stm/ltdc.c
@@ -1876,8 +1876,12 @@ static void ltdc_plane_atomic_disable(struct drm_plane *plane,
 	struct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,
 									  plane);
 	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_device *ddev = plane->dev;
 	u32 lofs = plane->index * LAY_OFS;
 
+	if (!pm_runtime_active(ddev->dev))
+		return;
+
 	/* Disable layer */
 	regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_MASK, 0);
 
@@ -2280,6 +2284,7 @@ int ltdc_load(struct drm_device *ddev)
 	int irq, i, nb_endpoints;
 	int ret = -ENODEV;
 	u32 mbl;
+	bool def_value;
 
 	DRM_DEBUG_DRIVER("\n");
 
@@ -2337,10 +2342,18 @@ int ltdc_load(struct drm_device *ddev)
 	mutex_init(&ldev->err_lock);
 	mutex_init(&ldev->act_lock);
 
-	if (!IS_ERR(rstc)) {
-		reset_control_assert(rstc);
-		usleep_range(10, 20);
-		reset_control_deassert(rstc);
+	def_value = device_property_read_bool(dev, "default-on");
+
+	/*
+	 * To obtain a continuous display after the probe, the clocks must
+	 * remain activated and reset shouldn't be done
+	 */
+	if (!def_value) {
+		if (!IS_ERR(rstc)) {
+			reset_control_assert(rstc);
+			usleep_range(10, 20);
+			reset_control_deassert(rstc);
+		}
 	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -2416,10 +2429,17 @@ int ltdc_load(struct drm_device *ddev)
 		goto err;
 	}
 
-	pinctrl_pm_select_sleep_state(ddev->dev);
-
+	pm_runtime_set_active(ddev->dev);
 	pm_runtime_enable(ddev->dev);
 
+	if (def_value) {
+		/* keep runtime active after the probe */
+		pm_runtime_get_sync(ddev->dev);
+	} else {
+		/* set to sleep state the pinctrl to stop data trasfert */
+		pinctrl_pm_select_sleep_state(ddev->dev);
+	}
+
 	/* Get the secure rotation buffer memory resource */
 	np = of_parse_phandle(dev->of_node, "rotation-memory", 0);
 	if (np)
-- 
2.39.5

