From 1bc5bac552579c1d164fd5a1b1192f8763279631 Mon Sep 17 00:00:00 2001
From: Yannick Fertre <yannick.fertre@foss.st.com>
Date: Tue, 21 May 2024 09:03:03 +0200
Subject: [PATCH] drm/stm: support of new hardware version for soc MP21

This hardware support a pad frequency of 150000000Hz.
Bus clock is an optional clock which is not present on legacy chipset.

Change-Id: I78021768297dbac5fb4c2e5137e044b0435c10ce
Signed-off-by: Yannick Fertre <yannick.fertre@foss.st.com>
Reviewed-on: https://gerrit.st.com/c/mpu/oe/st/linux-stm32/+/381182
ACI: CITOOLS <MDG-smet-aci-reviews@list.st.com>
ACI: CIBUILD <MDG-smet-aci-builds@list.st.com>
---
 drivers/gpu/drm/stm/drv.c  |  5 +++++
 drivers/gpu/drm/stm/ltdc.c | 13 +++++++++++--
 2 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/stm/drv.c b/drivers/gpu/drm/stm/drv.c
index 6ae9fadc3d13..0c8c14477d77 100644
--- a/drivers/gpu/drm/stm/drv.c
+++ b/drivers/gpu/drm/stm/drv.c
@@ -281,12 +281,17 @@ static struct ltdc_plat_data stm_drm_plat_data = {
 	.pad_max_freq_hz = 90000000,
 };
 
+static struct ltdc_plat_data stm_drm_plat_data_mp21 = {
+	.pad_max_freq_hz = 150000000,
+};
+
 static struct ltdc_plat_data stm_drm_plat_data_mp25 = {
 	.pad_max_freq_hz = 150000000,
 };
 
 static const struct of_device_id drv_dt_ids[] = {
 	{ .compatible = "st,stm32-ltdc", .data = &stm_drm_plat_data, },
+	{ .compatible = "st,stm32mp21-ltdc", .data = &stm_drm_plat_data_mp21, },
 	{ .compatible = "st,stm32mp25-ltdc", .data = &stm_drm_plat_data_mp25, },
 	{ /* end node */ },
 };
diff --git a/drivers/gpu/drm/stm/ltdc.c b/drivers/gpu/drm/stm/ltdc.c
index 0521d57e6e65..d5d84e7f124d 100644
--- a/drivers/gpu/drm/stm/ltdc.c
+++ b/drivers/gpu/drm/stm/ltdc.c
@@ -1751,7 +1751,8 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	}
 
 	/* Configure burst length */
-	if (of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc"))
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp21-ltdc") ||
+	    of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc"))
 		regmap_write(ldev->regmap, LTDC_L1BLCR + lofs, ldev->max_burst_length);
 
 	/* set color look-up table */
@@ -2364,7 +2365,8 @@ int ltdc_load(struct drm_device *ddev)
 	if (!nb_endpoints)
 		return -ENODEV;
 
-	if (of_device_is_compatible(np, "st,stm32mp25-ltdc")) {
+	if (of_device_is_compatible(np, "st,stm32mp21-ltdc") ||
+	    of_device_is_compatible(np, "st,stm32mp25-ltdc")) {
 		/* Get max burst length */
 		ret = of_property_read_u32(np, "st,burstlen", &mbl);
 		if (ret)
@@ -2591,6 +2593,13 @@ int ltdc_get_clk(struct device *dev, struct ltdc_device *ldev)
 		return PTR_ERR(ldev->pixel_clk);
 	}
 
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp21-ltdc")) {
+		ldev->bus_clk = devm_clk_get(dev, "bus");
+		if (IS_ERR(ldev->bus_clk))
+			return dev_err_probe(dev, PTR_ERR(ldev->bus_clk),
+					     "Unable to get bus clock\n");
+	}
+
 	if (of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc")) {
 		ldev->bus_clk = devm_clk_get(dev, "bus");
 		if (IS_ERR(ldev->bus_clk))
-- 
2.39.5

