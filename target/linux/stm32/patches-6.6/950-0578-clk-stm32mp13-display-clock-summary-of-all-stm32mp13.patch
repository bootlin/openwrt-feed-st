From 542ae4cd0fb04fc6d7935f52cf63feb2fe7b24bf Mon Sep 17 00:00:00 2001
From: Gabriel Fernandez <gabriel.fernandez@foss.st.com>
Date: Thu, 13 Oct 2022 17:46:28 +0200
Subject: [PATCH] clk: stm32mp13: display clock summary of all stm32mp13 clocks

Display all clocks (secure included) in specific clock summary.

cat /sys/kernel/debug/clk/stm32_clk_summary

Change-Id: I03ce2ed2788880ca15beb82bf30272de4ac726ac
Signed-off-by: Gabriel Fernandez <gabriel.fernandez@foss.st.com>
Reviewed-on: https://gerrit.st.com/c/mpu/oe/st/linux-stm32/+/257569
Reviewed-by: CITOOLS <MDG-smet-aci-reviews@list.st.com>
Reviewed-by: CIBUILD <MDG-smet-aci-builds@list.st.com>
Reviewed-by: Alexandre TORGUE <alexandre.torgue@foss.st.com>
---
 drivers/clk/stm32/clk-stm32-core.c |  169 ++++-
 drivers/clk/stm32/clk-stm32-core.h |   37 +
 drivers/clk/stm32/clk-stm32mp13.c  | 1001 ++++++++++++++++++++++++++++
 3 files changed, 1196 insertions(+), 11 deletions(-)

diff --git a/drivers/clk/stm32/clk-stm32-core.c b/drivers/clk/stm32/clk-stm32-core.c
index c50c97293bfb..4d3c2d2f40c7 100644
--- a/drivers/clk/stm32/clk-stm32-core.c
+++ b/drivers/clk/stm32/clk-stm32-core.c
@@ -19,6 +19,9 @@
 
 static DEFINE_SPINLOCK(rlock);
 
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data);
+
 static int stm32_rcc_clock_init(struct device *dev,
 				const struct of_device_id *match,
 				void __iomem *base)
@@ -27,6 +30,7 @@ static int stm32_rcc_clock_init(struct device *dev,
 	struct clk_hw_onecell_data *clk_data = data->hw_clks;
 	struct clk_hw **hws;
 	int n, max_binding;
+	int ret;
 
 	max_binding =  data->maxbinding;
 
@@ -34,6 +38,8 @@ static int stm32_rcc_clock_init(struct device *dev,
 	if (!clk_data)
 		return -ENOMEM;
 
+	data->clock_data->base = base;
+
 	clk_data->num = max_binding;
 
 	hws = clk_data->hws;
@@ -63,7 +69,14 @@ static int stm32_rcc_clock_init(struct device *dev,
 			hws[cfg_clock->id] = hw;
 	}
 
-	return devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	if (data->clock_summary)
+		stm32_clk_summary_debugfs_create(dev, data);
+
+	return ret;
 }
 
 int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
@@ -98,9 +111,9 @@ int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
 	return 0;
 }
 
-static u8 stm32_mux_get_parent(void __iomem *base,
-			       struct clk_stm32_clock_data *data,
-			       u16 mux_id)
+u8 stm32_mux_get_parent(void __iomem *base,
+			struct clk_stm32_clock_data *data,
+			u16 mux_id)
 {
 	const struct stm32_mux_cfg *mux = &data->muxes[mux_id];
 	u32 mask = BIT(mux->width) - 1;
@@ -195,9 +208,9 @@ static void stm32_gate_disable_unused(void __iomem *base,
 		writel(readl(addr) & ~BIT(gate->bit_idx), addr);
 }
 
-static int stm32_gate_is_enabled(void __iomem *base,
-				 struct clk_stm32_clock_data *data,
-				 u16 gate_id)
+int stm32_gate_is_enabled(void __iomem *base,
+			  struct clk_stm32_clock_data *data,
+			  u16 gate_id)
 {
 	const struct stm32_gate_cfg *gate = &data->gates[gate_id];
 
@@ -227,10 +240,10 @@ static unsigned int _get_div(const struct clk_div_table *table,
 	return val + 1;
 }
 
-static unsigned long stm32_divider_get_rate(void __iomem *base,
-					    struct clk_stm32_clock_data *data,
-					    u16 div_id,
-					    unsigned long parent_rate)
+unsigned long stm32_divider_get_rate(void __iomem *base,
+				     struct clk_stm32_clock_data *data,
+				     u16 div_id,
+				     unsigned long parent_rate)
 {
 	const struct stm32_div_cfg *divider = &data->dividers[div_id];
 	unsigned int val;
@@ -764,3 +777,137 @@ struct clk_hw *clk_stm32_composite_register(struct device *dev,
 
 	return hw;
 }
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+
+static void rcc_summary_show_one(struct seq_file *s, const char *name,
+				 unsigned long rate,
+				 bool is_enabled,
+				 int level)
+{
+	seq_printf(s, "%*s%-*s %11lu  %9c\n",
+		   level * 3 + 1, "",
+		   40 - level * 3,
+		   name,
+		   rate,
+		   is_enabled ? 'Y' : 'N'
+		);
+}
+
+static struct clk_summary *stm32_cs_get_parent(struct clk_stm32_clock_data *data,
+					       struct clk_summary *c)
+{
+	struct clk_summary *parent = NULL;
+
+	switch (c->nb_parents) {
+	case 0:
+		parent = NULL;
+		break;
+	case 1:
+		parent = c->clks[0];
+		break;
+	default:
+		if (c->get_parent)
+			parent = c->clks[c->get_parent(data, c)];
+	}
+
+	return parent;
+}
+
+static bool stm32_cs_is_enabled(struct clk_stm32_clock_data *data, struct clk_summary *c)
+{
+	if (c->is_enabled) {
+		return c->is_enabled(data, c);
+
+	} else if (c->nb_parents > 0) {
+		struct clk_summary *cs_parent = stm32_cs_get_parent(data, c);
+
+		return stm32_cs_is_enabled(data, cs_parent);
+	}
+
+	return true;
+}
+
+static unsigned long stm32_cs_get_rate(struct clk_stm32_clock_data *data,
+				       struct clk_summary *c,
+				       unsigned long parent_rate)
+{
+	unsigned long rate = 0;
+
+	if (c->get_rate)
+		rate = c->get_rate(data, c, parent_rate);
+	else
+		rate = parent_rate;
+
+	return rate;
+}
+
+static void rcc_summary_show_subtree(struct seq_file *s, struct clk_summary *c,
+				     unsigned long parent_rate, int level)
+{
+	struct stm32_rcc_match_data *match_data = (struct stm32_rcc_match_data *)s->private;
+	struct clk_stm32_clock_data *data = match_data->clock_data;
+	struct clock_summary *cs = match_data->clock_summary;
+	unsigned long rate;
+	int is_enabled;
+	int i;
+
+	rate = stm32_cs_get_rate(data, c, parent_rate);
+	is_enabled = stm32_cs_is_enabled(data, c);
+
+	rcc_summary_show_one(s, c->name, rate, is_enabled, level);
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *child = cs->clocks[i];
+		struct clk_summary *parent;
+
+		parent = stm32_cs_get_parent(data, child);
+		if (!parent)
+			continue;
+
+		if (c == parent)
+			rcc_summary_show_subtree(s, child, rate, level + 1);
+	}
+}
+
+static int rcc_summary_show(struct seq_file *s, void *data)
+{
+	struct stm32_rcc_match_data *match_data = (struct stm32_rcc_match_data *)s->private;
+	struct clock_summary *cs = match_data->clock_summary;
+
+	int i;
+
+	seq_puts(s, "                                                        hardware\n");
+	seq_puts(s, "   clock                                         rate     enable\n");
+	seq_puts(s, "----------------------------------------------------------------\n");
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *c = cs->clocks[i];
+
+		if (c->nb_parents == 0)
+			rcc_summary_show_subtree(s, c, 0, 0);
+	}
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(rcc_summary);
+
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data)
+{
+	struct dentry *rootdir = debugfs_lookup("clk", NULL);
+
+	debugfs_create_file("stm32_clk_summary", 0444, rootdir, (void *)data, &rcc_summary_fops);
+}
+
+#else
+
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data)
+
+{
+}
+#endif
diff --git a/drivers/clk/stm32/clk-stm32-core.h b/drivers/clk/stm32/clk-stm32-core.h
index 4be103710e12..ce34705e4678 100644
--- a/drivers/clk/stm32/clk-stm32-core.h
+++ b/drivers/clk/stm32/clk-stm32-core.h
@@ -57,6 +57,7 @@ struct clock_config {
 };
 
 struct clk_stm32_clock_data {
+	void __iomem			*base;
 	u16 *gate_cpt;
 	const struct stm32_gate_cfg	*gates;
 	const struct stm32_mux_cfg	*muxes;
@@ -64,6 +65,28 @@ struct clk_stm32_clock_data {
 	struct clk_hw *(*is_multi_mux)(struct clk_hw *hw);
 };
 
+struct clock_summary {
+	int nb_clocks;
+	struct clk_summary **clocks;
+};
+
+struct clk_summary {
+	const char *name;
+	int gate_id;
+	int mux_id;
+	int div_id;
+	void *data;
+	bool (*is_enabled)(struct clk_stm32_clock_data *data,
+			   struct clk_summary *c);
+	u8 (*get_parent)(struct clk_stm32_clock_data *data,
+			 struct clk_summary *c);
+	unsigned long (*get_rate)(struct clk_stm32_clock_data *data,
+				  struct clk_summary *c,
+				  unsigned long parent_rate);
+	int nb_parents;
+	struct clk_summary **clks;
+};
+
 struct stm32_rcc_match_data {
 	struct clk_hw_onecell_data	*hw_clks;
 	unsigned int			num_clocks;
@@ -74,11 +97,25 @@ struct stm32_rcc_match_data {
 	int (*check_security)(struct device_node *np, void __iomem *base,
 			      const struct clock_config *cfg);
 	int (*multi_mux)(void __iomem *base, const struct clock_config *cfg);
+	struct clock_summary		*clock_summary;
 };
 
 int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
 		   void __iomem *base);
 
+int stm32_gate_is_enabled(void __iomem *base,
+			  struct clk_stm32_clock_data *data,
+			  u16 gate_id);
+
+unsigned long stm32_divider_get_rate(void __iomem *base,
+				     struct clk_stm32_clock_data *data,
+				     u16 div_id,
+				     unsigned long parent_rate);
+
+u8 stm32_mux_get_parent(void __iomem *base,
+			struct clk_stm32_clock_data *data,
+			u16 mux_id);
+
 /* MUX define */
 #define MUX_NO_RDY		0xFF
 #define MUX_SAFE		BIT(7)
diff --git a/drivers/clk/stm32/clk-stm32mp13.c b/drivers/clk/stm32/clk-stm32mp13.c
index e5bc5e66bce6..93dca87bea9a 100644
--- a/drivers/clk/stm32/clk-stm32mp13.c
+++ b/drivers/clk/stm32/clk-stm32mp13.c
@@ -18,6 +18,55 @@
 
 /* STM32 Gates definition */
 enum enum_gate_cfg {
+#ifdef CONFIG_DEBUG_FS
+	GATE_LSE,
+	GATE_LSE_RDY,
+	GATE_LSI,
+	GATE_LSI_RDY,
+	GATE_HSI,
+	GATE_HSI_RDY,
+	GATE_CSI,
+	GATE_CSI_RDY,
+	GATE_HSE,
+	GATE_HSE_RDY,
+	GATE_PLL1,
+	GATE_PLL1_RDY,
+	GATE_PLL2,
+	GATE_PLL2_RDY,
+	GATE_PLL3,
+	GATE_PLL3_RDY,
+	GATE_PLL4,
+	GATE_PLL4_RDY,
+	GATE_HSIDIVRDY,
+	GATE_MPUSRCRDY,
+	GATE_AXISSRCRDY,
+	GATE_MCUSSRCRDY,
+	GATE_PLL12SRCRDY,
+	GATE_PLL3SRCRDY,
+	GATE_PLL4SRCRDY,
+	GATE_MPUDIVRDY,
+	GATE_AXIDIVRDY,
+	GATE_MLAHBDIVRDY,
+	GATE_APB1DIVRDY,
+	GATE_APB2DIVRDY,
+	GATE_APB3DIVRDY,
+	GATE_APB4DIVRDY,
+	GATE_APB5DIVRDY,
+	GATE_APB6DIVRDY,
+	GATE_RTCCK,
+	GATE_PLL1_DIVP,
+	GATE_PLL1_DIVQ,
+	GATE_PLL1_DIVR,
+	GATE_PLL2_DIVP,
+	GATE_PLL2_DIVQ,
+	GATE_PLL2_DIVR,
+	GATE_PLL3_DIVP,
+	GATE_PLL3_DIVQ,
+	GATE_PLL3_DIVR,
+	GATE_PLL4_DIVP,
+	GATE_PLL4_DIVQ,
+	GATE_PLL4_DIVR,
+#endif
 	GATE_MCO1,
 	GATE_MCO2,
 	GATE_DBGCK,
@@ -151,6 +200,55 @@ enum enum_gate_cfg {
 	_CFG_GATE(_id, _offset, _bit_idx, RCC_CLR_OFFSET)
 
 static struct stm32_gate_cfg stm32mp13_gates[] = {
+#ifdef CONFIG_DEBUG_FS
+	CFG_GATE(GATE_LSE,		RCC_BDCR,		0),
+	CFG_GATE(GATE_LSE_RDY,		RCC_BDCR,		2),
+	CFG_GATE(GATE_RTCCK,		RCC_BDCR,		20),
+	CFG_GATE(GATE_LSI,		RCC_RDLSICR,		0),
+	CFG_GATE(GATE_LSI_RDY,		RCC_RDLSICR,		1),
+	CFG_GATE_SETCLR(GATE_HSI,	RCC_OCENSETR,		0),
+	CFG_GATE(GATE_HSI_RDY,		RCC_OCRDYR,		0),
+	CFG_GATE_SETCLR(GATE_CSI,	RCC_OCENSETR,		4),
+	CFG_GATE(GATE_CSI_RDY,		RCC_OCRDYR,		4),
+	CFG_GATE_SETCLR(GATE_HSE,	RCC_OCENSETR,		8),
+	CFG_GATE(GATE_HSE_RDY,		RCC_OCRDYR,		8),
+	CFG_GATE(GATE_HSIDIVRDY,	RCC_OCRDYR,		2),
+	CFG_GATE(GATE_MPUSRCRDY,	RCC_MPCKSELR,		31),
+	CFG_GATE(GATE_AXISSRCRDY,	RCC_ASSCKSELR,		31),
+	CFG_GATE(GATE_MCUSSRCRDY,	RCC_MSSCKSELR,		31),
+	CFG_GATE(GATE_PLL12SRCRDY,	RCC_RCK12SELR,		31),
+	CFG_GATE(GATE_PLL3SRCRDY,	RCC_RCK3SELR,		31),
+	CFG_GATE(GATE_PLL4SRCRDY,	RCC_RCK4SELR,		31),
+	CFG_GATE(GATE_MPUDIVRDY,	RCC_MPCKDIVR,		31),
+	CFG_GATE(GATE_AXIDIVRDY,	RCC_AXIDIVR,		31),
+	CFG_GATE(GATE_MLAHBDIVRDY,	RCC_MLAHBDIVR,		31),
+	CFG_GATE(GATE_APB1DIVRDY,	RCC_APB1DIVR,		31),
+	CFG_GATE(GATE_APB2DIVRDY,	RCC_APB2DIVR,		31),
+	CFG_GATE(GATE_APB3DIVRDY,	RCC_APB3DIVR,		31),
+	CFG_GATE(GATE_APB4DIVRDY,	RCC_APB4DIVR,		31),
+	CFG_GATE(GATE_APB5DIVRDY,	RCC_APB5DIVR,		31),
+	CFG_GATE(GATE_APB6DIVRDY,	RCC_APB6DIVR,		31),
+	CFG_GATE(GATE_PLL1,		RCC_PLL1CR,		0),
+	CFG_GATE(GATE_PLL1_RDY,		RCC_PLL1CR,		1),
+	CFG_GATE(GATE_PLL1_DIVP,	RCC_PLL1CR,		4),
+	CFG_GATE(GATE_PLL1_DIVQ,	RCC_PLL1CR,		5),
+	CFG_GATE(GATE_PLL1_DIVR,	RCC_PLL1CR,		6),
+	CFG_GATE(GATE_PLL2,		RCC_PLL2CR,		0),
+	CFG_GATE(GATE_PLL2_RDY,		RCC_PLL2CR,		1),
+	CFG_GATE(GATE_PLL2_DIVP,	RCC_PLL2CR,		4),
+	CFG_GATE(GATE_PLL2_DIVQ,	RCC_PLL2CR,		5),
+	CFG_GATE(GATE_PLL2_DIVR,	RCC_PLL2CR,		6),
+	CFG_GATE(GATE_PLL3,		RCC_PLL3CR,		0),
+	CFG_GATE(GATE_PLL3_RDY,		RCC_PLL3CR,		1),
+	CFG_GATE(GATE_PLL3_DIVP,	RCC_PLL3CR,		4),
+	CFG_GATE(GATE_PLL3_DIVQ,	RCC_PLL3CR,		5),
+	CFG_GATE(GATE_PLL3_DIVR,	RCC_PLL3CR,		6),
+	CFG_GATE(GATE_PLL4,		RCC_PLL4CR,		0),
+	CFG_GATE(GATE_PLL4_RDY,		RCC_PLL4CR,		1),
+	CFG_GATE(GATE_PLL4_DIVP,	RCC_PLL4CR,		4),
+	CFG_GATE(GATE_PLL4_DIVQ,	RCC_PLL4CR,		5),
+	CFG_GATE(GATE_PLL4_DIVR,	RCC_PLL4CR,		6),
+#endif
 	CFG_GATE(GATE_MCO1,		RCC_MCO1CFGR,		12),
 	CFG_GATE(GATE_MCO2,		RCC_MCO2CFGR,		12),
 	CFG_GATE(GATE_DBGCK,		RCC_DBGCFGR,		8),
@@ -271,6 +369,27 @@ static struct stm32_gate_cfg stm32mp13_gates[] = {
 
 /* STM32 Divivers definition */
 enum enum_div_cfg {
+#ifdef CONFIG_DEBUG_FS
+	DIV_PLL1DIVP,
+	DIV_PLL2DIVP,
+	DIV_PLL2DIVQ,
+	DIV_PLL2DIVR,
+	DIV_PLL3DIVP,
+	DIV_PLL3DIVQ,
+	DIV_PLL3DIVR,
+	DIV_PLL4DIVP,
+	DIV_PLL4DIVQ,
+	DIV_PLL4DIVR,
+	DIV_MPU,
+	DIV_AXI,
+	DIV_MLAHB,
+	DIV_APB1,
+	DIV_APB2,
+	DIV_APB3,
+	DIV_APB4,
+	DIV_APB5,
+	DIV_APB6,
+#endif
 	DIV_RTC,
 	DIV_HSI,
 	DIV_MCO1,
@@ -281,6 +400,28 @@ enum enum_div_cfg {
 	DIV_NB
 };
 
+#ifdef CONFIG_DEBUG_FS
+static const struct clk_div_table axi_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },
+	{ 4, 4 }, { 5, 4 }, { 6, 4 }, { 7, 4 },
+	{ 0 },
+};
+
+static const struct clk_div_table mlahb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 32 }, { 6, 64 }, { 7, 128 },
+	{ 8, 256 }, { 9, 512 }, { 10, 512}, { 11, 512 },
+	{ 12, 512 }, { 13, 512 }, { 14, 512}, { 15, 512 },
+	{ 0 },
+};
+
+static const struct clk_div_table apb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
+	{ 0 },
+};
+#endif
+
 static const struct clk_div_table ck_trace_div_table[] = {
 	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
 	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
@@ -298,6 +439,29 @@ static const struct clk_div_table ck_trace_div_table[] = {
 	}
 
 static const struct stm32_div_cfg stm32mp13_dividers[DIV_NB] = {
+#ifdef CONFIG_DEBUG_FS
+	CFG_DIV(DIV_MPU, RCC_MPCKDIVR, 0, 4, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_AXI, RCC_AXIDIVR, 0, 3, 0, axi_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_MLAHB, RCC_MLAHBDIVR, 0, 4, 0, mlahb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB1, RCC_APB1DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB2, RCC_APB2DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB3, RCC_APB3DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB4, RCC_APB4DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB5, RCC_APB5DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB6, RCC_APB6DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_HSI, RCC_HSICFGR, 0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL, DIV_NO_RDY),
+
+	CFG_DIV(DIV_PLL1DIVP, RCC_PLL1CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVP, RCC_PLL2CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVQ, RCC_PLL2CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVR, RCC_PLL2CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVP, RCC_PLL3CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVQ, RCC_PLL3CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVR, RCC_PLL3CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVP, RCC_PLL4CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVQ, RCC_PLL4CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVR, RCC_PLL4CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+#endif
 	CFG_DIV(DIV_RTC, RCC_RTCDIVR, 0, 6, 0, NULL, DIV_NO_RDY),
 	CFG_DIV(DIV_MCO1, RCC_MCO1CFGR, 4, 4, 0, NULL, DIV_NO_RDY),
 	CFG_DIV(DIV_MCO2, RCC_MCO2CFGR, 4, 4, 0, NULL, DIV_NO_RDY),
@@ -308,6 +472,16 @@ static const struct stm32_div_cfg stm32mp13_dividers[DIV_NB] = {
 
 /* STM32 Muxes definition */
 enum enum_mux_cfg {
+#ifdef CONFIG_DEBUG_FS
+	MUX_MPU,
+	MUX_AXI,
+	MUX_MLAHB,
+	MUX_PLL12,
+	MUX_PLL3,
+	MUX_PLL4,
+	MUX_RTC,
+	MUX_CKPER,
+#endif
 	MUX_ADC1,
 	MUX_ADC2,
 	MUX_DCMIPP,
@@ -365,6 +539,16 @@ enum enum_mux_cfg {
 	_CFG_MUX(_id, _offset, _shift, _witdh, MUX_NO_RDY, MUX_SAFE)
 
 static const struct stm32_mux_cfg stm32mp13_muxes[] = {
+#ifdef CONFIG_DEBUG_FS
+	CFG_MUX(MUX_MPU,	RCC_MPCKSELR,		0, 2),
+	CFG_MUX(MUX_AXI,	RCC_ASSCKSELR,		0, 3),
+	CFG_MUX(MUX_MLAHB,	RCC_MSSCKSELR,		0, 2),
+	CFG_MUX(MUX_PLL12,	RCC_RCK12SELR,		0, 2),
+	CFG_MUX(MUX_PLL3,	RCC_RCK3SELR,		0, 2),
+	CFG_MUX(MUX_PLL4,	RCC_RCK4SELR,		0, 2),
+	CFG_MUX(MUX_CKPER,	RCC_CPERCKSELR,		0, 2),
+	CFG_MUX(MUX_RTC,	RCC_BDCR,		16, 2),
+#endif
 	CFG_MUX(MUX_I2C12,	RCC_I2C12CKSELR,	0, 3),
 	CFG_MUX(MUX_LPTIM45,	RCC_LPTIM45CKSELR,	0, 3),
 	CFG_MUX(MUX_SPI23,	RCC_SPI2S23CKSELR,	0, 3),
@@ -1535,6 +1719,10 @@ static struct clk_hw *stm32mp13_is_multi_mux(struct clk_hw *hw)
 
 static u16 stm32mp13_cpt_gate[GATE_NB];
 
+#ifdef CONFIG_DEBUG_FS
+static struct clock_summary clock_summary_mp13;
+#endif
+
 static struct clk_stm32_clock_data stm32mp13_clock_data = {
 	.gate_cpt	= stm32mp13_cpt_gate,
 	.gates		= stm32mp13_gates,
@@ -1556,6 +1744,9 @@ static const struct stm32_rcc_match_data stm32mp13_data = {
 	.check_security = &stm32mp13_clock_is_provided_by_secure,
 	.maxbinding	= STM32MP1_LAST_CLK,
 	.reset_data	= &stm32mp13_reset_data,
+#ifdef CONFIG_DEBUG_FS
+	.clock_summary	= &clock_summary_mp13,
+#endif
 };
 
 static const struct of_device_id stm32mp13_match_data[] = {
@@ -1592,3 +1783,813 @@ static int __init stm32mp13_clocks_init(void)
 	return platform_driver_register(&stm32mp13_rcc_clocks_driver);
 }
 core_initcall(stm32mp13_clocks_init);
+
+#ifdef CONFIG_DEBUG_FS
+
+static bool cs_stm32_gate_is_enabled(struct clk_stm32_clock_data *data, struct clk_summary *c)
+{
+	return stm32_gate_is_enabled(data->base, data, c->gate_id);
+}
+
+static u8 cs_stm32_mux_get_parent(struct clk_stm32_clock_data *data, struct clk_summary *c)
+{
+	return stm32_mux_get_parent(data->base, data, c->mux_id);
+}
+
+static unsigned long cs_stm32_div_get_rate(struct clk_stm32_clock_data *data,
+					   struct clk_summary *c,
+					   unsigned long parent_rate)
+{
+	return stm32_divider_get_rate(data->base, data, c->div_id, parent_rate);
+}
+
+static unsigned long cs_stm32_get_rate_by_name(struct clk_stm32_clock_data *data,
+					       struct clk_summary *c,
+					       unsigned long parent_rate)
+{
+	struct clk *clk = __clk_lookup(c->name);
+
+	if (clk)
+		return clk_get_rate(clk);
+
+	return 0;
+}
+
+static unsigned long cs_hsediv2_recalc_rate(struct clk_stm32_clock_data *data,
+					    struct clk_summary *c,
+					    unsigned long parent_rate)
+{
+	return parent_rate / 2;
+}
+
+/* STM32 PLL */
+struct clk_pll_fractional_divider {
+	struct clk_hw hw;
+	void __iomem *mreg;
+	u8 mshift;
+	u8 mwidth;
+	u8 mflags;
+	void __iomem *nreg;
+	u8 nshift;
+	u8 nwidth;
+	u8 nflags;
+	void __iomem *freg;
+	u8 fshift;
+	u8 fwidth;
+};
+
+struct cs_pll {
+	u32 offset;
+};
+
+#define PLL_BIT_ON		0
+#define PLL_BIT_RDY		1
+#define PLL_MUX_SHIFT		0
+#define PLL_MUX_MASK		3
+#define PLL_DIVMN_OFFSET	4
+#define PLL_DIVM_SHIFT		16
+#define PLL_DIVM_WIDTH		6
+#define PLL_DIVN_SHIFT		0
+#define PLL_DIVN_WIDTH		9
+#define PLL_FRAC_OFFSET		0xC
+#define PLL_FRAC_SHIFT		3
+#define PLL_FRAC_WIDTH		13
+
+static unsigned long cs_stm32_pll_recalc_rate(struct clk_stm32_clock_data *data,
+					      struct clk_summary *c,
+					      unsigned long parent_rate)
+{
+	struct cs_pll *pll = (struct cs_pll *)c->data;
+	struct clk_pll_fractional_divider fracdiv;
+	struct clk_pll_fractional_divider *fd = &fracdiv;
+	void __iomem *reg;
+	u32 mmask;
+	u32 nmask;
+	u32 fmask;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	reg = data->base + pll->offset;
+	fd->mreg = reg + PLL_DIVMN_OFFSET;
+	fd->mshift = PLL_DIVM_SHIFT;
+	fd->mwidth = PLL_DIVM_WIDTH;
+	fd->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->nreg = reg + PLL_DIVMN_OFFSET;
+	fd->nshift = PLL_DIVN_SHIFT;
+	fd->nwidth = PLL_DIVN_WIDTH;
+	fd->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->freg = reg + PLL_FRAC_OFFSET;
+	fd->fshift = PLL_FRAC_SHIFT;
+	fd->fwidth = PLL_FRAC_WIDTH;
+
+	mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
+
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
+
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
+	}
+
+	return rate + frate;
+}
+
+/* The divider of RTC clock concerns only ck_hse clock */
+#define HSE_RTC 3
+
+static unsigned long cs_rtc_recalc_rate(struct clk_stm32_clock_data *data,
+					struct clk_summary *c,
+					unsigned long parent_rate)
+{
+	u8 parent;
+
+	parent = stm32_mux_get_parent(data->base, data, c->mux_id);
+	if (parent == HSE_RTC)
+		return stm32_divider_get_rate(data->base, data, c->div_id, parent_rate);
+
+	return parent_rate;
+}
+
+struct cs_stm32_timer {
+	u32 apbdiv;
+	u32 timpre;
+};
+
+#define APB_DIV_MASK 0x07
+#define TIM_PRE_MASK 0x01
+
+static unsigned long cs_stm32_timer_recalc_rate(struct clk_stm32_clock_data *data,
+						struct clk_summary *c,
+						unsigned long parent_rate)
+{
+	struct cs_stm32_timer *tim = (struct cs_stm32_timer *)c->data;
+	void __iomem *rcc_base = data->base;
+	u32 prescaler, timpre;
+
+	prescaler = readl(rcc_base + tim->apbdiv) & APB_DIV_MASK;
+
+	timpre = readl(rcc_base + tim->timpre) & TIM_PRE_MASK;
+
+	if (prescaler == 0U)
+		return parent_rate;
+
+	return parent_rate * (timpre + 1U) * 2U;
+}
+
+#define CS_CLOCK(_name) (&cs_##_name)
+
+#define CS_GATE(_name, _parent, _gate)						\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= (_gate),					\
+		.is_enabled	= cs_stm32_gate_is_enabled,			\
+		.nb_parents	= 1,						\
+		.clks		= (struct clk_summary *[]) {  &cs_##_parent },	\
+	}
+
+#define CS_MUX(_name, _parents, _mux)						\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= NO_STM32_GATE,				\
+		.mux_id		= (_mux),					\
+		.div_id		= NO_STM32_DIV,					\
+		.get_parent	= cs_stm32_mux_get_parent,			\
+		.nb_parents	= ARRAY_SIZE(_parents),				\
+		.clks		= _parents,					\
+	}
+
+#define CS_DIV(_name, _parent, _div)						\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= NO_STM32_GATE,				\
+		.mux_id		= NO_STM32_MUX,					\
+		.div_id		= _div,						\
+		.get_rate	= cs_stm32_div_get_rate,			\
+		.nb_parents	= 1,						\
+		.clks		= (struct clk_summary *[]) {  &cs_##_parent },	\
+	}
+
+#define CS_MUX_DIV(_name, _parents, _mux,  _div)				\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= NO_STM32_GATE,				\
+		.mux_id		= (_mux),					\
+		.div_id		= (_div),					\
+		.get_rate	= cs_stm32_div_get_rate,			\
+		.get_parent	= cs_stm32_mux_get_parent,			\
+		.nb_parents	= ARRAY_SIZE(_parents),				\
+		.clks		= _parents,					\
+	}
+
+#define CS_GATE_MUX(_name, _parents, _gate, _mux)				\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= (_gate),					\
+		.mux_id		= (_mux),					\
+		.div_id		= NO_STM32_DIV,					\
+		.is_enabled	= cs_stm32_gate_is_enabled,			\
+		.get_parent	= cs_stm32_mux_get_parent,			\
+		.nb_parents	= ARRAY_SIZE(_parents),				\
+		.clks		= _parents,					\
+	}
+
+#define CS_GATE_DIV(_name, _parent, _gate,  _div)				\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= (_gate),					\
+		.mux_id		= NO_STM32_MUX,					\
+		.div_id		= (_div),					\
+		.is_enabled	= cs_stm32_gate_is_enabled,			\
+		.get_rate	= cs_stm32_div_get_rate,			\
+		.nb_parents	= 1,						\
+		.clks		= (struct clk_summary *[]) {  &cs_##_parent },	\
+	}
+
+#define CS_GATE_MUX_DIV(_name, _parents, _gate, _mux, _div)			\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= (_gate),					\
+		.mux_id		= (_mux),					\
+		.div_id		= (_div),					\
+		.is_enabled	= cs_stm32_gate_is_enabled,			\
+		.get_rate	= cs_stm32_div_get_rate,			\
+		.get_parent	= cs_stm32_mux_get_parent,			\
+		.nb_parents	= ARRAY_SIZE(_parents),				\
+		.clks		= _parents,					\
+	}
+
+#define CS_OSC_EXT(_name, _gate_id)						\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= _gate_id,					\
+		.mux_id		= NO_STM32_MUX,					\
+		.div_id		= NO_STM32_DIV,					\
+		.is_enabled	= cs_stm32_gate_is_enabled,			\
+		.get_rate	= cs_stm32_get_rate_by_name,			\
+		.nb_parents	= 0,						\
+	}
+
+#define CS_OSC_INT(_name, _gate_id) CS_OSC_EXT(_name, _gate_id)
+
+#define CS_EXT(_name)								\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= NO_STM32_GATE,				\
+		.mux_id		= NO_STM32_MUX,					\
+		.div_id		= NO_STM32_DIV,					\
+		.get_rate	= cs_stm32_get_rate_by_name,			\
+		.nb_parents	= 0,\
+	}
+
+#define CS_HSE_DIV2(_name, _parent)						\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= NO_STM32_GATE,				\
+		.mux_id		= NO_STM32_MUX,					\
+		.div_id		= NO_STM32_DIV,					\
+		.get_rate	= cs_hsediv2_recalc_rate,			\
+		.nb_parents	= 1,						\
+		.clks		= (struct clk_summary *[]) {  &cs_##_parent },	\
+	}
+
+#define CS_PLL(_name, _parents, _gate, _mux, _offset)				\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= (_gate),					\
+		.mux_id		= (_mux),					\
+		.div_id		= NO_STM32_DIV,					\
+		.data		=  &(struct cs_pll) {				\
+			.offset		= _offset,				\
+		},								\
+		.is_enabled	= cs_stm32_gate_is_enabled,			\
+		.get_rate	= cs_stm32_pll_recalc_rate,			\
+		.get_parent	= cs_stm32_mux_get_parent,			\
+		.nb_parents	= ARRAY_SIZE(_parents),				\
+		.clks		= _parents,					\
+	}
+
+#define CS_STM32_TIMER(_name, _parent, _apbdiv, _timpre)			\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.data		=  &(struct cs_stm32_timer) {			\
+			.apbdiv		= _apbdiv,				\
+			.timpre		= _timpre,				\
+		},								\
+		.get_rate	= cs_stm32_timer_recalc_rate,			\
+		.nb_parents	= 1,						\
+		.clks		= (struct clk_summary *[]) {  &cs_##_parent },	\
+	}
+
+#define CS_RTC(_name, _parents, _gate, _mux, _div)				\
+	static struct clk_summary cs_##_name = {				\
+		.name		= #_name,					\
+		.gate_id	= (_gate),					\
+		.mux_id		= (_mux),					\
+		.div_id		= (_div),					\
+		.is_enabled	= cs_stm32_gate_is_enabled,			\
+		.get_rate	= cs_rtc_recalc_rate,				\
+		.get_parent	= cs_stm32_mux_get_parent,			\
+		.nb_parents	= ARRAY_SIZE(_parents),				\
+		.clks		= _parents,					\
+	}
+
+CS_OSC_INT(ck_hsi, GATE_HSI);
+CS_OSC_INT(ck_lsi, GATE_LSI);
+CS_OSC_INT(ck_csi, GATE_CSI);
+CS_OSC_EXT(ck_hse, GATE_HSE);
+
+CS_OSC_EXT(ck_lse, GATE_LSE);
+
+CS_EXT(ck_usbo_48m);
+CS_EXT(i2s_ckin);
+CS_EXT(spdif_ck_symb);
+
+CS_HSE_DIV2(hse_div2_ck, ck_hse);
+
+static struct clk_summary *cs_ref12_parents[] = {
+	CS_CLOCK(ck_hsi), CS_CLOCK(ck_hse)
+};
+
+static struct clk_summary *cs_ref3_parents[] = {
+	CS_CLOCK(ck_hsi), CS_CLOCK(ck_hse), CS_CLOCK(ck_csi)
+};
+
+static struct clk_summary *cs_ref4_parents[] = {
+	CS_CLOCK(ck_hsi), CS_CLOCK(ck_hse), CS_CLOCK(ck_csi), CS_CLOCK(i2s_ckin)
+};
+
+CS_PLL(pll1, cs_ref12_parents, GATE_PLL1, MUX_PLL12, RCC_PLL1CR);
+CS_GATE_DIV(pll1_p, pll1, GATE_PLL1_DIVP, DIV_PLL1DIVP);
+CS_DIV(pll1_p_div, pll1_p, DIV_MPU);
+
+CS_PLL(pll2, cs_ref12_parents, GATE_PLL2, MUX_PLL12, RCC_PLL2CR);
+CS_GATE_DIV(pll2_p, pll2, GATE_PLL2_DIVP, DIV_PLL2DIVP);
+CS_GATE_DIV(pll2_q, pll2, GATE_PLL2_DIVQ, DIV_PLL2DIVQ);
+CS_GATE_DIV(pll2_r, pll2, GATE_PLL2_DIVR, DIV_PLL2DIVR);
+
+CS_PLL(pll3, cs_ref3_parents, GATE_PLL3, MUX_PLL3, RCC_PLL3CR);
+CS_GATE_DIV(pll3_p, pll3, GATE_PLL3_DIVP, DIV_PLL3DIVP);
+CS_GATE_DIV(pll3_q, pll3, GATE_PLL3_DIVQ, DIV_PLL3DIVQ);
+CS_GATE_DIV(pll3_r, pll3, GATE_PLL3_DIVR, DIV_PLL3DIVR);
+
+CS_PLL(pll4, cs_ref4_parents, GATE_PLL4, MUX_PLL4, RCC_PLL4CR);
+CS_GATE_DIV(pll4_p, pll4, GATE_PLL4_DIVP, DIV_PLL4DIVP);
+CS_GATE_DIV(pll4_q, pll4, GATE_PLL4_DIVQ, DIV_PLL4DIVQ);
+CS_GATE_DIV(pll4_r, pll4, GATE_PLL4_DIVR, DIV_PLL4DIVR);
+
+static struct clk_summary *cs_cpu_src[] = {
+	CS_CLOCK(ck_hsi), CS_CLOCK(ck_hse), CS_CLOCK(pll1_p), CS_CLOCK(pll1_p_div)
+};
+
+static struct clk_summary *cs_axi_src[] = {
+	CS_CLOCK(ck_hsi), CS_CLOCK(ck_hse), CS_CLOCK(pll2_p)
+};
+
+static struct clk_summary *cs_mlahb_src[] = {
+	CS_CLOCK(ck_hsi), CS_CLOCK(ck_hse), CS_CLOCK(ck_csi), CS_CLOCK(pll3_p)
+};
+
+static struct clk_summary *cs_per_src[] = {
+	CS_CLOCK(ck_hsi), CS_CLOCK(ck_csi), CS_CLOCK(ck_hse)
+};
+
+static struct clk_summary *cs_rtc_src[] = {
+	NULL, CS_CLOCK(ck_lse), CS_CLOCK(ck_lsi), CS_CLOCK(ck_hse)
+};
+
+CS_MUX(ck_mpu, cs_cpu_src, MUX_MPU);
+CS_MUX(ck_axi, cs_axi_src, MUX_AXI);
+CS_MUX(ck_mlahb, cs_mlahb_src, MUX_MLAHB);
+CS_MUX(ck_per, cs_per_src, MUX_CKPER);
+
+CS_DIV(pclk1, ck_mlahb, DIV_APB1);
+CS_DIV(pclk2, ck_mlahb, DIV_APB2);
+CS_DIV(pclk3, ck_mlahb, DIV_APB3);
+CS_DIV(pclk4, ck_axi, DIV_APB4);
+CS_DIV(pclk5, ck_axi, DIV_APB5);
+CS_DIV(pclk6, ck_mlahb, DIV_APB6);
+
+CS_STM32_TIMER(timg1_ck, pclk1, RCC_APB1DIVR, RCC_TIMG1PRER);
+CS_STM32_TIMER(timg2_ck, pclk2, RCC_APB2DIVR, RCC_TIMG2PRER);
+CS_STM32_TIMER(timg3_ck, pclk1, RCC_APB6DIVR, RCC_TIMG3PRER);
+
+CS_GATE(tim2_k, timg1_ck, GATE_TIM2);
+CS_GATE(tim3_k, timg1_ck, GATE_TIM3);
+CS_GATE(tim4_k, timg1_ck, GATE_TIM4);
+CS_GATE(tim5_k, timg1_ck, GATE_TIM5);
+CS_GATE(tim6_k, timg1_ck, GATE_TIM6);
+CS_GATE(tim7_k, timg1_ck, GATE_TIM7);
+CS_GATE(tim1_k, timg2_ck, GATE_TIM1);
+CS_GATE(tim8_k, timg2_ck, GATE_TIM8);
+CS_GATE(tim12_k, timg3_ck, GATE_TIM12);
+CS_GATE(tim13_k, timg3_ck, GATE_TIM13);
+CS_GATE(tim14_k, timg3_ck, GATE_TIM14);
+CS_GATE(tim15_k, timg3_ck, GATE_TIM15);
+CS_GATE(tim16_k, timg3_ck, GATE_TIM16);
+CS_GATE(tim17_k, timg3_ck, GATE_TIM17);
+CS_GATE(spi2, pclk1, GATE_SPI2);
+CS_GATE(spi3, pclk1, GATE_SPI3);
+CS_GATE(sai1, pclk2, GATE_SAI1);
+CS_GATE(sai2, pclk2, GATE_SAI2);
+CS_GATE(spi1, pclk2, GATE_SPI1);
+CS_GATE(syscfg, pclk3, GATE_SYSCFG);
+CS_GATE(vref, pclk3, GATE_VREF);
+CS_GATE(dts, pclk3, GATE_DTS);
+CS_GATE(pmbctrl, pclk3, GATE_PMBCTRL);
+CS_GATE(hdp, pclk3, GATE_HDP);
+CS_GATE(iwdg2, pclk4, GATE_IWDG2APB);
+CS_GATE(stgenro, pclk4, GATE_STGENRO);
+CS_GATE(gpioa, pclk4, GATE_GPIOA);
+CS_GATE(gpiob, pclk4, GATE_GPIOB);
+CS_GATE(gpioc, pclk4, GATE_GPIOC);
+CS_GATE(gpiod, pclk4, GATE_GPIOD);
+CS_GATE(gpioe, pclk4, GATE_GPIOE);
+CS_GATE(gpiof, pclk4, GATE_GPIOF);
+CS_GATE(gpiog, pclk4, GATE_GPIOG);
+CS_GATE(gpioh, pclk4, GATE_GPIOH);
+CS_GATE(gpioi, pclk4, GATE_GPIOI);
+CS_GATE(tsc, pclk4, GATE_TSC);
+CS_GATE(ddrperfm, pclk4, GATE_DDRPERFM);
+CS_GATE(tzpc, pclk5, GATE_TZC);
+CS_GATE(iwdg1, pclk5, GATE_IWDG1APB);
+CS_GATE(bsec, pclk5, GATE_BSEC);
+CS_GATE(spi4, pclk6, GATE_SPI4);
+CS_GATE(spi5, pclk6, GATE_SPI5);
+CS_GATE(dma1, ck_mlahb, GATE_DMA1);
+CS_GATE(dma2, ck_mlahb, GATE_DMA2);
+CS_GATE(dmamux1, ck_mlahb, GATE_DMAMUX1);
+CS_GATE(dma3, ck_mlahb, GATE_DMA3);
+CS_GATE(dmamux2, ck_mlahb, GATE_DMAMUX2);
+CS_GATE(adc1, ck_mlahb, GATE_ADC1);
+CS_GATE(adc2, ck_mlahb, GATE_ADC2);
+CS_GATE(pka, ck_axi, GATE_PKA);
+CS_GATE(cryp1, ck_axi, GATE_CRYP1);
+CS_GATE(hash1, ck_axi, GATE_HASH1);
+CS_GATE(bkpsram, ck_axi, GATE_BKPSRAM);
+CS_GATE(mdma, ck_axi, GATE_MDMA);
+CS_GATE(eth1tx, ck_axi, GATE_ETH1TX);
+CS_GATE(eth1rx, ck_axi, GATE_ETH1RX);
+CS_GATE(eth1mac, ck_axi, GATE_ETH1MAC);
+CS_GATE(eth2tx, ck_axi, GATE_ETH2TX);
+CS_GATE(eth2rx, ck_axi, GATE_ETH2RX);
+CS_GATE(eth2mac, ck_axi, GATE_ETH2MAC);
+CS_GATE(crc1, ck_axi, GATE_CRC1);
+CS_GATE(usbh, ck_axi, GATE_USBH);
+CS_GATE(eth1stp, ck_axi, GATE_ETH1STP);
+CS_GATE(eth2stp, ck_axi, GATE_ETH2STP);
+CS_GATE(dfsdm_k, ck_mlahb, GATE_DFSDM);
+CS_GATE(ltdc_px, pll4_q, GATE_LTDC);
+CS_GATE(ck_sys_dbg, ck_axi, GATE_DBGCK);
+CS_GATE(rtcapb, pclk5, GATE_RTCAPB);
+CS_GATE_DIV(ck_trace, ck_axi, GATE_TRACECK, DIV_TRACE);
+
+static struct clk_summary *cs_adc12_src[] = {
+	CS_CLOCK(pll4_r), CS_CLOCK(ck_per), CS_CLOCK(pll3_q)
+};
+
+static struct clk_summary *cs_dcmipp_src[] = {
+	CS_CLOCK(ck_axi), CS_CLOCK(pll2_q), CS_CLOCK(pll4_p), CS_CLOCK(ck_per)
+};
+
+static struct clk_summary *cs_eth12_src[] = {
+	CS_CLOCK(pll4_p), CS_CLOCK(pll3_q)
+};
+
+static struct clk_summary *cs_fdcan_src[] = {
+	CS_CLOCK(ck_hse), CS_CLOCK(pll3_q), CS_CLOCK(pll4_q), CS_CLOCK(pll4_r)
+};
+
+static struct clk_summary *cs_fmc_src[] = {
+	CS_CLOCK(ck_axi), CS_CLOCK(pll3_r), CS_CLOCK(pll4_p), CS_CLOCK(ck_per)
+};
+
+static struct clk_summary *cs_i2c12_src[] = {
+	CS_CLOCK(pclk1), CS_CLOCK(pll4_r), CS_CLOCK(ck_hsi), CS_CLOCK(ck_csi)
+};
+
+static struct clk_summary *cs_i2c345_src[] = {
+	CS_CLOCK(pclk6), CS_CLOCK(pll4_r), CS_CLOCK(ck_hsi), CS_CLOCK(ck_csi)
+};
+
+static struct clk_summary *cs_lptim1_src[] = {
+	CS_CLOCK(pclk1), CS_CLOCK(pll4_p), CS_CLOCK(pll3_q),
+	CS_CLOCK(ck_lse), CS_CLOCK(ck_lsi), CS_CLOCK(ck_per)
+};
+
+static struct clk_summary *cs_lptim23_src[] = {
+	CS_CLOCK(pclk3), CS_CLOCK(pll4_q), CS_CLOCK(ck_per), CS_CLOCK(ck_lse), CS_CLOCK(ck_lsi)
+};
+
+static struct clk_summary *cs_lptim45_src[] = {
+	CS_CLOCK(pclk3), CS_CLOCK(pll4_p), CS_CLOCK(pll3_q),
+	CS_CLOCK(ck_lse), CS_CLOCK(ck_lsi), CS_CLOCK(ck_per)
+};
+
+static struct clk_summary *cs_mco1_src[] = {
+	CS_CLOCK(ck_hsi), CS_CLOCK(ck_hse), CS_CLOCK(ck_csi), CS_CLOCK(ck_lsi), CS_CLOCK(ck_lse)
+};
+
+static struct clk_summary *cs_mco2_src[] = {
+	CS_CLOCK(ck_mpu), CS_CLOCK(ck_axi), CS_CLOCK(ck_mlahb),
+	CS_CLOCK(pll4_p), CS_CLOCK(ck_hse), CS_CLOCK(ck_hsi)
+};
+
+static struct clk_summary *cs_qspi_src[] = {
+	CS_CLOCK(ck_axi), CS_CLOCK(pll3_r), CS_CLOCK(pll4_p), CS_CLOCK(ck_per)
+};
+
+static struct clk_summary *cs_rng1_src[] = {
+	CS_CLOCK(ck_csi), CS_CLOCK(pll4_r), NULL, CS_CLOCK(ck_lsi)
+};
+
+static struct clk_summary *cs_saes_src[] = {
+	CS_CLOCK(ck_axi), CS_CLOCK(ck_per), CS_CLOCK(pll4_r), CS_CLOCK(ck_lsi)
+};
+
+static struct clk_summary *cs_sai1_src[] = {
+	CS_CLOCK(pll4_q), CS_CLOCK(pll3_q), CS_CLOCK(i2s_ckin), CS_CLOCK(ck_per), CS_CLOCK(pll3_r)
+};
+
+static struct clk_summary *cs_sai2_src[] = {
+	CS_CLOCK(pll4_q), CS_CLOCK(pll3_q), CS_CLOCK(i2s_ckin),
+	CS_CLOCK(ck_per), CS_CLOCK(spdif_ck_symb), CS_CLOCK(pll3_r)
+};
+
+static struct clk_summary *cs_sdmmc12_src[] = {
+	CS_CLOCK(ck_axi), CS_CLOCK(pll3_r), CS_CLOCK(pll4_p), CS_CLOCK(ck_hsi)
+};
+
+static struct clk_summary *cs_spdif_src[] = {
+	CS_CLOCK(pll4_p), CS_CLOCK(pll3_q), CS_CLOCK(ck_hsi)
+};
+
+static struct clk_summary *cs_spi123_src[] = {
+	CS_CLOCK(pll4_p), CS_CLOCK(pll3_q), CS_CLOCK(i2s_ckin), CS_CLOCK(ck_per), CS_CLOCK(pll3_r)
+};
+
+static struct clk_summary *cs_spi4_src[] = {
+	CS_CLOCK(pclk6), CS_CLOCK(pll4_q), CS_CLOCK(ck_hsi),
+	CS_CLOCK(ck_csi), CS_CLOCK(ck_hse), CS_CLOCK(i2s_ckin)
+};
+
+static struct clk_summary *cs_spi5_src[] = {
+	CS_CLOCK(pclk6), CS_CLOCK(pll4_q), CS_CLOCK(ck_hsi), CS_CLOCK(ck_csi), CS_CLOCK(ck_hse)
+};
+
+static struct clk_summary *cs_stgen_src[] = {
+	CS_CLOCK(ck_hsi), CS_CLOCK(ck_hse)
+};
+
+static struct clk_summary *cs_usart12_src[] = {
+	CS_CLOCK(pclk6), CS_CLOCK(pll3_q), CS_CLOCK(ck_hsi),
+	CS_CLOCK(ck_csi), CS_CLOCK(pll4_q), CS_CLOCK(ck_hse)
+};
+
+static struct clk_summary *cs_usart34578_src[] = {
+	CS_CLOCK(pclk1), CS_CLOCK(pll4_q), CS_CLOCK(ck_hsi), CS_CLOCK(ck_csi), CS_CLOCK(ck_hse)
+};
+
+static struct clk_summary *cs_usart6_src[] = {
+	CS_CLOCK(pclk2), CS_CLOCK(pll4_q), CS_CLOCK(ck_hsi), CS_CLOCK(ck_csi), CS_CLOCK(ck_hse)
+};
+
+static struct clk_summary *cs_usbo_src[] = {
+	CS_CLOCK(pll4_r), CS_CLOCK(ck_usbo_48m)
+};
+
+static struct clk_summary *cs_usbphy_src[] = {
+	CS_CLOCK(ck_hse), CS_CLOCK(pll4_r), CS_CLOCK(hse_div2_ck)
+};
+
+CS_GATE_MUX(sdmmc1_k, cs_sdmmc12_src, GATE_SDMMC1, MUX_SDMMC1);
+CS_GATE_MUX(sdmmc2_k, cs_sdmmc12_src, GATE_SDMMC2, MUX_SDMMC2);
+CS_GATE_MUX(fmc_k, cs_fmc_src, GATE_FMC, MUX_FMC);
+CS_GATE_MUX(qspi_k, cs_qspi_src, GATE_QSPI, MUX_QSPI);
+CS_GATE_MUX(spi2_k, cs_spi123_src, GATE_SPI2, MUX_SPI23);
+CS_GATE_MUX(spi3_k, cs_spi123_src, GATE_SPI3, MUX_SPI23);
+CS_GATE_MUX(i2c1_k, cs_i2c12_src, GATE_I2C1, MUX_I2C12);
+CS_GATE_MUX(i2c2_k, cs_i2c12_src, GATE_I2C2, MUX_I2C12);
+CS_GATE_MUX(lptim4_k, cs_lptim45_src, GATE_LPTIM4, MUX_LPTIM45);
+CS_GATE_MUX(lptim5_k, cs_lptim45_src, GATE_LPTIM5, MUX_LPTIM45);
+CS_GATE_MUX(usart3_k, cs_usart34578_src, GATE_USART3, MUX_UART35);
+CS_GATE_MUX(uart5_k, cs_usart34578_src, GATE_UART5, MUX_UART35);
+CS_GATE_MUX(uart7_k, cs_usart34578_src, GATE_UART7, MUX_UART78);
+CS_GATE_MUX(uart8_k, cs_usart34578_src, GATE_UART8, MUX_UART78);
+CS_GATE_MUX(sai1_k, cs_sai1_src, GATE_SAI1, MUX_SAI1);
+CS_GATE_MUX(adfsdm_k, cs_sai1_src, GATE_ADFSDM, MUX_SAI1);
+CS_GATE_MUX(sai2_k, cs_sai2_src, GATE_SAI2, MUX_SAI2);
+CS_GATE_MUX(adc1_k, cs_adc12_src, GATE_ADC1, MUX_ADC1);
+CS_GATE_MUX(adc2_k, cs_adc12_src, GATE_ADC2, MUX_ADC2);
+CS_GATE_MUX(rng1_k, cs_rng1_src, GATE_RNG1, MUX_RNG1);
+CS_GATE_MUX(usbphy_k, cs_usbphy_src, GATE_USBPHY, MUX_USBPHY);
+CS_GATE_MUX(stgen_k, cs_stgen_src, GATE_STGENC, MUX_STGEN);
+CS_GATE_MUX(spdif_k, cs_spdif_src, GATE_SPDIF, MUX_SPDIF);
+CS_GATE_MUX(spi1_k, cs_spi123_src, GATE_SPI1, MUX_SPI1);
+CS_GATE_MUX(spi4_k, cs_spi4_src, GATE_SPI4, MUX_SPI4);
+CS_GATE_MUX(spi5_k, cs_spi5_src, GATE_SPI5, MUX_SPI5);
+CS_GATE_MUX(i2c3_k, cs_i2c345_src, GATE_I2C3, MUX_I2C3);
+CS_GATE_MUX(i2c4_k, cs_i2c345_src, GATE_I2C4, MUX_I2C4);
+CS_GATE_MUX(i2c5_k, cs_i2c345_src, GATE_I2C5, MUX_I2C5);
+CS_GATE_MUX(lptim1_k, cs_lptim1_src, GATE_LPTIM1, MUX_LPTIM1);
+CS_GATE_MUX(lptim2_k, cs_lptim23_src, GATE_LPTIM2, MUX_LPTIM2);
+CS_GATE_MUX(lptim3_k, cs_lptim23_src, GATE_LPTIM3, MUX_LPTIM3);
+CS_GATE_MUX(usart1_k, cs_usart12_src, GATE_USART1, MUX_UART1);
+CS_GATE_MUX(usart2_k, cs_usart12_src, GATE_USART2, MUX_UART2);
+CS_GATE_MUX(uart4_k, cs_usart34578_src, GATE_UART4, MUX_UART4);
+CS_GATE_MUX(uart6_k, cs_usart6_src, GATE_USART6, MUX_UART6);
+CS_GATE_MUX(fdcan_k, cs_fdcan_src, GATE_FDCAN, MUX_FDCAN);
+CS_GATE_MUX(dcmipp_k, cs_dcmipp_src, GATE_DCMIPP, MUX_DCMIPP);
+CS_GATE_MUX(usbo_k, cs_usbo_src, GATE_USBO, MUX_USBO);
+CS_GATE_MUX(eth1ck_k, cs_eth12_src, GATE_ETH1CK, MUX_ETH1);
+CS_GATE_MUX(eth2ck_k, cs_eth12_src, GATE_ETH2CK, MUX_ETH2);
+CS_GATE_MUX(saes_k, cs_saes_src, GATE_SAES, MUX_SAES);
+
+CS_MUX_DIV(eth1ptp_k, cs_eth12_src, MUX_ETH1, DIV_ETH1PTP);
+CS_MUX_DIV(eth2ptp_k, cs_eth12_src, MUX_ETH2, DIV_ETH2PTP);
+
+CS_GATE_MUX_DIV(ck_mco1, cs_mco1_src, GATE_MCO1, MUX_MCO1, DIV_MCO1);
+CS_GATE_MUX_DIV(ck_mco2, cs_mco2_src, GATE_MCO2, MUX_MCO2, DIV_MCO2);
+
+CS_RTC(ck_rtc, cs_rtc_src, GATE_RTCCK, MUX_RTC, DIV_RTC);
+
+static struct clk_summary *stm32mp13_clock_summary[] = {
+	CS_CLOCK(ck_hsi),
+	CS_CLOCK(ck_lsi),
+	CS_CLOCK(ck_csi),
+	CS_CLOCK(ck_hse),
+	CS_CLOCK(ck_lse),
+	CS_CLOCK(ck_usbo_48m),
+	CS_CLOCK(i2s_ckin),
+	CS_CLOCK(spdif_ck_symb),
+	CS_CLOCK(hse_div2_ck),
+	CS_CLOCK(pll1),
+	CS_CLOCK(pll1_p),
+	CS_CLOCK(pll1_p_div),
+	CS_CLOCK(pll2),
+	CS_CLOCK(pll2_p),
+	CS_CLOCK(pll2_q),
+	CS_CLOCK(pll2_r),
+	CS_CLOCK(pll3),
+	CS_CLOCK(pll3_p),
+	CS_CLOCK(pll3_q),
+	CS_CLOCK(pll3_r),
+	CS_CLOCK(pll4),
+	CS_CLOCK(pll4_p),
+	CS_CLOCK(pll4_q),
+	CS_CLOCK(pll4_r),
+	CS_CLOCK(ck_mpu),
+	CS_CLOCK(ck_axi),
+	CS_CLOCK(ck_mlahb),
+	CS_CLOCK(ck_per),
+	CS_CLOCK(pclk1),
+	CS_CLOCK(pclk2),
+	CS_CLOCK(pclk3),
+	CS_CLOCK(pclk4),
+	CS_CLOCK(pclk5),
+	CS_CLOCK(pclk6),
+	CS_CLOCK(timg1_ck),
+	CS_CLOCK(timg2_ck),
+	CS_CLOCK(timg3_ck),
+	CS_CLOCK(tim2_k),
+	CS_CLOCK(tim3_k),
+	CS_CLOCK(tim4_k),
+	CS_CLOCK(tim5_k),
+	CS_CLOCK(tim6_k),
+	CS_CLOCK(tim7_k),
+	CS_CLOCK(tim1_k),
+	CS_CLOCK(tim8_k),
+	CS_CLOCK(tim12_k),
+	CS_CLOCK(tim13_k),
+	CS_CLOCK(tim14_k),
+	CS_CLOCK(tim15_k),
+	CS_CLOCK(tim16_k),
+	CS_CLOCK(tim17_k),
+	CS_CLOCK(spi2),
+	CS_CLOCK(spi3),
+	CS_CLOCK(sai1),
+	CS_CLOCK(sai2),
+	CS_CLOCK(spi1),
+	CS_CLOCK(syscfg),
+	CS_CLOCK(vref),
+	CS_CLOCK(dts),
+	CS_CLOCK(pmbctrl),
+	CS_CLOCK(hdp),
+	CS_CLOCK(iwdg2),
+	CS_CLOCK(stgenro),
+	CS_CLOCK(gpioa),
+	CS_CLOCK(gpiob),
+	CS_CLOCK(gpioc),
+	CS_CLOCK(gpiod),
+	CS_CLOCK(gpioe),
+	CS_CLOCK(gpiof),
+	CS_CLOCK(gpiog),
+	CS_CLOCK(gpioh),
+	CS_CLOCK(gpioi),
+	CS_CLOCK(tsc),
+	CS_CLOCK(ddrperfm),
+	CS_CLOCK(tzpc),
+	CS_CLOCK(iwdg1),
+	CS_CLOCK(bsec),
+	CS_CLOCK(spi4),
+	CS_CLOCK(spi5),
+	CS_CLOCK(dma1),
+	CS_CLOCK(dma2),
+	CS_CLOCK(dmamux1),
+	CS_CLOCK(dma3),
+	CS_CLOCK(dmamux2),
+	CS_CLOCK(adc1),
+	CS_CLOCK(adc2),
+	CS_CLOCK(pka),
+	CS_CLOCK(cryp1),
+	CS_CLOCK(hash1),
+	CS_CLOCK(bkpsram),
+	CS_CLOCK(mdma),
+	CS_CLOCK(eth1tx),
+	CS_CLOCK(eth1rx),
+	CS_CLOCK(eth1mac),
+	CS_CLOCK(eth2tx),
+	CS_CLOCK(eth2rx),
+	CS_CLOCK(eth2mac),
+	CS_CLOCK(crc1),
+	CS_CLOCK(usbh),
+	CS_CLOCK(eth1stp),
+	CS_CLOCK(eth2stp),
+	CS_CLOCK(dfsdm_k),
+	CS_CLOCK(ltdc_px),
+	CS_CLOCK(ck_sys_dbg),
+	CS_CLOCK(rtcapb),
+	CS_CLOCK(ck_trace),
+	CS_CLOCK(sdmmc1_k),
+	CS_CLOCK(sdmmc2_k),
+	CS_CLOCK(fmc_k),
+	CS_CLOCK(qspi_k),
+	CS_CLOCK(spi2_k),
+	CS_CLOCK(spi3_k),
+	CS_CLOCK(i2c1_k),
+	CS_CLOCK(i2c2_k),
+	CS_CLOCK(lptim4_k),
+	CS_CLOCK(lptim5_k),
+	CS_CLOCK(usart3_k),
+	CS_CLOCK(uart5_k),
+	CS_CLOCK(uart7_k),
+	CS_CLOCK(uart8_k),
+	CS_CLOCK(sai1_k),
+	CS_CLOCK(adfsdm_k),
+	CS_CLOCK(sai2_k),
+	CS_CLOCK(adc1_k),
+	CS_CLOCK(adc2_k),
+	CS_CLOCK(rng1_k),
+	CS_CLOCK(usbphy_k),
+	CS_CLOCK(stgen_k),
+	CS_CLOCK(spdif_k),
+	CS_CLOCK(spi1_k),
+	CS_CLOCK(spi4_k),
+	CS_CLOCK(spi5_k),
+	CS_CLOCK(i2c3_k),
+	CS_CLOCK(i2c4_k),
+	CS_CLOCK(i2c5_k),
+	CS_CLOCK(lptim1_k),
+	CS_CLOCK(lptim2_k),
+	CS_CLOCK(lptim3_k),
+	CS_CLOCK(usart1_k),
+	CS_CLOCK(usart2_k),
+	CS_CLOCK(uart4_k),
+	CS_CLOCK(uart6_k),
+	CS_CLOCK(fdcan_k),
+	CS_CLOCK(dcmipp_k),
+	CS_CLOCK(usbo_k),
+	CS_CLOCK(eth1ck_k),
+	CS_CLOCK(eth2ck_k),
+	CS_CLOCK(saes_k),
+	CS_CLOCK(eth1ptp_k),
+	CS_CLOCK(eth2ptp_k),
+	CS_CLOCK(ck_mco1),
+	CS_CLOCK(ck_mco2),
+	CS_CLOCK(ck_rtc),
+};
+
+static struct clock_summary clock_summary_mp13 = {
+	.clocks		= stm32mp13_clock_summary,
+	.nb_clocks	= ARRAY_SIZE(stm32mp13_clock_summary),
+};
+
+#endif
-- 
2.39.5

