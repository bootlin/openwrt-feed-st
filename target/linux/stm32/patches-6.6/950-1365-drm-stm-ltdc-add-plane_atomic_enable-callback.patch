From 759efa7b495921ac36227f829bef35f94c771625 Mon Sep 17 00:00:00 2001
From: Yannick Fertre <yannick.fertre@foss.st.com>
Date: Fri, 6 Sep 2024 10:38:16 +0200
Subject: [PATCH] drm/stm: ltdc: add plane_atomic_enable callback

Ltdc driver should use this function to unconditionally enable a plane.

Change-Id: I83afb5c96203c710daddb8a7586a02f4601b6a5d
Signed-off-by: Yannick Fertre <yannick.fertre@foss.st.com>
Reviewed-on: https://gerrit.st.com/c/mpu/oe/st/linux-stm32/+/401517
ACI: CITOOLS <MDG-smet-aci-reviews@list.st.com>
ACI: CIBUILD <MDG-smet-aci-builds@list.st.com>
---
 drivers/gpu/drm/stm/ltdc.c | 49 ++++++++++++++++++++++++++++++++++----
 drivers/gpu/drm/stm/ltdc.h |  1 +
 2 files changed, 46 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/stm/ltdc.c b/drivers/gpu/drm/stm/ltdc.c
index 480f71936881..1e15c5343b0d 100644
--- a/drivers/gpu/drm/stm/ltdc.c
+++ b/drivers/gpu/drm/stm/ltdc.c
@@ -1419,8 +1419,7 @@ static void ltdc_plane_update_clut(struct drm_plane *plane,
 	}
 }
 
-static void ltdc_plane_atomic_update(struct drm_plane *plane,
-				     struct drm_atomic_state *state)
+static void ltdc_plane_update(struct drm_plane *plane, struct drm_atomic_state *state)
 {
 	struct ltdc_device *ldev = plane_to_ltdc(plane);
 	struct drm_device *ddev = plane->dev;
@@ -1716,7 +1715,6 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 
 	/* Enable layer and CLUT if needed */
 	lxcr = fb->format->format == DRM_FORMAT_C8 ? LXCR_CLUTEN : 0;
-	lxcr |= LXCR_LEN;
 
 	/* Enable horizontal mirroring if requested */
 	if (plane_rotation & DRM_MODE_REFLECT_X)
@@ -1750,7 +1748,10 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 		regmap_write(ldev->regmap, LTDC_L1SVSPR + lofs, val + (1 << SCALER_FRACTION));
 	}
 
-	regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_MASK, lxcr);
+	if (ldev->plane_enabled[plane->index])
+		regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_MASK, lxcr | LXCR_LEN);
+	else
+		regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_MASK, lxcr);
 
 	/* Commit shadow registers = update plane at next vblank */
 	if (ldev->caps.plane_reg_shadow)
@@ -1784,6 +1785,21 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	mutex_unlock(&ldev->err_lock);
 }
 
+static void ltdc_plane_atomic_update(struct drm_plane *plane,
+				     struct drm_atomic_state *state)
+{
+	struct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state, plane);
+	struct drm_device *ddev = plane->dev;
+
+	DRM_DEBUG_DRIVER("CRTC:%d plane:%d\n", newstate->crtc->base.id, plane->base.id);
+
+	if (!pm_runtime_active(ddev->dev))
+		return;
+
+	/* Update plane settings */
+	ltdc_plane_update(plane, state);
+}
+
 static void ltdc_plane_atomic_disable(struct drm_plane *plane,
 				      struct drm_atomic_state *state)
 {
@@ -1793,6 +1809,8 @@ static void ltdc_plane_atomic_disable(struct drm_plane *plane,
 	struct drm_device *ddev = plane->dev;
 	u32 lofs = plane->index * LAY_OFS;
 
+	ldev->plane_enabled[plane->index] = false;
+
 	if (!pm_runtime_active(ddev->dev))
 		return;
 
@@ -1811,6 +1829,28 @@ static void ltdc_plane_atomic_disable(struct drm_plane *plane,
 			 oldstate->crtc->base.id, plane->base.id);
 }
 
+static void ltdc_plane_atomic_enable(struct drm_plane *plane,
+				     struct drm_atomic_state *state)
+{
+	struct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state, plane);
+	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_device *ddev = plane->dev;
+
+	DRM_DEBUG_DRIVER("CRTC:%d plane:%d\n", newstate->crtc->base.id, plane->base.id);
+
+	ldev->plane_enabled[plane->index] = true;
+
+	if (!pm_runtime_active(ddev->dev)) {
+		if (pm_runtime_get_sync(ddev->dev)) {
+			DRM_ERROR("Failed to enable plane, cannot get sync\n");
+			return;
+		}
+	}
+
+	/* Update plane settings */
+	ltdc_plane_update(plane, state);
+}
+
 static void ltdc_plane_atomic_print_state(struct drm_printer *p,
 					  const struct drm_plane_state *state)
 {
@@ -1844,6 +1884,7 @@ static const struct drm_plane_helper_funcs ltdc_plane_helper_funcs = {
 	.atomic_check = ltdc_plane_atomic_check,
 	.atomic_update = ltdc_plane_atomic_update,
 	.atomic_disable = ltdc_plane_atomic_disable,
+	.atomic_enable = ltdc_plane_atomic_enable,
 };
 
 static struct drm_plane *ltdc_plane_create(struct drm_device *ddev,
diff --git a/drivers/gpu/drm/stm/ltdc.h b/drivers/gpu/drm/stm/ltdc.h
index 595cc1803ea2..8b7f56571f74 100644
--- a/drivers/gpu/drm/stm/ltdc.h
+++ b/drivers/gpu/drm/stm/ltdc.h
@@ -73,6 +73,7 @@ struct ltdc_device {
 	u32 max_burst_length;
 	struct reserved_mem *rot_mem;
 	struct stm32_firewall firewall[LTDC_MAX_FIREWALL];
+	bool plane_enabled[LTDC_MAX_LAYER];
 };
 
 int ltdc_parse_device_tree(struct device *dev);
-- 
2.39.5

