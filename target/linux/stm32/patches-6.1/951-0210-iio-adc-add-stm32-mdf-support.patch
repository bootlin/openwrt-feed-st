From d32d4f0e458b6afaf3aee6bbd21238ab338f6cf8 Mon Sep 17 00:00:00 2001
From: Olivier Moysan <olivier.moysan@foss.st.com>
Date: Mon, 16 Jan 2023 17:09:23 +0100
Subject: [PATCH 0210/1141] iio: adc: add stm32 mdf support

Add STM32 MDF support for PDM audio microphones.

Change-Id: Ib45d099a2476ca38a2d1ef629aa73a69363674da
Signed-off-by: Olivier Moysan <olivier.moysan@foss.st.com>
---
 drivers/iio/adc/Kconfig               |  25 +
 drivers/iio/adc/Makefile              |   2 +
 drivers/iio/adc/stm32-mdf-adc.c       | 883 ++++++++++++++++++++++++++
 drivers/iio/adc/stm32-mdf-core.c      | 778 +++++++++++++++++++++++
 drivers/iio/adc/stm32-mdf.h           | 283 +++++++++
 include/linux/iio/adc/stm32-mdf-adc.h |  18 +
 6 files changed, 1989 insertions(+)
 create mode 100644 drivers/iio/adc/stm32-mdf-adc.c
 create mode 100644 drivers/iio/adc/stm32-mdf-core.c
 create mode 100644 drivers/iio/adc/stm32-mdf.h
 create mode 100644 include/linux/iio/adc/stm32-mdf-adc.h

diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
index 791612ca6012..0feb3426f00e 100644
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -1046,6 +1046,31 @@ config STM32_DFSDM_ADC
 	  This driver can also be built as a module.  If so, the module
 	  will be called stm32-dfsdm-adc.
 
+config STM32_MDF_CORE
+	tristate "STMicroelectronics STM32 MDF core"
+	depends on (ARCH_STM32 && OF) || COMPILE_TEST
+	select REGMAP
+	select REGMAP_MMIO
+	help
+	  Select this option to enable the driver for STMicroelectronics
+	  STM32 Multi-function Digital Filter for sigma delta converter.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called stm32-mdf-core.
+
+config STM32_MDF_ADC
+	tristate "STMicroelectronics STM32 MDF adc"
+	depends on (ARCH_STM32 && OF) || COMPILE_TEST
+	select STM32_MDF_CORE
+	select IIO_BUFFER
+	select IIO_BUFFER_HW_CONSUMER
+	help
+	  Select this option to support ADCSigma delta modulator for
+	  STMicroelectronics STM32 Multi-function digital filter.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called stm32-mdf-adc.
+
 config STMPE_ADC
 	tristate "STMicroelectronics STMPE ADC driver"
 	depends on OF && MFD_STMPE
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
index 46caba7a010c..e60f5590b924 100644
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -95,6 +95,8 @@ obj-$(CONFIG_STM32_ADC_CORE) += stm32-adc-core.o
 obj-$(CONFIG_STM32_ADC) += stm32-adc.o
 obj-$(CONFIG_STM32_DFSDM_CORE) += stm32-dfsdm-core.o
 obj-$(CONFIG_STM32_DFSDM_ADC) += stm32-dfsdm-adc.o
+obj-$(CONFIG_STM32_MDF_CORE) += stm32-mdf-core.o
+obj-$(CONFIG_STM32_MDF_ADC) += stm32-mdf-adc.o
 obj-$(CONFIG_STMPE_ADC) += stmpe-adc.o
 obj-$(CONFIG_TI_ADC081C) += ti-adc081c.o
 obj-$(CONFIG_TI_ADC0832) += ti-adc0832.o
diff --git a/drivers/iio/adc/stm32-mdf-adc.c b/drivers/iio/adc/stm32-mdf-adc.c
new file mode 100644
index 000000000000..bae784624d65
--- /dev/null
+++ b/drivers/iio/adc/stm32-mdf-adc.c
@@ -0,0 +1,883 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * This file is part of STM32 MDF driver
+ *
+ * Copyright (C) 2023, STMicroelectronics.
+ * Author: Olivier Moysan <olivier.moysan@foss.st.com>.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/iio/adc/stm32-mdf-adc.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/hw-consumer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/timer/stm32-lptim-trigger.h>
+#include <linux/iio/timer/stm32-timer-trigger.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+#include "stm32-mdf.h"
+
+#define MDF_DMA_BUFFER_SIZE (4 * PAGE_SIZE)
+#define STM32_MDF_ITF_MAX 8
+#define STM32_MDF_DATA_RES 24
+
+struct stm32_mdf_dev_data {
+	int type;
+	int (*init)(struct device *dev, struct iio_dev *indio_dev);
+};
+
+struct stm32_mdf_adc {
+	struct stm32_mdf *mdf;
+	struct regmap *regmap;
+	struct dma_chan *dma_chan;
+	const struct stm32_mdf_dev_data *dev_data;
+	dma_addr_t dma_buf;
+	phys_addr_t phys_addr;
+	int (*cb)(const void *data, size_t size, void *cb_priv);
+	void *cb_priv;
+	unsigned long sck_freq;
+	unsigned long sample_freq;
+	unsigned int fl_id;
+	unsigned int sitf_id;
+	unsigned int decim_ratio;
+	unsigned int decim_cic;
+	unsigned int decim_rsflt;
+	unsigned int bufi;
+	unsigned int buf_sz;
+	u32 cicmode;
+	u32 datsrc;
+	u32 bsmx;
+	u8 *rx_buf;
+	bool rsflt_bypass;
+};
+
+enum sd_converter_type {
+	STM32_MDF_AUDIO,
+	STM32_MDF_IIO,
+};
+
+enum stm32_data_src_type {
+	STM32_MDF_DATSRC_BSMX,
+	STM32_MDF_DATSRC_UNSUPPORTED,
+	STM32_MDF_DATSRC_ADCITF1,
+	STM32_MDF_DATSRC_ADCITF2,
+	STM32_MDF_DATSRC_NB,
+};
+
+static bool stm32_mdf_readable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_BSMXCR_REG:
+	case MDF_DFLTCR_REG:
+	case MDF_DFLTCICR_REG:
+	case MDF_DFLTRSFR_REG:
+	case MDF_DFLTINTR_REG:
+	case MDF_OLDCR_REG:
+	case MDF_OLDTHLR_REG:
+	case MDF_OLDTHHR_REG:
+	case MDF_DLYCR_REG:
+	case MDF_SCDCR_REG:
+	case MDF_DFLTIER_REG:
+	case MDF_DFLTISR_REG:
+	case MDF_OECCR_REG:
+	case MDF_SNPSxDR:
+	case MDF_DLTDR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_mdf_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_DFLTISR_REG:
+	case MDF_SNPSxDR:
+	case MDF_DLTDR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_mdf_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_BSMXCR_REG:
+	case MDF_DFLTCR_REG:
+	case MDF_DFLTCICR_REG:
+	case MDF_DFLTRSFR_REG:
+	case MDF_DFLTINTR_REG:
+	case MDF_OLDCR_REG:
+	case MDF_OLDTHLR_REG:
+	case MDF_OLDTHHR_REG:
+	case MDF_DLYCR_REG:
+	case MDF_SCDCR_REG:
+	case MDF_DFLTIER_REG:
+	case MDF_DFLTISR_REG:
+	case MDF_OECCR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config stm32_mdf_regmap_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = sizeof(u32),
+	.max_register = MDF_SIDR_REG,
+	.readable_reg = stm32_mdf_readable_reg,
+	.volatile_reg = stm32_mdf_volatile_reg,
+	.writeable_reg = stm32_mdf_writeable_reg,
+	.fast_io = true,
+};
+
+static int stm32_mdf_filter_configure(struct stm32_mdf_adc *adc)
+{
+	return 0;
+}
+
+static int stm32_mdf_start_filter(struct stm32_mdf_adc *adc)
+{
+	return regmap_set_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+}
+
+static void stm32_mdf_stop_filter(struct stm32_mdf_adc *adc)
+{
+	regmap_clear_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+}
+
+static int stm32_mdf_start_conv(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct stm32_mdf *mdf = adc->mdf;
+	struct stm32_mdf_sitf *sitf = &mdf->sitf[adc->sitf_id];
+	int ret;
+
+	ret = stm32_mdf_start_sitf(sitf);
+	if (ret < 0)
+		return ret;
+
+	ret = stm32_mdf_filter_configure(adc);
+	if (ret < 0)
+		goto stop_sitf;
+
+	ret = stm32_mdf_start_filter(adc);
+	if (ret < 0)
+		goto stop_sitf;
+
+	return 0;
+
+stop_sitf:
+	stm32_mdf_stop_sitf(sitf);
+
+	return ret;
+}
+
+static void stm32_mdf_stop_conv(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct stm32_mdf *mdf = adc->mdf;
+	struct stm32_mdf_sitf *sitf = &mdf->sitf[adc->sitf_id];
+
+	stm32_mdf_stop_filter(adc);
+
+	stm32_mdf_stop_sitf(sitf);
+}
+
+static unsigned int stm32_mdf_adc_dma_residue(struct stm32_mdf_adc *adc)
+{
+	struct dma_tx_state state;
+	enum dma_status status;
+
+	status = dmaengine_tx_status(adc->dma_chan, adc->dma_chan->cookie, &state);
+	if (status == DMA_IN_PROGRESS) {
+		/* Residue is size in bytes from end of buffer */
+		unsigned int i = adc->buf_sz - state.residue;
+		unsigned int size;
+
+		/* Return available bytes */
+		if (i >= adc->bufi)
+			size = i - adc->bufi;
+		else
+			size = adc->buf_sz + i - adc->bufi;
+
+		return size;
+	}
+
+	return 0;
+}
+
+static void stm32_mdf_dma_buffer_done(void *data)
+{
+	struct iio_dev *indio_dev = data;
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int available = stm32_mdf_adc_dma_residue(adc);
+	size_t old_pos;
+
+	dev_dbg(&indio_dev->dev, "pos = %d, available = %d\n", adc->bufi, available);
+	old_pos = adc->bufi;
+
+	while (available >= indio_dev->scan_bytes) {
+		available -= indio_dev->scan_bytes;
+		adc->bufi += indio_dev->scan_bytes;
+		if (adc->bufi >= adc->buf_sz) {
+			if (adc->cb)
+				adc->cb(&adc->rx_buf[old_pos], adc->buf_sz - old_pos, adc->cb_priv);
+			adc->bufi = 0;
+			old_pos = 0;
+		}
+	}
+	if (adc->cb)
+		adc->cb(&adc->rx_buf[old_pos], adc->bufi - old_pos, adc->cb_priv);
+}
+
+static int stm32_mdf_adc_dma_start(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct dma_slave_config config = {
+		.src_addr = (dma_addr_t)adc->phys_addr + MDF_DLTDR_REG,
+		.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,
+	};
+	struct dma_async_tx_descriptor *desc;
+	int ret;
+
+	if (!adc->dma_chan)
+		return -EINVAL;
+
+	dev_dbg(&indio_dev->dev, "size=%d watermark=%d\n", adc->buf_sz, adc->buf_sz / 2);
+
+	ret = dmaengine_slave_config(adc->dma_chan, &config);
+	if (ret)
+		return ret;
+
+	/* Prepare a DMA cyclic transaction */
+	desc = dmaengine_prep_dma_cyclic(adc->dma_chan, adc->dma_buf,
+					 adc->buf_sz, adc->buf_sz / 2,
+					 DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);
+	if (!desc)
+		return -EBUSY;
+
+	desc->callback = stm32_mdf_dma_buffer_done;
+	desc->callback_param = indio_dev;
+
+	ret = dma_submit_error(dmaengine_submit(desc));
+	if (ret)
+		goto err_stop_dma;
+
+	/* Issue pending DMA requests */
+	dma_async_issue_pending(adc->dma_chan);
+
+	/* Enable regular DMA transfer*/
+	ret = regmap_set_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DMAEN);
+	if (ret < 0)
+		goto err_stop_dma;
+
+	return 0;
+
+err_stop_dma:
+	dmaengine_terminate_all(adc->dma_chan);
+
+	return ret;
+}
+
+static void stm32_mdf_adc_dma_stop(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	if (!adc->dma_chan)
+		return;
+
+	regmap_clear_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DMAEN);
+
+	dmaengine_terminate_all(adc->dma_chan);
+}
+
+static int stm32_mdf_postenable(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct stm32_mdf *mdf = adc->mdf;
+	int ret;
+
+	/* Reset adc buffer index */
+	adc->bufi = 0;
+
+	ret = stm32_mdf_start_mdf(adc->mdf);
+	if (ret < 0)
+		return ret;
+
+	/* Enable CCKx clock if configured as output */
+	ret = clk_prepare_enable(mdf->sitf[adc->sitf_id].sck);
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "Failed to enable clock %s\n",
+			__clk_get_name(mdf->sitf[adc->sitf_id].sck));
+		goto err_stop_mdf;
+	}
+
+	regmap_set_bits(adc->regmap, MDF_DFLTISR_REG,
+			MDF_DFLTISR_DOVRF_MASK | MDF_DFLTISR_SATF_MASK);
+
+	regmap_set_bits(adc->regmap, MDF_DFLTIER_REG,
+			MDF_DFLTIER_DOVRIE_MASK | MDF_DFLTIER_SATIE_MASK);
+
+	ret = stm32_mdf_adc_dma_start(indio_dev);
+	if (ret) {
+		dev_err(&indio_dev->dev, "Can't start DMA\n");
+		goto err_stop_clk;
+	}
+
+	ret = stm32_mdf_start_conv(indio_dev);
+	if (ret) {
+		dev_err(&indio_dev->dev, "Can't start conversion\n");
+		goto err_stop_dma;
+	}
+
+	return 0;
+
+err_stop_dma:
+	stm32_mdf_adc_dma_stop(indio_dev);
+err_stop_clk:
+	clk_disable_unprepare(mdf->sitf[adc->sitf_id].sck);
+err_stop_mdf:
+	stm32_mdf_stop_mdf(adc->mdf);
+
+	return ret;
+}
+
+static int stm32_mdf_predisable(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct stm32_mdf *mdf = adc->mdf;
+
+	stm32_mdf_stop_conv(indio_dev);
+
+	stm32_mdf_adc_dma_stop(indio_dev);
+
+	regmap_clear_bits(adc->regmap, MDF_DFLTIER_REG,
+			  MDF_DFLTIER_DOVRIE_MASK | MDF_DFLTIER_SATIE_MASK);
+
+	/* Disable CCKx clock if configured as output */
+	clk_disable_unprepare(mdf->sitf[adc->sitf_id].sck);
+
+	stm32_mdf_stop_mdf(adc->mdf);
+
+	return 0;
+}
+
+static const struct iio_buffer_setup_ops stm32_mdf_buffer_setup_ops = {
+	.postenable = &stm32_mdf_postenable,
+	.predisable = &stm32_mdf_predisable,
+};
+
+static void stm32_mdf_dma_release(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	if (adc && adc->dma_chan) {
+		dma_free_coherent(adc->dma_chan->device->dev,
+				  MDF_DMA_BUFFER_SIZE, adc->rx_buf, adc->dma_buf);
+		dma_release_channel(adc->dma_chan);
+	}
+}
+
+static int stm32_mdf_dma_request(struct device *dev, struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	adc->dma_chan = dma_request_chan(dev, "rx");
+	if (IS_ERR(adc->dma_chan)) {
+		adc->dma_chan = NULL;
+		return PTR_ERR(adc->dma_chan);
+	}
+
+	adc->rx_buf = dma_alloc_coherent(adc->dma_chan->device->dev,
+					 MDF_DMA_BUFFER_SIZE, &adc->dma_buf, GFP_KERNEL);
+	if (!adc->rx_buf) {
+		dma_release_channel(adc->dma_chan);
+		return -ENOMEM;
+	}
+
+	indio_dev->modes |= INDIO_BUFFER_SOFTWARE;
+	indio_dev->setup_ops = &stm32_mdf_buffer_setup_ops;
+
+	return 0;
+}
+
+static int stm32_mdf_adc_chan_init_one(struct iio_dev *indio_dev,
+				       struct iio_chan_spec *ch)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	ch->type = IIO_VOLTAGE;
+	ch->indexed = 1;
+	ch->channel = adc->fl_id;
+
+	ch->scan_type.sign = 's';
+	ch->scan_type.realbits = STM32_MDF_DATA_RES;
+	ch->scan_type.storagebits = 32;
+
+	return 0;
+}
+
+static int stm32_mdf_audio_init(struct device *dev, struct iio_dev *indio_dev)
+{
+	struct iio_chan_spec *ch;
+	int ret;
+
+	ch = devm_kzalloc(&indio_dev->dev, sizeof(*ch), GFP_KERNEL);
+	if (!ch)
+		return -ENOMEM;
+
+	ret = stm32_mdf_adc_chan_init_one(indio_dev, ch);
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "Channels init failed\n");
+		return ret;
+	}
+	ch->info_mask_separate = BIT(IIO_CHAN_INFO_SAMP_FREQ);
+
+	/* TODO: manage interleave */
+	indio_dev->num_channels = 1;
+	indio_dev->channels = ch;
+
+	ret = stm32_mdf_dma_request(dev, indio_dev);
+	if (ret) {
+		dev_err(&indio_dev->dev, "Failed to get dma: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_mdf_compute_flt_decim(struct iio_dev *indio_dev, unsigned int decim)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	unsigned int decim_cic, decim_rsflt = 1;
+	u32 val;
+	int ret;
+
+	decim_rsflt = 1;
+	if (!adc->rsflt_bypass) {
+		regmap_read(adc->regmap, MDF_DFLTRSFR_REG, &val);
+		if (!(val & MDF_DFLTRSFR_RSFLTD))
+			decim_rsflt = 4;
+	}
+
+	decim_cic = DIV_ROUND_CLOSEST(decim, decim_rsflt);
+	if (decim % decim_rsflt) {
+		dev_err(&indio_dev->dev, "Wrong decimation factor for CIC filter\n");
+		return -EINVAL;
+	}
+
+	if (decim_cic < MDF_DFLTCICR_MCICD_MIN ||
+	    decim_cic > MDF_DFLTCICR_MCICD_MAX) {
+		dev_err(&indio_dev->dev,
+			"Decimation factor [%d] out of range for CIC filter\n", decim_cic);
+		return -EINVAL;
+	}
+
+	ret = regmap_update_bits(adc->regmap, MDF_DFLTCICR_REG,
+				 MDF_DFLTCICR_MCICD_MASK,
+				 MDF_DFLTCICR_MCICD(decim_cic));
+	if (ret)
+		return ret;
+
+	/*
+	 * TODO: manage scaling depending on decim & filter conf
+	 * Also expose control to adjust scaling ?
+	 * Fixed scaling for time being set according to settings #8 in reference manual
+	 */
+	ret = regmap_update_bits(adc->regmap, MDF_DFLTCICR_REG,
+				 MDF_DFLTCICR_SCALE_MASK,
+				 MDF_DFLTCICR_SCALE(0x27));
+
+	adc->decim_cic = decim_cic;
+
+	return 0;
+}
+
+static int mdf_adc_set_samp_freq(struct iio_dev *indio_dev,
+				 unsigned long sample_freq)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct stm32_mdf *mdf = adc->mdf;
+	unsigned int decim_ratio;
+	unsigned long sck_freq;
+	int ret;
+
+	sck_freq = clk_get_rate(mdf->sitf[adc->sitf_id].sck);
+	if (!sck_freq) {
+		dev_err(&indio_dev->dev, "Unexpected serial clock frequency: 0Hz\n");
+		return -EINVAL;
+	}
+
+	decim_ratio = DIV_ROUND_CLOSEST(sck_freq, sample_freq);
+	if (sck_freq % sample_freq)
+		dev_dbg(&indio_dev->dev,
+			"Rate not accurate. requested (%lu), actual (%lu)\n",
+			sample_freq, sck_freq / decim_ratio);
+
+	ret = stm32_mdf_compute_flt_decim(indio_dev, decim_ratio);
+	if (ret < 0)
+		return ret;
+
+	adc->sample_freq = sck_freq / decim_ratio;
+	adc->decim_ratio = decim_ratio;
+
+	return 0;
+}
+
+static int stm32_mdf_set_watermark(struct iio_dev *indio_dev, unsigned int val)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	unsigned int watermark = MDF_DMA_BUFFER_SIZE / 2;
+	unsigned int rx_buf_sz = MDF_DMA_BUFFER_SIZE;
+
+	/*
+	 * DMA cyclic transfers are used, buffer is split into two periods.
+	 * There should be :
+	 * - always one buffer (period) DMA is working on
+	 * - one buffer (period) driver pushed to ASoC side.
+	 */
+	watermark = min(watermark, val * (unsigned int)(sizeof(u32)));
+	adc->buf_sz = min(rx_buf_sz, watermark * 2);
+
+	return 0;
+}
+
+static int stm32_mdf_write_raw(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan, int val,
+			       int val2, long mask)
+{
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		if (!val)
+			return -EINVAL;
+
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+
+		ret = mdf_adc_set_samp_freq(indio_dev, val);
+		iio_device_release_direct_mode(indio_dev);
+
+		return ret;
+	}
+
+	return -EINVAL;
+}
+
+static int stm32_mdf_read_raw(struct iio_dev *indio_dev,
+			      struct iio_chan_spec const *chan, int *val,
+			      int *val2, long mask)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = adc->sample_freq;
+
+		return IIO_VAL_INT;
+	}
+
+	return -EINVAL;
+}
+
+static const struct iio_info stm32_mdf_info_audio = {
+	.hwfifo_set_watermark = stm32_mdf_set_watermark,
+	.write_raw = stm32_mdf_write_raw,
+	.read_raw = stm32_mdf_read_raw,
+};
+
+static irqreturn_t stm32_mdf_irq(int irq, void *arg)
+{
+	struct iio_dev *indio_dev = arg;
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct regmap *regmap = adc->regmap;
+	u32 isr, ier, flags;
+
+	regmap_read(regmap, MDF_DFLTISR_REG, &isr);
+	regmap_read(regmap, MDF_DFLTIER_REG, &ier);
+
+	flags = isr & ier;
+	if (!flags)
+		return IRQ_NONE;
+
+	if (flags & MDF_DFLTISR_DOVRF_MASK) {
+		dev_warn(&indio_dev->dev, "Data overflow detected\n");
+		regmap_set_bits(regmap, MDF_DFLTISR_REG, MDF_DFLTISR_DOVRF_MASK);
+	}
+
+	if (flags & MDF_DFLTISR_RFOVRF_MASK) {
+		dev_warn(&indio_dev->dev, "Reshape filter overrun detected\n");
+		regmap_set_bits(regmap, MDF_DFLTISR_REG, MDF_DFLTISR_RFOVRF_MASK);
+	}
+
+	if (flags & MDF_DFLTISR_SATF_MASK) {
+		dev_warn(&indio_dev->dev, "Saturation detected\n");
+		regmap_set_bits(regmap, MDF_DFLTISR_REG, MDF_DFLTISR_SATF_MASK);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static const struct stm32_mdf_dev_data stm32_mdf_audio_data = {
+	.type = STM32_MDF_AUDIO,
+	.init = stm32_mdf_audio_init,
+};
+
+/**
+ * stm32_mdf_get_buff_cb() - register a callback that will be called when
+ *                           DMA transfer period is achieved.
+ *
+ * @iio_dev: Handle to IIO device.
+ * @cb: Pointer to callback function:
+ *      - data: pointer to data buffer
+ *      - size: size in byte of the data buffer
+ *      - private: pointer to consumer private structure.
+ * @private: Pointer to consumer private structure.
+ */
+int stm32_mdf_get_buff_cb(struct iio_dev *iio_dev,
+			  int (*cb)(const void *data, size_t size, void *private), void *private)
+{
+	struct stm32_mdf_adc *adc;
+
+	if (!iio_dev)
+		return -EINVAL;
+	adc = iio_priv(iio_dev);
+
+	if (!adc)
+		return -EINVAL;
+
+	adc->cb = cb;
+	adc->cb_priv = private;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_get_buff_cb);
+
+/**
+ * stm32_mdf_release_buff_cb - unregister buffer callback
+ *
+ * @iio_dev: Handle to IIO device.
+ */
+int stm32_mdf_release_buff_cb(struct iio_dev *iio_dev)
+{
+	struct stm32_mdf_adc *adc;
+
+	if (!iio_dev)
+		return -EINVAL;
+	adc = iio_priv(iio_dev);
+
+	if (!adc)
+		return -EINVAL;
+
+	adc->cb = NULL;
+	adc->cb_priv = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_release_buff_cb);
+
+static const struct of_device_id stm32_mdf_adc_match[] = {
+	{
+		.compatible = "st,stm32mp25-mdf-dmic",
+		.data = &stm32_mdf_audio_data,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, stm32_mdf_adc_match);
+
+static int stm32_mdf_adc_parse_of(struct platform_device *pdev, struct stm32_mdf_adc *adc)
+{
+	struct device *dev = &pdev->dev;
+	int ret, nb_streams, nb_itf;
+	u32 sitfs[STM32_MDF_ITF_MAX], streams[STM32_MDF_ITF_MAX];
+	u32 val, idx, dfltcicr_msk, dfltcicr;
+
+	ret = device_property_read_u32(dev, "reg", &idx);
+	if (ret) {
+		dev_err(dev, "Could not get filter index: %d\n", ret);
+		return ret;
+	}
+	adc->fl_id = (idx >> 7) - 1;
+
+	ret = device_property_read_u32(dev, "st,cic-mode", &val);
+	if (ret) {
+		dev_err(dev, "Could not get cic filter mode: %d\n", ret);
+		return ret;
+	}
+	adc->cicmode = val;
+	dfltcicr_msk = MDF_SITFCR_SITFMOD_MASK;
+	dfltcicr = MDF_SITFCR_SITFMOD(val);
+
+	nb_streams = device_property_count_u32(dev, "st,sitf-streams");
+	if (!nb_streams || nb_streams > adc->mdf->nbf) {
+		dev_err(dev, "Bad number of streams: %d\n", nb_streams);
+		return -EINVAL;
+	}
+
+	ret = device_property_read_u32_array(dev, "st,sitf-streams", streams, nb_streams);
+	if (ret < 0) {
+		dev_err(dev, "Could not get streams indexes: %d\n", ret);
+		return ret;
+	}
+
+	nb_itf = device_property_count_u32(dev, "st,sitf-indexes");
+	if (!nb_itf || nb_itf > adc->mdf->nbf) {
+		dev_err(dev, "Bad number of serial interfaces: %d\n", nb_itf);
+		return -EINVAL;
+	}
+
+	if (nb_itf != nb_streams) {
+		dev_err(dev, "Stream number [%d] do not match interface number [%d]\n",
+			nb_streams, nb_itf);
+		return -EINVAL;
+	}
+
+	ret = device_property_read_u32_array(dev, "st,sitf-indexes", sitfs, nb_itf);
+	if (ret < 0) {
+		dev_err(dev, "Could not get serial interface indexes: %d\n", ret);
+		return ret;
+	};
+
+	/* Only support BSMX filter source right now */
+	adc->datsrc = STM32_MDF_DATSRC_BSMX;
+	dfltcicr_msk |= MDF_SITFCR_SCKSRC_MASK;
+	dfltcicr |= MDF_SITFCR_SCKSRC(adc->datsrc);
+
+	/* TODO: read sitfs array from DT to support interleave mode */
+	if (!adc->mdf->sitf[sitfs[0]].registered) {
+		dev_err(dev, "Interface [%d] not registered\n", sitfs[0]);
+		return -EINVAL;
+	}
+	adc->bsmx = sitfs[0] * 2 + streams[0];
+	adc->sitf_id = sitfs[0];
+
+	/* Configure DFLTCICR */
+	regmap_update_bits(adc->regmap, MDF_DFLTCICR_REG, dfltcicr_msk, dfltcicr);
+
+	/* Configure BSMXCR */
+	regmap_update_bits(adc->regmap, MDF_BSMXCR_REG,
+			   MDF_BSMXCR_BSSEL_MASK, MDF_BSMXCR_BSSEL(adc->bsmx));
+
+	return 0;
+}
+
+static int stm32_mdf_adc_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct stm32_mdf_adc *adc;
+	const struct stm32_mdf_dev_data *dev_data;
+	struct iio_dev *iio;
+	struct resource *res;
+	void __iomem *base;
+	int ret, irq;
+
+	dev_data = of_device_get_match_data(dev);
+	iio = devm_iio_device_alloc(dev, sizeof(*adc));
+	if (!iio) {
+		dev_err(dev, "Failed to allocate IIO device\n");
+		return -ENOMEM;
+	}
+
+	adc = iio_priv(iio);
+	adc->mdf = dev_get_drvdata(dev->parent);
+
+	platform_set_drvdata(pdev, adc);
+
+	base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(base))
+		return dev_err_probe(dev, PTR_ERR(base), "Failed to get resource\n");
+	adc->phys_addr = res->start;
+
+	adc->regmap = devm_regmap_init_mmio_clk(dev, "ker_ck", base, &stm32_mdf_regmap_cfg);
+	if (IS_ERR(adc->regmap))
+		return dev_err_probe(dev, PTR_ERR(adc->regmap), "Failed to get kernel clock\n");
+
+	ret = stm32_mdf_adc_parse_of(pdev, adc);
+	if (ret < 0)
+		return ret;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return dev_err_probe(dev, irq, "Failed to get kernel clock\n");
+
+	ret = devm_request_irq(dev, irq, stm32_mdf_irq, 0, pdev->name, iio);
+	if (ret < 0) {
+		dev_err(dev, "Failed to request IRQ\n");
+		return ret;
+	}
+
+	if (dev_data->type == STM32_MDF_AUDIO)
+		iio->info = &stm32_mdf_info_audio;
+	iio->name = dev_name(&pdev->dev);
+
+	adc->dev_data = dev_data;
+	ret = dev_data->init(dev, iio);
+	if (ret < 0)
+		return ret;
+
+	ret = iio_device_register(iio);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register IIO device: %d\n", ret);
+		goto err_cleanup;
+	}
+
+	if (dev_data->type == STM32_MDF_AUDIO) {
+		ret = of_platform_populate(node, NULL, NULL, dev);
+		if (ret < 0) {
+			return dev_err_probe(dev, ret, "Failed to find an audio DAI\n");
+			goto err_unregister;
+		}
+	}
+
+	return 0;
+
+err_unregister:
+	iio_device_unregister(iio);
+err_cleanup:
+	stm32_mdf_dma_release(iio);
+
+	return ret;
+}
+
+static int stm32_mdf_adc_remove(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	if (adc->dev_data->type == STM32_MDF_AUDIO)
+		of_platform_depopulate(&pdev->dev);
+	iio_device_unregister(indio_dev);
+	stm32_mdf_dma_release(indio_dev);
+
+	return 0;
+}
+
+static struct platform_driver stm32_mdf_adc_driver = {
+	.driver = {
+		.name = "stm32-mdf-adc",
+		.of_match_table = stm32_mdf_adc_match,
+	},
+	.probe = stm32_mdf_adc_probe,
+	.remove = stm32_mdf_adc_remove,
+};
+module_platform_driver(stm32_mdf_adc_driver);
+
+MODULE_DESCRIPTION("STM32 MDF sigma delta ADC");
+MODULE_AUTHOR("Olivier Moysan <olivier.moysan@foss.st.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/stm32-mdf-core.c b/drivers/iio/adc/stm32-mdf-core.c
new file mode 100644
index 000000000000..79ff45b14cc9
--- /dev/null
+++ b/drivers/iio/adc/stm32-mdf-core.c
@@ -0,0 +1,778 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * This file is part of STM32 MDF driver
+ *
+ * Copyright (C) 2023, STMicroelectronics.
+ * Author: Olivier Moysan <olivier.moysan@foss.st.com>.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/device.h>
+#include <linux/gcd.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+
+#include "stm32-mdf.h"
+
+#define STM32_MDF_MODE_SZ 12
+
+static bool stm32_mdf_readable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_GCR_REG:
+	case MDF_CKGCR_REG:
+	case MDF_HWCFGR_REG:
+	case MDF_VERR_REG:
+	case MDF_IPIDR_REG:
+	case MDF_SIDR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_mdf_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_CKGCR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_mdf_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_GCR_REG:
+	case MDF_CKGCR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config stm32_mdf_regmap_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = sizeof(u32),
+	.max_register = MDF_SIDR_REG,
+	.readable_reg = stm32_mdf_readable_reg,
+	.volatile_reg = stm32_mdf_volatile_reg,
+	.writeable_reg = stm32_mdf_writeable_reg,
+	.fast_io = true,
+};
+
+/*
+ * struct stm32_mdf_sck_prov - STM32 MDF serial interface clock provider data
+ * @hw: pointer to hw clock data
+ * @data: pointer to mdf private data
+ * @div: serial clock divider data
+ * @gate: serial clock gating data
+ * @id: serial clock provider id (0 for cck0 & 1 for cck1)
+ * @lock: lock to manage common divider
+ */
+struct stm32_mdf_sck_prov {
+	struct clk_hw *hw;
+	struct stm32_mdf_priv *data;
+	struct clk_divider div;
+	struct clk_gate gate;
+	unsigned int id;
+	spinlock_t lock; /* Manage common divider concurrent accesses */
+};
+
+/*
+ * struct stm32_mdf_priv - STM32 MDF private data
+ * @mdf: mdf common data
+ * @pdev: platform device pointer
+ * @regmap: regmap for register read/write
+ * @prov: serial interface clock providers array
+ * @kclk: mdf kernel clock handle
+ * @base: mdf registers base cpu address
+ * @phys_base: mdf registers base physical address
+ * @n_active_ch: number of active channels
+ * @cck_freq: output cck clocks frequencies array
+ * @procdiv: processing divider (common divider)
+ * @cckdiv: cck divider (cck0 & cck1 common divider)
+ */
+struct stm32_mdf_priv {
+	struct stm32_mdf mdf;
+	struct platform_device *pdev;
+	struct regmap *regmap;
+	struct stm32_mdf_sck_prov prov[2];
+	struct clk *kclk;
+	void __iomem *base;
+	phys_addr_t phys_base;
+	atomic_t n_active_ch;
+	unsigned long cck_freq[2];
+	u32 procdiv;
+	u32 cckdiv;
+};
+
+#define gate_to_sck_prov(p) container_of(p, struct stm32_mdf_sck_prov, gate)
+#define div_to_sck_prov(p) container_of(p, struct stm32_mdf_sck_prov, div)
+
+enum {
+	STM32_MDF_MODE_SPI,
+	STM32_MDF_MODE_SPI_LF,
+	STM32_MDF_MODE_MANCHESTER_R,
+	STM32_MDF_MODE_MANCHESTER_F,
+	STM32_MDF_MODE_NB,
+};
+
+enum {
+	STM32_MDF_SCKSRC_CCK0,
+	STM32_MDF_SCKSRC_CCK1,
+	STM32_MDF_SCKSRC_CLK,
+	STM32_MDF_SCKSRC_NONE,
+};
+
+#define STM32_MDF_MAX_CCK STM32_MDF_SCKSRC_CLK
+
+struct stm32_mdf_sf_mode {
+	const char *name;
+	u32 idx;
+};
+
+static const struct stm32_mdf_sf_mode stm32_mdf_mode[STM32_MDF_MODE_NB] = {
+	{ "spi", STM32_MDF_MODE_SPI },
+	{ "spi_lf", STM32_MDF_MODE_SPI_LF },
+	{ "manchester_r", STM32_MDF_MODE_MANCHESTER_R },
+	{ "manchester_f", STM32_MDF_MODE_MANCHESTER_F },
+};
+
+static inline struct stm32_mdf_priv *to_stm32_mdf_priv(struct stm32_mdf *mdf)
+{
+	return container_of(mdf, struct stm32_mdf_priv, mdf);
+}
+
+static int stm32_mdf_sitf_readl(struct stm32_mdf_sitf *sitf, u32 reg)
+{
+	int ret;
+
+	ret = clk_enable(sitf->kclk);
+	if (ret < 0)
+		return ret;
+
+	readl_relaxed(sitf->base + reg);
+
+	clk_disable(sitf->kclk);
+
+	return 0;
+}
+
+static int stm32_mdf_sitf_writel(struct stm32_mdf_sitf *sitf, u32 reg, u32 val)
+{
+	int ret;
+
+	ret = clk_enable(sitf->kclk);
+	if (ret < 0)
+		return ret;
+
+	writel_relaxed(val, sitf->base + reg);
+
+	clk_disable(sitf->kclk);
+
+	return 0;
+}
+
+static int stm32_mdf_sitf_clr_bits(struct stm32_mdf_sitf *sitf, u32 reg, u32 bits)
+{
+	return stm32_mdf_sitf_writel(sitf, reg, stm32_mdf_sitf_readl(sitf, reg) & ~bits);
+}
+
+static int stm32_mdf_sitf_set_bits(struct stm32_mdf_sitf *sitf, u32 reg, u32 bits)
+{
+	return stm32_mdf_sitf_writel(sitf, reg, stm32_mdf_sitf_readl(sitf, reg) | bits);
+}
+
+int stm32_mdf_start_mdf(struct stm32_mdf *mdf)
+{
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+	struct device *dev = &priv->pdev->dev;
+	int ret;
+	u32 val;
+
+	if (atomic_inc_return(&priv->n_active_ch) == 1) {
+		/* Enable PROCDIV and CCKDIV clock dividers */
+		ret = regmap_set_bits(priv->regmap, MDF_CKGCR_REG, MDF_CKG_CKGDEN);
+		if (ret < 0)
+			goto err;
+
+		/* Check clock status */
+		regmap_read(priv->regmap, MDF_CKGCR_REG, &val);
+		if (!(val & MDF_CKG_ACTIVE)) {
+			ret = -EINVAL;
+			dev_err(dev, "MDF clock not active\n");
+			goto err;
+		}
+
+		/* TODO: Manage syncronous mode with TRGO trigger. UC with several filters */
+	}
+
+	return 0;
+
+err:
+	atomic_dec(&priv->n_active_ch);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_start_mdf);
+
+int stm32_mdf_stop_mdf(struct stm32_mdf *mdf)
+{
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+	int ret;
+
+	if (atomic_dec_and_test(&priv->n_active_ch)) {
+		ret = regmap_clear_bits(priv->regmap, MDF_CKGCR_REG, MDF_CKG_CKGDEN);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_stop_mdf);
+
+int stm32_mdf_start_sitf(struct stm32_mdf_sitf *sitf)
+{
+	int ret;
+
+	spin_lock(&sitf->lock);
+
+	ret = stm32_mdf_sitf_set_bits(sitf, MDF_SITFCR_REG, MDF_SITFCR_SITFEN);
+	if (ret)
+		goto err;
+
+	sitf->refcnt++;
+
+err:
+	spin_unlock(&sitf->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_start_sitf);
+
+int stm32_mdf_stop_sitf(struct stm32_mdf_sitf *sitf)
+{
+	int ret = 0;
+
+	spin_lock(&sitf->lock);
+
+	sitf->refcnt--;
+
+	if (!sitf->refcnt)
+		ret = stm32_mdf_sitf_clr_bits(sitf, MDF_SITFCR_REG, MDF_SITFCR_SITFEN);
+
+	spin_unlock(&sitf->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_stop_sitf);
+
+static int stm32_mdf_clk_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct clk_gate *gate = to_clk_gate(hw);
+	struct stm32_mdf_sck_prov *prov = gate_to_sck_prov(gate);
+	struct stm32_mdf_priv *priv = prov->data;
+	u32 bit = enable ? gate->bit_idx : 0;
+
+	return regmap_update_bits(priv->regmap, gate->reg - priv->base, gate->bit_idx, bit);
+}
+
+static int stm32_mdf_cck_gate_enable(struct clk_hw *hw)
+{
+	stm32_mdf_clk_gate_endisable(hw, 1);
+
+	return 0;
+};
+
+static void stm32_mdf_cck_gate_disable(struct clk_hw *hw)
+{
+	stm32_mdf_clk_gate_endisable(hw, 0);
+};
+
+static int stm32_mdf_cck_gate_is_enabled(struct clk_hw *hw)
+{
+	struct clk_gate *gate = to_clk_gate(hw);
+	struct stm32_mdf_sck_prov *prov = gate_to_sck_prov(gate);
+	struct stm32_mdf_priv *priv = prov->data;
+	u32 val;
+
+	regmap_read(priv->regmap, gate->reg - priv->base, &val);
+
+	return (val & gate->bit_idx) ? 1 : 0;
+};
+
+static unsigned long stm32_mdf_cck_divider_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct clk_divider *div = to_clk_divider(hw);
+	struct stm32_mdf_sck_prov *prov = div_to_sck_prov(div);
+	struct stm32_mdf_priv *priv = prov->data;
+	unsigned int ratio;
+	u32 cckdiv, procdiv;
+
+	regmap_read(priv->regmap, MDF_CKGCR_REG, &cckdiv);
+	regmap_read(priv->regmap, MDF_CKGCR_REG, &procdiv);
+	ratio = (FIELD_GET(MDF_CKG_PROCDIV_MASK, procdiv) + 1) *
+		(FIELD_GET(MDF_CKG_CCKDIV_MASK, cckdiv) + 1);
+
+	return DIV_ROUND_CLOSEST_ULL((u64)parent_rate, ratio);
+};
+
+static int stm32_mdf_cck_divider_set_rate(struct clk_hw *hw, unsigned long rate,
+					  unsigned long parent_rate)
+{
+	struct clk_divider *div = to_clk_divider(hw);
+	struct stm32_mdf_sck_prov *prov = div_to_sck_prov(div);
+	struct stm32_mdf_priv *priv = prov->data;
+
+	/* Configure CKGCR register */
+	return regmap_update_bits(priv->regmap, MDF_CKGCR_REG,
+				  MDF_CKG_CCKDIV_MASK | MDF_CKG_PROCDIV_MASK,
+				  MDF_CKG_CCKDIV(priv->cckdiv - 1) |
+				  MDF_CKG_PROCDIV(priv->procdiv - 1));
+};
+
+static long stm32_mdf_cck_divider_round_rate(struct clk_hw *hw, unsigned long rate,
+					     unsigned long *parent_rate)
+{
+	struct clk_divider *div = to_clk_divider(hw);
+	struct stm32_mdf_sck_prov *prov = div_to_sck_prov(div);
+	struct stm32_mdf_priv *priv = prov->data;
+	struct device *dev = &priv->pdev->dev;
+	unsigned long ratio, delta;
+	u32 cckdiv, procdiv;
+
+	/* Compute procdiv / cckdiv if not already set */
+	/* TODO: manage race conditions and concurrency on procdiv configuration for cck0/1 */
+	if (!priv->procdiv || !priv->cckdiv) {
+		ratio = DIV_ROUND_CLOSEST(*parent_rate, rate);
+		if (!ratio) {
+			dev_err(dev, "CCK frequency above kernel frequency\n");
+			return -EINVAL;
+		}
+
+		delta = abs(*parent_rate - (ratio * rate));
+		if (delta) {
+			/* Warn if frequency deviation is higher than 1% */
+			if (delta / *parent_rate > 1)
+				dev_warn(dev, "CCK clock frequency not accurate\n");
+				/*
+				 * TODO: If rate is not a multiple of freq,
+				 * try to change parent rate ?
+				 */
+			else
+				dev_dbg(dev, "CCK clock frequency not accurate\n");
+		}
+
+		/*
+		 * The total divider ratio must be split between proc divider and
+		 * cck divider. Try to maximize cck divider first, to help fulfilling
+		 * frequency ratio requirements between fproc and fcck.
+		 */
+		cckdiv = gcd(ratio, MDF_CCKDIV_MAX);
+		procdiv = ratio / cckdiv;
+
+		if (procdiv > MDF_PROCDIV_MAX) {
+			dev_err(dev, "Proc divider out of range: %d > %d\n",
+				procdiv, MDF_PROCDIV_MAX);
+			return -EINVAL;
+		}
+
+		priv->procdiv = procdiv;
+		priv->cckdiv = cckdiv;
+	} else {
+		ratio = priv->procdiv * priv->cckdiv;
+	}
+
+	return DIV_ROUND_CLOSEST_ULL((u64)*parent_rate, ratio);
+};
+
+static const struct clk_ops cck_gate_ops = {
+	.enable = stm32_mdf_cck_gate_enable,
+	.disable = stm32_mdf_cck_gate_disable,
+	.is_enabled = stm32_mdf_cck_gate_is_enabled,
+};
+
+const struct clk_ops cck_divider_ops = {
+	.recalc_rate = stm32_mdf_cck_divider_recalc_rate,
+	.round_rate = stm32_mdf_cck_divider_round_rate,
+	.set_rate = stm32_mdf_cck_divider_set_rate,
+};
+
+static int stm32_mdf_core_register_clock_provider(struct platform_device *pdev,
+						  struct stm32_mdf_priv *priv)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw *hw;
+	struct property *prop;
+	struct clk_parent_data pdata = { .name = "ker_ck" };
+	struct clk_gate *gate;
+	struct clk_divider *div;
+	const char *clk_name;
+	const __be32 *p;
+	u32 ckgcr = 0;
+	int index;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, STM32_MDF_MAX_CCK), GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	of_property_for_each_u32 (node, "clock-indices", prop, p, index) {
+		of_property_read_string_index(node, "clock-output-names", index, &clk_name);
+
+		if (index >= STM32_MDF_MAX_CCK) {
+			dev_err(dev, "Too many cck providers defined\n");
+			return -EINVAL;
+		}
+
+		gate = &priv->prov[index].gate;
+		gate->reg = priv->base + MDF_CKGCR_REG;
+		gate->bit_idx = index ? MDF_CKG_CCK1EN : MDF_CKG_CCK0EN;
+
+		div = &priv->prov[index].div;
+		div->reg = priv->base + MDF_CKGCR_REG;
+		div->shift = MDF_CKG_CCKDIV_SHIFT;
+		div->width = MDF_CKG_CCKDIV_WIDTH;
+		div->lock = &priv->prov[index].lock;
+		spin_lock_init(div->lock);
+
+		priv->prov[index].data = priv;
+
+		hw = devm_clk_hw_register_composite_pdata(dev, clk_name, &pdata, 1, NULL, NULL,
+							  &priv->prov[index].div.hw,
+							  &cck_divider_ops, &gate->hw,
+							  &cck_gate_ops, 0);
+		if (IS_ERR(hw)) {
+			dev_err(dev, "Failed to register %s clock provider\n", clk_name);
+			return PTR_ERR(hw);
+		}
+
+		priv->prov[index].hw = hw;
+		clk_data->hws[index] = hw;
+		clk_data->num++;
+
+		/* Configure the CCKx clock as output */
+		ckgcr |= index ? MDF_CKG_CCK1DIR : MDF_CKG_CCK0DIR;
+	}
+
+	devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+
+	/* Configure CKGCR register */
+	return regmap_set_bits(priv->regmap, MDF_CKGCR_REG, ckgcr);
+}
+
+static int stm32_mdf_of_cck_get(struct platform_device *pdev, const char *prop,
+				unsigned long *cck_freq)
+{
+	struct device *dev = &pdev->dev;
+	u32 freq;
+	int ret;
+
+	ret = device_property_read_u32(dev, prop, &freq);
+	if (ret < 0) {
+		/* If property does not exist return immediately */
+		if (ret == -EINVAL)
+			return 0;
+
+		dev_err(dev, "Failed to read %s property: %d\n", prop, ret);
+		return ret;
+	}
+
+	if (!freq) {
+		dev_err(dev, "Null frequency not allowed for %s\n", prop);
+		return -EINVAL;
+	}
+	*cck_freq = freq;
+
+	return 0;
+}
+
+static int stm32_mdf_core_parse_clocks(struct platform_device *pdev, struct stm32_mdf_priv *priv)
+{
+	struct device *dev = &pdev->dev;
+	struct clk *kclk;
+	int ret;
+
+	kclk = devm_clk_get(dev, "ker_ck");
+	if (IS_ERR(kclk))
+		return dev_err_probe(dev, PTR_ERR(kclk), "Failed to get kernel clock\n");
+	priv->kclk = kclk;
+
+	/* CCK0 and CCK1 clocks are optional. Used only in SPI master modes. */
+	ret = stm32_mdf_of_cck_get(pdev, "st,cck-freq-hz", &priv->cck_freq[0]);
+	if (ret)
+		return ret;
+
+	ret = stm32_mdf_of_cck_get(pdev, "st,cck-freq-hz", &priv->cck_freq[1]);
+	if (ret)
+		return ret;
+
+	ret = stm32_mdf_core_register_clock_provider(pdev, priv);
+	if (ret)
+		return ret;
+
+	if (priv->cck_freq[0]) {
+		ret = clk_set_rate(priv->prov[0].div.hw.clk, priv->cck_freq[0]);
+		if (ret) {
+			dev_err(dev, "Failed to set cck0 rate: %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (priv->cck_freq[1]) {
+		ret = clk_set_rate(priv->prov[1].div.hw.clk, priv->cck_freq[1]);
+		if (ret) {
+			dev_err(dev, "Failed to set cck0 rate: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_get_sitf_clk(struct device_node *np, struct stm32_mdf_sitf *sitf)
+{
+	struct clk *sck;
+
+	sck = of_clk_get(np, 0);
+	if (IS_ERR(sck)) {
+		if (PTR_ERR(sck) == -ENOENT)
+			return 0;
+		else
+			return dev_err_probe(sitf->dev, PTR_ERR(sck), "Can't get serial clock\n");
+	}
+
+	if (!strncmp(__clk_get_name(sck), "cck0", 4))
+		sitf->scksrc = STM32_MDF_SCKSRC_CCK0;
+	else if (!strncmp(__clk_get_name(sck), "cck1", 4))
+		sitf->scksrc = STM32_MDF_SCKSRC_CCK1;
+	else
+		sitf->scksrc = STM32_MDF_SCKSRC_CLK;
+
+	sitf->sck = sck;
+
+	return 0;
+};
+
+static int stm32_mdf_core_parse_sitf(struct platform_device *pdev, struct stm32_mdf_priv *priv)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct stm32_mdf *mdf = &priv->mdf;
+	struct stm32_mdf_sitf *sitf = mdf->sitf;
+	struct device_node *child;
+	struct device *dev = &pdev->dev;
+	struct resource res;
+	void __iomem *base;
+	const char *str;
+	int ret, i;
+	u32 idx, mode, sitfcr;
+
+	sitf = devm_kzalloc(&pdev->dev, mdf->nbf * sizeof(*mdf->sitf), GFP_KERNEL);
+	if (!sitf)
+		return -ENOMEM;
+	spin_lock_init(&sitf->lock);
+	mdf->sitf = sitf;
+
+	for (i = 0; i < mdf->nbf; i++) {
+		sitf[i].dev = dev;
+		sitf[i].scksrc = STM32_MDF_SCKSRC_NONE;
+	}
+
+	for_each_available_child_of_node(node, child) {
+		/* If compatible found, child node is not a sitf node. skip it */
+		ret = of_property_read_string(child, "compatible", &str);
+		if (!ret)
+			continue;
+
+		ret = of_property_read_u32(child, "reg", &idx);
+		if (ret) {
+			dev_err(dev, "Could not get interface index: %d\n", ret);
+			return ret;
+		}
+		idx = (idx >> 7) - 1;
+
+		of_address_to_resource(child, 0, &res);
+		if (ret) {
+			dev_err(dev, "Failed to get resource from address: %d\n", ret);
+			return ret;
+		}
+
+		base = devm_ioremap_resource(dev, &res);
+		if (IS_ERR(base)) {
+			ret = PTR_ERR(base);
+			dev_err(dev, "Failed to get sitf resource: %d\n", ret);
+			return ret;
+		}
+		sitf[idx].base = base;
+
+		if (idx > priv->mdf.nbf) {
+			dev_err(dev, "Interface index [%d] exceeds maximum [%d]\n", idx,
+				priv->mdf.nbf);
+			return -EINVAL;
+		}
+
+		/* Get SITF mode */
+		ret = of_property_read_string(child, "st,sitf-mode", &str);
+		if (ret) {
+			/* skip if mode is not defined */
+			if (ret == -EINVAL)
+				continue;
+
+			dev_err(dev, "Could not get interface mode: %d\n", ret);
+			return ret;
+		}
+
+		i = 0;
+		while (i < STM32_MDF_MODE_NB) {
+			if (!strncmp(stm32_mdf_mode[i].name, str, STM32_MDF_MODE_SZ)) {
+				mode = stm32_mdf_mode[i].idx;
+				break;
+			}
+			i++;
+		}
+
+		if (i >= STM32_MDF_MODE_NB) {
+			dev_err(dev, "Unknown serial interface mode [%s]\n", str);
+			return -EINVAL;
+		}
+
+		sitf[idx].mode = mode;
+		sitfcr = MDF_SITFCR_SITFMOD(mode);
+
+		/* Optional clocks. Clock not needed in Manchester mode */
+		ret = stm32_get_sitf_clk(child, &sitf[idx]);
+		if (ret)
+			return ret;
+
+		if ((mode == STM32_MDF_MODE_SPI || mode == STM32_MDF_MODE_SPI_LF) &&
+		    sitf[idx].scksrc == STM32_MDF_SCKSRC_NONE) {
+			dev_err(dev, "Missing clock for serial interface [%d]\n", idx);
+			return -EINVAL;
+		}
+
+		sitf[idx].kclk = priv->kclk;
+		sitf[idx].registered = true;
+		sitfcr |= MDF_SITFCR_SCKSRC(sitf[idx].scksrc);
+
+		/* TODO: check clock config & ratio cck/ck_ker versus mode */
+
+		/* Configure SITF register */
+		stm32_mdf_sitf_set_bits(&sitf[idx], MDF_SITFCR_REG, sitfcr);
+
+		dev_dbg(dev, "Serial interface [%d] registered\n", idx);
+	}
+
+	return 0;
+}
+
+static int stm32_mdf_core_parse_of(struct platform_device *pdev, struct stm32_mdf_priv *priv)
+{
+	struct device_node *node = pdev->dev.of_node;
+	int ret;
+
+	if (!node)
+		return -EINVAL;
+
+	ret = stm32_mdf_core_parse_clocks(pdev, priv);
+	if (ret < 0)
+		return ret;
+
+	ret = stm32_mdf_core_parse_sitf(pdev, priv);
+	if (ret < 0)
+		return ret;
+
+	return ret;
+}
+
+static int stm32_mdf_core_identification(struct platform_device *pdev, struct stm32_mdf_priv *priv)
+{
+	struct stm32_mdf *mdf = &priv->mdf;
+	u32 val;
+	int ret;
+
+	ret = regmap_read(priv->regmap, MDF_IPIDR_REG, &val);
+	if (ret)
+		return ret;
+
+	if (val == STM32MP25_MDF_IPIDR_NUMBER) {
+		ret = regmap_read(priv->regmap, MDF_HWCFGR_REG, &val);
+		if (ret)
+			return ret;
+
+		mdf->nbf = FIELD_GET(MDF_HWCFGR_NBF_MASK, val);
+
+		ret = regmap_read(priv->regmap, MDF_VERR_REG, &val);
+
+		dev_dbg(&pdev->dev, "MDF version: %lu.%lu\n", FIELD_GET(MDF_VERR_MAJREV_MASK, val),
+			FIELD_GET(MDF_VERR_MINREV_MASK, val));
+	} else {
+		dev_err(&pdev->dev, "Unexpected ID number: 0x%x\n", val);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int stm32_mdf_core_probe(struct platform_device *pdev)
+{
+	struct stm32_mdf_priv *priv;
+	struct resource *res;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->pdev = pdev;
+
+	priv->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+	priv->phys_base = res->start;
+
+	priv->regmap =
+		devm_regmap_init_mmio_clk(&pdev->dev, "ker_ck", priv->base, &stm32_mdf_regmap_cfg);
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		dev_err(&pdev->dev, "Failed to allocate regmap: %d\n", ret);
+		return ret;
+	}
+
+	ret = stm32_mdf_core_identification(pdev, priv);
+	if (ret < 0)
+		return ret;
+
+	ret = stm32_mdf_core_parse_of(pdev, priv);
+	if (ret < 0)
+		return ret;
+
+	platform_set_drvdata(pdev, priv);
+
+	return devm_of_platform_populate(&pdev->dev);
+}
+
+static const struct of_device_id stm32_mdf_of_match[] = {
+	{ .compatible = "st,stm32mp25-mdf" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, stm32_mdf_of_match);
+
+static struct platform_driver stm32_mdf_driver = {
+	.probe = stm32_mdf_core_probe,
+	.driver = {
+		.name = "stm32-mdf",
+		.of_match_table = stm32_mdf_of_match,
+	},
+};
+
+module_platform_driver(stm32_mdf_driver);
+
+MODULE_AUTHOR("Olivier Moysan <olivier.moysan@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 MDF driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/stm32-mdf.h b/drivers/iio/adc/stm32-mdf.h
new file mode 100644
index 000000000000..5654bba806bb
--- /dev/null
+++ b/drivers/iio/adc/stm32-mdf.h
@@ -0,0 +1,283 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * This file is part of STM32 MDF driver
+ *
+ * Copyright (C) 2023, STMicroelectronics.
+ * Author: Olivier Moysan <olivier.moysan@foss.st.com>.
+ */
+
+#include <linux/bitfield.h>
+
+/* Register definitions */
+#define MDF_GCR_REG 0x00
+#define MDF_CKGCR_REG 0x04
+#define MDF_HWCFGR_REG 0xff0
+#define MDF_VERR_REG 0xff4
+#define MDF_IPIDR_REG 0xff8
+#define MDF_SIDR_REG 0xffc
+
+/* Registers offsets relative to sitf base address */
+#define MDF_SITFCR_REG 0x00 /* 0x80 * x + offset */
+
+/* Registers offsets relative to filter base address */
+#define MDF_BSMXCR_REG 0x00 /* 0x84 * x + offset */
+#define MDF_DFLTCR_REG 0x04
+#define MDF_DFLTCICR_REG 0x08
+#define MDF_DFLTRSFR_REG 0x0c
+#define MDF_DFLTINTR_REG 0x10
+#define MDF_OLDCR_REG 0x14
+#define MDF_OLDTHLR_REG 0x18
+#define MDF_OLDTHHR_REG 0x1c
+#define MDF_DLYCR_REG 0x20
+#define MDF_SCDCR_REG 0x24
+#define MDF_DFLTIER_REG 0x28
+#define MDF_DFLTISR_REG 0x2C
+#define MDF_OECCR_REG 0x30
+#define MDF_SNPSxDR 0x64
+#define MDF_DLTDR_REG 0x6c
+
+/* MDF_GCR: Global Control Register */
+#define MDF_GCR_TRGO BIT(0)
+#define MDF_GCR_ILVNB_MASK GENMASK(7, 4)
+#define MDF_GCR_ILVNB(v) FIELD_PREP(MDF_GCR_ILVNB_MASK, v)
+
+/* MDF_CKGCR: Clock Generator Control Register */
+#define MDF_CKG_CKGDEN BIT(0)
+#define MDF_CKG_CCK0EN BIT(1)
+#define MDF_CKG_CCK1EN BIT(2)
+#define MDF_CKG_CKGMOD BIT(4)
+#define MDF_CKG_CCK0DIR BIT(5)
+#define MDF_CKG_CCK1DIR BIT(6)
+#define MDF_CKG_TRGSENS BIT(8)
+#define MDF_CKG_TRGSRC_MASK GENMASK(15, 12)
+#define MDF_CKG_TRGSRC(v) FIELD_PREP(MDF_CKG_TRGSRC_MASK, v)
+#define MDF_CKG_CCKDIV_MASK GENMASK(19, 16)
+#define MDF_CKG_CCKDIV_SHIFT 16
+#define MDF_CKG_CCKDIV_WIDTH 4
+#define MDF_CKG_CCKDIV(v) FIELD_PREP(MDF_CKG_CCKDIV_MASK, v)
+#define MDF_CKG_PROCDIV_MASK GENMASK(30, 24)
+#define MDF_CKG_PROCDIV(v) FIELD_PREP(MDF_CKG_PROCDIV_MASK, v)
+#define MDF_CKG_ACTIVE BIT(31)
+
+/* MDF_OR: Option Register */
+#define MDF_OR_OPTION_MASK OPTION(31, 0)
+#define MDF_OR_OPTION(v) FIELD_PREP(MDF_OR_OPTION_MASK, v)
+
+/* MDF_SITFCR: Serial Interface Control Register */
+#define MDF_SITFCR_SITFEN BIT(0)
+#define MDF_SITFCR_SCKSRC_MASK GENMASK(2, 1)
+#define MDF_SITFCR_SCKSRC(v) FIELD_PREP(MDF_SITFCR_SCKSRC_MASK, v)
+#define MDF_SITFCR_SITFMOD_MASK GENMASK(6, 4)
+#define MDF_SITFCR_SITFMOD(v) FIELD_PREP(MDF_SITFCR_SITFMOD_MASK, v)
+#define MDF_SITFCR_STH_MASK GENMASK(12, 8)
+#define MDF_SITFCR_STH(v) FIELD_PREP(MDF_SITFCR_STH_MASK, v)
+#define MDF_SITFCR_ACTIVE BIT(31)
+
+/* MDF_BSMXCR: Bitstream Matrix Control Register */
+#define MDF_BSMXCR_BSSEL_MASK GENMASK(4, 0)
+#define MDF_BSMXCR_BSSEL(v) FIELD_PREP(MDF_BSMXCR_BSSEL_MASK, v)
+#define MDF_BSMXCR_ACTIVE BIT(31)
+
+/* MDF_DFLTCR: Digital Filter Control Register */
+#define MDF_DFLTCR_DFLTEN BIT(0)
+#define MDF_DFLTCR_DMAEN BIT(1)
+#define MDF_DFLTCR_FTH BIT(2)
+#define MDF_DFLTCR_ACQMOD_MASK GENMASK(6, 4)
+#define MDF_DFLTCR_ACQMOD(v) FIELD_PREP(MDF_DFLTCR_ACQMOD_MASK, v)
+#define MDF_DFLTCR_TRGSENS BIT(8)
+#define MDF_DFLTCR_TRGSRC_MASK GENMASK(12, 15)
+#define MDF_DFLTCR_TRGSRC(v) FIELD_PREP(MDF_DFLTCR_TRGSRC_MASK, v)
+#define MDF_DFLTCR_SNPSFMT BIT(16)
+#define MDF_DFLTCR_NBDIS_MASK GENMASK(27, 20)
+#define MDF_DFLTCR_NBDIS(v) FIELD_PREP(MDF_DFLTCR_NBDIS_MASK, v)
+#define MDF_DFLTCR_DFLTRUN BIT(30)
+#define MDF_DFLTCR_ACTIVE BIT(31)
+
+/* MDF_DFLTCICR: Digital Filter Configuration Register */
+#define MDF_DFLTCICR_DATSRC_MASK GENMASK(1, 0)
+#define MDF_DFLTCICR_DATSRC(v) FIELD_PREP(MDF_DFLTCICR_DATSRC_MASK, v)
+#define MDF_DFLTCICR_CICMOD_MASK GENMASK(6, 4)
+#define MDF_DFLTCICR_CICMOD(v) FIELD_PREP(MDF_DFLTCICR_CICMOD_MASK, v)
+#define MDF_DFLTCICR_MCICD_MASK GENMASK(16, 8)
+#define MDF_DFLTCICR_MCICD(v) FIELD_PREP(MDF_DFLTCICR_MCICD_MASK, v)
+#define MDF_DFLTCICR_MCICD_MIN 2
+#define MDF_DFLTCICR_MCICD_MAX                                                 \
+	(FIELD_GET(MDF_DFLTCICR_MCICD_MASK, MDF_DFLTCICR_MCICD_MASK) + 1)
+#define MDF_DFLTCICR_SCALE_MASK GENMASK(25, 20)
+#define MDF_DFLTCICR_SCALE(v) FIELD_PREP(MDF_DFLTCICR_SCALE_MASK, v)
+
+/* MDF_DFLTRSFR: Reshape Filter Configuration Register */
+#define MDF_DFLTRSFR_RSFLTBYP BIT(0)
+#define MDF_DFLTRSFR_RSFLTD BIT(4)
+#define MDF_DFLTRSFR_HPFBYP BIT(7)
+#define MDF_DFLTRSFR_HPFC_MASK GENMASK(9, 8)
+#define MDF_DFLTRSFR_HPFC(v) FIELD_PREP(MDF_DFLTRSFR_HPFC_MASK, v)
+
+/* MDF_DFLTINTR: Integrator Configuration Register */
+#define MDF_DFLTINTR_INTDIV_MASK GENMASK(1, 0)
+#define MDF_DFLTINTR_INTDIV(v) FIELD_PREP(MDF_DFLTINTR_INTDIV_MASK, v)
+#define MDF_DFLTINTR_INTVAL_MASK GENMASK(10, 4)
+#define MDF_DFLTINTR_INTVAL(v) FIELD_PREP(MDF_DFLTINTR_INTVAL_MASK, v)
+
+/* MDF_OLDCR: Out-Of Limit Detector Control Register */
+#define MDF_OLDCR_OLDEN_MASK BIT(0)
+#define MDF_OLDCR_OLDEN(v) FIELD_PREP(MDF_OLDCR_OLDEN_MASK, v)
+#define MDF_OLDCR_THINB_MASK BIT(1)
+#define MDF_OLDCR_THINB(v) FIELD_PREP(MDF_OLDCR_THINB_MASK, v)
+#define MDF_OLDCR_BKOLD_MASK GENMASK(7, 4)
+#define MDF_OLDCR_BKOLD(v) FIELD_PREP(MDF_OLDCR_BKOLD_MASK, v)
+#define MDF_OLDCR_ACICN_MASK GENMASK(13, 12)
+#define MDF_OLDCR_ACICN(v) FIELD_PREP(MDF_OLDCR_ACICN_MASK, v)
+#define MDF_OLDCR_ACICD_MASK GENMASK(21, 17)
+#define MDF_OLDCR_ACICD(v) FIELD_PREP(MDF_OLDCR_ACICD_MASK, v)
+#define MDF_OLDCR_ACTIVE_MASK BIT(31)
+#define MDF_OLDCR_ACTIVE(v) FIELD_PREP(MDF_OLDCR_ACTIVE_MASK, v)
+
+/* MDF_OLDxTHLR: OLD Threshold Low Register */
+#define MDF_OLDTHLR_OLDTHL_MASK GENMASK(25, 0)
+#define MDF_OLDTHLR_OLDTHL(v) FIELD_PREP(MDF_OLDTHLR_OLDTHL_MASK, v)
+
+/* MDF_OLDxTHHR: OLD Threshold High Register */
+#define MDF_OLDTHHR_OLDTHH_MASK GENMASK(25, 0)
+#define MDF_OLDTHHR_OLDTHH(v) FIELD_PREP(MDF_OLDTHHR_OLDTHH_MASK, v)
+
+/* MDF_DLYCR: Delay control Register */
+#define MDF_DLYCR_SKPDLY_MASK GENMASK(6, 0)
+#define MDF_DLYCR_SKPDLY(v) FIELD_PREP(MDF_DLYCR_SKPDLY_MASK, v)
+
+/* MDF_SCDCR: Short circuit detector control Register */
+#define MDF_SCDCR_CDEN_MASK BIT(0)
+#define MDF_SCDCR_CDEN(v) FIELD_PREP(MDF_SCDCR_CDEN_MASK, v)
+#define MDF_SCDCR_BKSCD_MASK GENMASK(7, 4)
+#define MDF_SCDCR_BKSCD(v) FIELD_PREP(MDF_SCDCR_BKSCD_MASK, v)
+#define MDF_SCDCR_SCDT_MASK GENMASK(19, 12)
+#define MDF_SCDCR_SCDT(v) FIELD_PREP(MDF_SCDCR_SCDT_MASK, v)
+#define MDF_SCDCR_ACTIVE_MASK BIT(31)
+#define MDF_SCDCR_ACTIVE(v) FIELD_PREP(MDF_SCDCR_ACTIVE_MASK, v)
+
+/* MDF_DFLTIER: DFLT Interrupt enable Register */
+#define MDF_DFLTIER_FTHIE_MASK BIT(0)
+#define MDF_DFLTIER_FTHIE(v) FIELD_PREP(MDF_DFLTIER_FTHIE_MASK, v)
+#define MDF_DFLTIER_DOVRIE_MASK BIT(1)
+#define MDF_DFLTIER_DOVRIE(v) FIELD_PREP(MDF_DFLTIER_DOVRIE_MASK, v)
+#define MDF_DFLTIER_SSDRIE_MASK BIT(2)
+#define MDF_DFLTIER_SSDRIE(v) FIELD_PREP(MDF_DFLTIER_SSDRIE_MASK, v)
+#define MDF_DFLTIER_OLDIE_MASK BIT(4)
+#define MDF_DFLTIER_OLDIE(v) FIELD_PREP(MDF_DFLTIER_OLDIE_MASK, v)
+#define MDF_DFLTIER_SSOVRIE_MASK BIT(7)
+#define MDF_DFLTIER_SSOVRIE(v) FIELD_PREP(MDF_DFLTIER_SSOVRIE_MASK, v)
+#define MDF_DFLTIER_SCDIE_MASK BIT(8)
+#define MDF_DFLTIER_SCDIE(v) FIELD_PREP(MDF_DFLTIER_SCDIE_MASK, v)
+#define MDF_DFLTIER_SATIE_MASK BIT(9)
+#define MDF_DFLTIER_SATIE(v) FIELD_PREP(MDF_DFLTIER_SATIE_MASK, v)
+#define MDF_DFLTIER_CKABIE_MASK BIT(10)
+#define MDF_DFLTIER_CKABIE(v) FIELD_PREP(MDF_DFLTIER_CKABIE_MASK, v)
+#define MDF_DFLTIER_RFOVRIE_MASK BIT(11)
+#define MDF_DFLTIER_RFOVRIE(v) FIELD_PREP(MDF_DFLTIER_RFOVRIE_MASK, v)
+
+/* MDF_DFLTISR: DFLT Interrupt status Register */
+#define MDF_DFLTISR_FTHF_MASK BIT(0)
+#define MDF_DFLTISR_FTHF(v) FIELD_PREP(MDF_DFLTISR_FTHF_MASK, v)
+#define MDF_DFLTISR_DOVRF_MASK BIT(1)
+#define MDF_DFLTISR_DOVRF(v) FIELD_PREP(MDF_DFLTISR_DOVRF_MASK, v)
+#define MDF_DFLTISR_SSDRF_MASK BIT(2)
+#define MDF_DFLTISR_SSDRF(v) FIELD_PREP(MDF_DFLTISR_SSDRF_MASK, v)
+#define MDF_DFLTISR_OLDF_MASK BIT(4)
+#define MDF_DFLTISR_OLDF(v) FIELD_PREP(MDF_DFLTISR_OLDF_MASK, v)
+#define MDF_DFLTISR_SSOVRF_MASK BIT(7)
+#define MDF_DFLTISR_SSOVRF(v) FIELD_PREP(MDF_DFLTISR_SSOVRF_MASK, v)
+#define MDF_DFLTISR_SCDF_MASK BIT(8)
+#define MDF_DFLTISR_SCDF(v) FIELD_PREP(MDF_DFLTISR_SCDF_MASK, v)
+#define MDF_DFLTISR_SATF_MASK BIT(9)
+#define MDF_DFLTISR_SATF(v) FIELD_PREP(MDF_DFLTISR_SATF_MASK, v)
+#define MDF_DFLTISR_CKABF_MASK BIT(10)
+#define MDF_DFLTISR_CKABF(v) FIELD_PREP(MDF_DFLTISR_CKABF_MASK, v)
+#define MDF_DFLTISR_RFOVRF_MASK BIT(11)
+#define MDF_DFLTISR_RFOVRF(v) FIELD_PREP(MDF_DFLTISR_RFOVRF_MASK, v)
+
+/* MDF_OECCR: Offset Error Compensation Control Register */
+#define MDF_OECCR_OFFSET_MASK GENMASK(25, 0)
+#define MDF_OECCR_OFFSET(v) FIELD_PREP(MDF_OECCR_OFFSET_MASK, v)
+
+/* MDF_SNPSDR:  Snapshot Data Register */
+#define MDF_SNPSDR_MCICDC_MASK GENMASK(8, 0)
+#define MDF_SNPSDR_MCICDC(v) FIELD_PREP(MDF_SNPSDR_MCICDC_MASK, v)
+#define MDF_SNPSDR_EXTSDR_MASK GENMASK(15, 9)
+#define MDF_SNPSDR_EXTSDR(v) FIELD_PREP(MDF_SNPSDR_EXTSDR_MASK, v)
+#define MDF_SNPSDR_SDR_MASK GENMASK(31, 16)
+#define MDF_SNPSDR_SDR(v) FIELD_PREP(MDF_SNPSDR_SDR_MASK, v)
+
+/* MDF_DFLTDR: Digital Filter Data Register */
+#define MDF_DFLTDR_DR_MASK GENMASK(31, 8)
+#define MDF_DFLTDR_DR(v) FIELD_PREP(MDF_DFLTDR_DR_MASK, v)
+
+/* MDF_HWCFGR: Hardware configuration register */
+#define MDF_HWCFGR_FIFO_SIZE_MASK GENMASK(7, 0)
+#define MDF_HWCFGR_FIFO_SIZE(v) FIELD_PREP(MDF_HWCFGR_FIFO_SIZE_MASK, v)
+#define MDF_HWCFGR_NBF_MASK GENMASK(15, 8)
+#define MDF_HWCFGR_NBF(v) FIELD_PREP(MDF_HWCFGR_NBF_MASK, v)
+#define MDF_HWCFGR_FLT_CFG_MASK GENMASK(19, 16)
+#define MDF_HWCFGR_FLT_CFG(v) FIELD_PREP(MDF_HWCFGR_FLT_CFG_MASK, v)
+#define MDF_HWCFGR_SAD_MASK GENMASK(23, 20)
+#define MDF_HWCFGR_SAD(v) FIELD_PREP(MDF_HWCFGR_SAD_MASK, v)
+#define MDF_HWCFGR_OPTION_MASK GENMASK(31, 24)
+#define MDF_HWCFGR_OPTION(v) FIELD_PREP(MDF_HWCFGR_OPTION_MASK, v)
+
+/* MDF_VERR: Version Register */
+#define MDF_VERR_MINREV_MASK GENMASK(3, 0)
+#define MDF_VERR_MINREV(v) FIELD_PREP(MDF_VERR_MINREV_MASK, v)
+#define MDF_VERR_MAJREV_MASK GENMASK(7, 4)
+#define MDF_VERR_MAJREV(v) FIELD_PREP(MDF_VERR_MAJREV_MASK, v)
+
+/* MDF_IPIDR: Identification Register */
+#define MDF_IPIDR_ID_MASK GENMASK(31, 0)
+#define MDF_IPIDR_ID_MINREV(v) FIELD_PREP(MDF_IPIDR_ID_MASK, v)
+
+/* MDF_SIDR: Size Identification Register */
+#define MDF_SIDR_SID_MASK GENMASK(31, 0)
+#define MDF_SIDR_SID(v) FIELD_PREP(MDF_SIDR_SID_MASK, v)
+
+#define MDF_PROCDIV_MAX 512
+#define MDF_CCKDIV_MAX 16
+
+#define STM32MP25_MDF_IPIDR_NUMBER 0x00110032
+
+/*
+ * struct stm32_mdf_sitf - STM32 MDF serial interface data
+ * @dev: pointer to parent device
+ * @sck: sitf clock handle
+ * @kclk: mdf kernel clock handle
+ * @base: sitf registers base cpu addr
+ * @lock: sitf state manegement lock
+ * @refcnt: sitf usage reference counter
+ * @scksrc: sitf clock source
+ * @mode: sitf mode
+ * @registered: sitf status
+ */
+struct stm32_mdf_sitf {
+	struct device *dev;
+	struct clk *sck;
+	struct clk *kclk;
+	void __iomem *base;
+	spinlock_t lock; /* Manage race conditions on sitf state */
+	unsigned int refcnt;
+	unsigned int scksrc;
+	u32 mode;
+	bool registered;
+};
+
+/*
+ * struct stm32_mdf - STM32 MDF driver common data (for all instances)
+ * @sitf: pointer to serial interfaces list
+ * @nbf: total number of digital filters
+ */
+struct stm32_mdf {
+	struct stm32_mdf_sitf *sitf;
+	unsigned int nbf;
+};
+
+int stm32_mdf_start_mdf(struct stm32_mdf *mdf);
+int stm32_mdf_stop_mdf(struct stm32_mdf *mdf);
+
+int stm32_mdf_start_sitf(struct stm32_mdf_sitf *sitf);
+int stm32_mdf_stop_sitf(struct stm32_mdf_sitf *sitf);
diff --git a/include/linux/iio/adc/stm32-mdf-adc.h b/include/linux/iio/adc/stm32-mdf-adc.h
new file mode 100644
index 000000000000..b4b4d078a2a8
--- /dev/null
+++ b/include/linux/iio/adc/stm32-mdf-adc.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * This file discribe the STM32 MDF IIO driver API for audio part
+ *
+ * Copyright (C) 2023, STMicroelectronics.
+ * Author(s): Olivier Moysan <olivier.moysan@foss.st.com>.
+ */
+
+#ifndef STM32_MDF_ADC_H
+#define STM32_MDF_ADC_H
+
+#include <linux/iio/iio.h>
+
+int stm32_mdf_get_buff_cb(struct iio_dev *iio_dev,
+			  int (*cb)(const void *data, size_t size, void *private), void *private);
+int stm32_mdf_release_buff_cb(struct iio_dev *iio_dev);
+
+#endif
-- 
2.39.2

