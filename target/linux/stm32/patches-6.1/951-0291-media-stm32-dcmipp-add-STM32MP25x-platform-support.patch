From 7360ac91e00004f58799e36cc40d88047cc144b6 Mon Sep 17 00:00:00 2001
From: Alain Volmat <alain.volmat@foss.st.com>
Date: Wed, 1 Dec 2021 17:51:35 +0100
Subject: [PATCH 0291/1141] media: stm32: dcmipp: add STM32MP25x platform
 support

On the STM32MP25x platform, the DCMIPP embeds 3 pipes
instead of a single pipe on the previous STM32MP13x.
In addition to the byte pipe, the STM32MP25x has two
pixel based pipes (main & aux).  The main is made of
an ISP stage followed by a post-processing stage, while
aux pipe has only a post-processing stage.  The aux
pipe input can either be straight from the input or
coming from the output of the ISP stage of the main pipe.

In addition to that, the DCMIPP can receive input from
either a parallel interface or from a CSI2 interface via
the csi2host driver.

Change-Id: I17e5c30e86c627c618acf66c6baf8c7aad481c8f
Signed-off-by: Alain Volmat <alain.volmat@foss.st.com>
Signed-off-by: Hugues Fruchet <hugues.fruchet@foss.st.com>
---
 .../platform/st/stm32/stm32-dcmipp/Makefile   |    2 +-
 .../st/stm32/stm32-dcmipp/dcmipp-colorconv.c  |  362 +++++
 .../st/stm32/stm32-dcmipp/dcmipp-colorconv.h  |   26 +
 .../st/stm32/stm32-dcmipp/dcmipp-core.c       |  129 +-
 .../st/stm32/stm32-dcmipp/dcmipp-isp.c        | 1009 +++++++++++++
 .../st/stm32/stm32-dcmipp/dcmipp-pixelcap.c   | 1277 +++++++++++++++++
 .../st/stm32/stm32-dcmipp/dcmipp-pixelproc.c  |  900 ++++++++++++
 7 files changed, 3702 insertions(+), 3 deletions(-)
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.h
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelcap.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelproc.c

--- a/drivers/media/platform/st/stm32/stm32-dcmipp/Makefile
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/Makefile
@@ -2,4 +2,4 @@
 stm32-dcmipp-y := dcmipp-core.o dcmipp-common.o
 
 obj-$(CONFIG_VIDEO_STM32_DCMIPP) += stm32-dcmipp.o
-obj-$(CONFIG_VIDEO_STM32_DCMIPP) += dcmipp-parallel.o dcmipp-byteproc.o dcmipp-bytecap.o
+obj-$(CONFIG_VIDEO_STM32_DCMIPP) += dcmipp-parallel.o dcmipp-byteproc.o dcmipp-bytecap.o dcmipp-isp.o dcmipp-colorconv.o dcmipp-pixelproc.o dcmipp-pixelcap.o
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.c
@@ -0,0 +1,362 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-colorconv.h"
+
+/* Macro for negative coefficient, 11 bits coded */
+#define N11(val) (((val) ^ 0x7FF) + 1)
+/* Macro for added value, 10 bits coded */
+#define N10(val) (((val) ^ 0x3FF) + 1)
+
+/* Macro to convert row matrix to DCMIPP PxCCCyy register value */
+#define ROW(c1, c2, c3, add) ((c2) << 16 | (c1)), ((add) << 16 | (c3))
+
+static const u32 rgbfull_to_yuv601full[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(110),	N11(21),	128),
+/*  Y */ ROW(77,	150,		29,		0),
+/* Cb */ ROW(N11(44),	N11(87),	131,		128),
+};
+
+static const u32 rgbfull_to_yuv601lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(112,	N11(94),	N11(18),	128),
+/*  Y */ ROW(66,	129,		25,		16),
+/* Cb */ ROW(N11(38),	N11(74),	112,		128),
+};
+
+static const u32 rgbfull_to_yuv709full[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(119),	N11(12),	128),
+/*  Y */ ROW(55,	183,		18,		0),
+/* Cb */ ROW(N11(30),	N11(101),	131,		128),
+};
+
+static const u32 rgbfull_to_yuv709lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(112,	N11(102),	N11(10),	128),
+/*  Y */ ROW(47,	157,		16,		16),
+/* Cb */ ROW(N11(26),	N11(87),	112,		128),
+};
+
+static const u32 rgblim_to_yuv601lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(110),	N11(21),	128),
+/*  Y */ ROW(77,	150,		29,		0),
+/* Cb */ ROW(N11(44),	N11(87),	131,		128),
+};
+
+static const u32 rgblim_to_yuv709lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(119),	N11(12),	128),
+/*  Y */ ROW(55,	183,		18,		0),
+/* Cb */ ROW(N11(30),	N11(101),	131,		128),
+};
+
+static const u32 yuv601full_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(351,	256,		0,		N10(175)),
+/* G */  ROW(N11(179),	256,		N11(86),	132),
+/* B */  ROW(0,		256,		443,		N10(222)),
+};
+
+static const u32 yuv601lim_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(409,	298,		0,		N10(223)),
+/* G */  ROW(N11(208),	298,		N11(100),	135),
+/* B */  ROW(0,		298,		517,		N10(277)),
+};
+
+static const u32 yuv601lim_to_rgblim[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(351,	256,		0,		N10(175)),
+/* G */  ROW(N11(179),	256,		N11(86),	132),
+/* B */  ROW(0,		256,		443,		N10(222)),
+};
+
+static const u32 yuv709full_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(394,	256,		0,		N10(197)),
+/* G */  ROW(N11(118),	256,		N11(47),	82),
+/* B */  ROW(0,		256,		456,		N10(232)),
+};
+
+static const u32 yuv709lim_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(459,	298,		0,		N10(248)),
+/* G */  ROW(N11(137),	298,		N11(55),	77),
+/* B */  ROW(0,		298,		541,		N10(289)),
+};
+
+static const u32 yuv709lim_to_rgblim[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(394,	256,		0,		N10(197)),
+/* G */  ROW(N11(118),	256,		N11(47),	82),
+/* B */  ROW(0,		256,		465,		N10(232)),
+};
+
+/* cconv_matrices[src_fmt][src_range][sink_fmt][sink_range] */
+static const u32 *cconv_matrices[3][2][3][2] = {
+	/* RGB */
+	{
+		/* RGB full range */
+		{
+			/* RGB full range => RGB */
+			{
+				/* RGB full range => RGB full range */
+				NULL,
+				/* RGB full range => RGB limited range */
+				NULL,
+			},
+			/* RGB full range => YUV601 */
+			{
+				/* RGB full range => YUV601 full range */
+				rgbfull_to_yuv601full,
+				/* RGB full range => YUV601 limited range */
+				rgbfull_to_yuv601lim,
+			},
+			/* RGB full range => YUV709 */
+			{
+				/* RGB full range => YUV709 full range */
+				rgbfull_to_yuv709full,
+				/* RGB full range => YUV709 limited range */
+				rgbfull_to_yuv709lim,
+			},
+		},
+		/* RGB limited range */
+		{
+			/* RGB limited range => RGB */
+			{
+				/* RGB limited range => RGB full range */
+				NULL,
+				/* RGB limited range => RGB limited range */
+				NULL,
+			},
+			/* RGB limited range => YUV601 */
+			{
+				/* RGB limited range => YUV601 full range */
+				NULL,
+				/* RGB limited range => YUV601 limited range */
+				rgblim_to_yuv601lim,
+			},
+			/* RGB limited range => YUV709 */
+			{
+				/* RGB limited range => YUV709 full range */
+				NULL,
+				/* RGB limited range => YUV709 limited range */
+				rgblim_to_yuv709lim,
+			},
+		},
+	},
+	/* YUV601 */
+	{
+		/* YUV601 full range */
+		{
+			/* YUV601 full range => RGB */
+			{
+				/* YUV601 full range => RGB full range */
+				yuv601full_to_rgbfull,
+				/* YUV601 full range => RGB limited range */
+				NULL,
+			},
+			/* YUV601 full range => YUV601 */
+			{
+				/* YUV601 full range => YUV601 full range */
+				NULL,
+				/* YUV601 full range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV601 full range => YUV709 */
+			{
+				/* YUV601 full range => YUV709 full range */
+				NULL,
+				/* YUV601 full range => YUV709 limited range */
+				NULL,
+			},
+		},
+		/* YUV601 limited range */
+		{
+			/* YUV601 limited range => RGB */
+			{
+				/* YUV601 limited range => RGB full range */
+				yuv601lim_to_rgbfull,
+				/* YUV601 limited range => RGB limited range */
+				yuv601lim_to_rgblim,
+			},
+			/* YUV601 limited range => YUV601 */
+			{
+				/* YUV601 limited range => YUV601 full range */
+				NULL,
+				/* YUV601 limited range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV601 limited range => YUV709 */
+			{
+				/* YUV601 limited range => YUV709 full range */
+				NULL,
+				/* YUV601 limited range => YUV709 limited range */
+				NULL,
+			},
+		},
+	},
+	/* YUV709 */
+	{
+		/* YUV709 full range */
+		{
+			/* YUV709 full range => RGB */
+			{
+				/* YUV709 full range => RGB full range */
+				yuv709full_to_rgbfull,
+				/* YUV709 full range => RGB limited range */
+				NULL,
+			},
+			/* YUV709 full range => YUV601 */
+			{
+				/* YUV709 full range => YUV601 full range */
+				NULL,
+				/* YUV709 full range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV709 full range => YUV709 */
+			{
+				/* YUV709 full range => YUV709 full range */
+				NULL,
+				/* YUV709 full range => YUV709 limited range */
+				NULL,
+			},
+		},
+		/* YUV709 limited range */
+		{
+			/* YUV709 limited range => RGB */
+			{
+				/* YUV709 limited range => RGB full range */
+				yuv709lim_to_rgbfull,
+				/* YUV709 limited range => RGB limited range */
+				yuv709lim_to_rgblim,
+			},
+			/* YUV709 limited range => YUV601 */
+			{
+				/* YUV709 limited range => YUV601 full range */
+				NULL,
+				/* YUV709 limited range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV709 limited range => YUV709 */
+			{
+				/* YUV709 limited range => YUV709 full range */
+				NULL,
+				/* YUV709 limited range => YUV709 limited range */
+				NULL,
+			},
+		},
+	},
+};
+
+enum cconv_fmt {
+	FMT_RGB = 0,
+	FMT_YUV601,
+	FMT_YUV709
+};
+
+static inline enum cconv_fmt to_cconv_fmt(struct v4l2_mbus_framefmt *fmt)
+{
+	/* YUV format codes are within the 0x2xxx */
+	if (fmt->code >= MEDIA_BUS_FMT_Y8_1X8 &&
+	    fmt->code < MEDIA_BUS_FMT_SBGGR8_1X8) {
+		if (fmt->ycbcr_enc == V4L2_YCBCR_ENC_709)
+			return FMT_YUV709;
+		else
+			return FMT_YUV601;
+	}
+
+	/* All other formats are referred as RGB, indeed, demosaicing bloc
+	 * generate RGB format
+	 */
+	return FMT_RGB;
+};
+
+#define FMT_STR(f) ({					\
+	typeof(f) __f = (f);				\
+	(__f) == FMT_RGB ? "RGB" :			\
+	(__f) == FMT_YUV601 ? "YUV601" :		\
+	(__f) == FMT_YUV709 ? "YUV709" : "?"; })
+
+enum cconv_range {
+	RANGE_FULL = 0,
+	RANGE_LIMITED,
+};
+
+static inline enum cconv_range to_cconv_range(struct v4l2_mbus_framefmt *fmt)
+{
+	if (fmt->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+		return RANGE_FULL;
+
+	return RANGE_LIMITED;
+};
+
+#define RANGE_STR(range) ((range) == RANGE_FULL ? "full" : "limited")
+
+int dcmipp_colorconv_configure(struct device *dev,
+			       struct v4l2_mbus_framefmt *sink,
+			       struct v4l2_mbus_framefmt *src,
+			       struct dcmipp_colorconv_config *cfg)
+{
+	const u32 *cconv_matrix;
+	enum cconv_fmt sink_fmt;
+	enum cconv_range sink_range;
+	enum cconv_fmt src_fmt;
+	enum cconv_range src_range;
+	int i;
+
+	sink_fmt = to_cconv_fmt(sink);
+	sink_range = to_cconv_range(sink);
+	src_fmt = to_cconv_fmt(src);
+	src_range = to_cconv_range(src);
+
+	if (sink_fmt == src_fmt &&
+	    sink_range == src_range) {
+		cfg->enable = false;
+		return 0;
+	}
+
+	/* color conversion */
+	cconv_matrix = cconv_matrices[sink_fmt][sink_range][src_fmt][src_range];
+
+	dev_dbg(dev, "cconv_matrices[%d][%d][%d][%d]=%p\n",
+		sink_fmt, sink_range, src_fmt, src_range, cconv_matrix);
+	if (!cconv_matrix) {
+		dev_err(dev, "Unsupported color conversion %s-%s => %s-%s\n",
+			FMT_STR(sink_fmt), RANGE_STR(sink_range),
+			FMT_STR(src_fmt), RANGE_STR(src_range));
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "color conversion %s-%s => %s-%s\n",
+		FMT_STR(sink_fmt), RANGE_STR(sink_range),
+		FMT_STR(src_fmt), RANGE_STR(src_range));
+
+	if (src_range == RANGE_LIMITED)
+		cfg->clamping = true;
+
+	cfg->enable = true;
+
+	for (i = 0; i < ARRAY_SIZE(cfg->conv_matrix); i++)
+		cfg->conv_matrix[i] = cconv_matrix[i];
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dcmipp_colorconv_configure);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#ifndef _DCMIPP_COLORCONV_H_
+#define _DCMIPP_COLORCONV_H_
+
+struct dcmipp_colorconv_config {
+	unsigned int conv_matrix[6];
+	bool clamping;
+	bool enable;
+};
+
+int dcmipp_colorconv_configure(struct device *dev,
+			       struct v4l2_mbus_framefmt *sink,
+			       struct v4l2_mbus_framefmt *src,
+			       struct dcmipp_colorconv_config *cfg);
+
+#endif
+
--- a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c
@@ -7,7 +7,6 @@
  *          Alain Volmat <alain.volmat@foss.st.com>
  *          for STMicroelectronics.
  */
-
 #include <linux/clk.h>
 #include <linux/component.h>
 #include <linux/delay.h>
@@ -37,6 +36,8 @@
 }
 
 #define DCMIPP_CMHWCFGR (0x200)
+#define DCMIPP_CMCR (0x204)
+#define DCMIPP_CMCR_INSEL BIT(0)
 #define DCMIPP_P0HWCFGR (0x400)
 #define DCMIPP_VERR (0xFF4)
 
@@ -48,6 +49,7 @@ struct dcmipp_device {
 	/* Hardware resources */
 	struct reset_control		*rstc;
 	void __iomem			*regs;
+	struct clk			*mclk;
 	struct clk			*kclk;
 
 	/* The pipeline configuration */
@@ -130,6 +132,68 @@ static const struct dcmipp_pipeline_conf
 	.num_links	= ARRAY_SIZE(stm32mp13_ent_links)
 };
 
+#define	ID_MAIN_ISP 3
+#define	ID_MAIN_POSTPROC 4
+#define	ID_MAIN_CAPTURE	5
+#define	ID_AUX_POSTPROC 6
+#define	ID_AUX_CAPTURE 7
+static const struct dcmipp_ent_config stm32mp25_ent_config[] = {
+	{
+		.name = "dcmipp_parallel",
+		.drv = "dcmipp-parallel",
+	},
+	{
+		.name = "dcmipp_dump_postproc",
+		.drv = "dcmipp-byteproc",
+	},
+	{
+		.name = "dcmipp_dump_capture",
+		.drv = "dcmipp-bytecap",
+	},
+	{
+		.name = "dcmipp_main_isp",
+		.drv = "dcmipp-isp",
+	},
+	{
+		.name = "dcmipp_main_postproc",
+		.drv = "dcmipp-pixelproc",
+	},
+	{
+		.name = "dcmipp_main_capture",
+		.drv = "dcmipp-pixelcap",
+	},
+	{
+		.name = "dcmipp_aux_postproc",
+		.drv = "dcmipp-pixelproc",
+	},
+	{
+		.name = "dcmipp_aux_capture",
+		.drv = "dcmipp-pixelcap",
+	},
+};
+
+static const struct dcmipp_ent_link stm32mp25_ent_links[] = {
+	DCMIPP_ENT_LINK(ID_PARALLEL,      1, ID_DUMP_BYTEPROC, 0, 0),
+	DCMIPP_ENT_LINK(ID_DUMP_BYTEPROC, 1, ID_DUMP_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_PARALLEL,	1, ID_MAIN_ISP,  0, 0),
+	DCMIPP_ENT_LINK(ID_MAIN_ISP,	1, ID_MAIN_POSTPROC,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_MAIN_ISP,	2, ID_AUX_POSTPROC,  0, 0),
+	DCMIPP_ENT_LINK(ID_MAIN_POSTPROC,	1, ID_MAIN_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_PARALLEL,	1, ID_AUX_POSTPROC,  0, 0),
+	DCMIPP_ENT_LINK(ID_AUX_POSTPROC,	1, ID_AUX_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+};
+
+static const struct dcmipp_pipeline_config stm32mp25_pipe_cfg = {
+	.ents		= stm32mp25_ent_config,
+	.num_ents	= ARRAY_SIZE(stm32mp25_ent_config),
+	.links		= stm32mp25_ent_links,
+	.num_links	= ARRAY_SIZE(stm32mp25_ent_links)
+};
+
 /* -------------------------------------------------------------------------- */
 #define LINK_FLAG_TO_STR(f) ((f) == 0 ? "" :\
 			     (f) == MEDIA_LNK_FL_ENABLED ? "ENABLED" :\
@@ -290,6 +354,7 @@ static const struct component_master_ops
 
 static const struct of_device_id dcmipp_of_match[] = {
 	{ .compatible = "st,stm32mp13-dcmipp", .data = &stm32mp13_pipe_cfg},
+	{ .compatible = "st,stm32mp25-dcmipp", .data = &stm32mp25_pipe_cfg},
 	{ /* end node */ },
 };
 MODULE_DEVICE_TABLE(of, dcmipp_of_match);
@@ -380,6 +445,9 @@ static int dcmipp_graph_notify_bound(str
 	struct dcmipp_ent_device *sink;
 	struct device_node *np = dcmipp->dev->of_node;
 	struct v4l2_fwnode_endpoint ep = { .bus_type = 0 };
+	struct device_node *_np = dcmipp->dev->of_node;//FIXME _np/_ep...
+	struct device_node *_ep;
+	u32 flags = MEDIA_LNK_FL_ENABLED;
 
 	dev_dbg(dcmipp->dev, "Subdev \"%s\" bound\n", subdev->name);
 
@@ -438,9 +506,53 @@ static int dcmipp_graph_notify_bound(str
 			dev_dbg(dcmipp->dev, "DCMIPP is now linked to \"%s\"\n",
 				subdev->name);
 
+		/* Use the parallel interface */
+		reg_write(dcmipp, DCMIPP_CMCR, 0);
+
 		return 0;
 	}
 
+	/*
+	 * CSI-2 receiver
+	 * Connect all of its channels to the DCMIPP pipes
+	 */
+	for_each_endpoint_of_node(_np, _ep) {
+		struct of_endpoint endpoint;
+		unsigned int sink_ids[3] = {ID_DUMP_BYTEPROC, ID_MAIN_ISP, ID_AUX_POSTPROC};
+		unsigned int i;
+
+		of_graph_parse_endpoint(_ep, &endpoint);
+		dev_info(dcmipp->dev, "endpoint.port=%d\n", endpoint.port);
+//FIXME check	if ((src_pad + endpoint.port) > subdev->entity.num_pads)
+
+		for (i = 0; i < ARRAY_SIZE(sink_ids); i++) {
+			sink = platform_get_drvdata(dcmipp->subdevs[sink_ids[i]]);
+			ret = media_create_pad_link(&subdev->entity, src_pad + endpoint.port,
+						    sink->ent, 0,
+						    flags);
+			if (ret)
+				dev_err(dcmipp->dev, "Failed to create link \"%s\":%d -> %d:\"%s\" [%s]\n",
+					subdev->name, src_pad + endpoint.port,
+					0, sink->ent->name,
+					LINK_FLAG_TO_STR(flags));
+			else
+				dev_dbg(dcmipp->dev, "Create link \"%s\":%d -> %d:\"%s\" [%s]\n",
+					subdev->name, src_pad + endpoint.port,
+					0, sink->ent->name,
+					LINK_FLAG_TO_STR(flags));
+		}
+
+		/*
+		 * Enable media link of first port connection by default,
+		 * Let the other connections disabled, they could be enabled
+		 * later on using MC
+		 */
+		flags = 0;
+	}
+
+	/* Use the CSI interface */
+	reg_write(dcmipp, DCMIPP_CMCR, DCMIPP_CMCR_INSEL);
+
 	return ret;
 }
 
@@ -492,7 +604,7 @@ static int dcmipp_probe(struct platform_
 	struct dcmipp_device *dcmipp;
 	struct component_match *comp_match = NULL;
 	struct resource *res;
-	struct clk *kclk;
+	struct clk *kclk, *mclk;
 	const struct dcmipp_pipeline_config *pipe_cfg;
 	int irq;
 	int ret;
@@ -566,6 +678,14 @@ static int dcmipp_probe(struct platform_
 				     "Unable to get kclk\n");
 	dcmipp->kclk = kclk;
 
+	if (!of_device_is_compatible(pdev->dev.of_node, "st,stm32mp13-dcmipp")) {
+		mclk = devm_clk_get(&pdev->dev, "mclk");
+		if (IS_ERR(mclk))
+			return dev_err_probe(&pdev->dev, PTR_ERR(mclk),
+					     "Unable to get mclk\n");
+		dcmipp->mclk = mclk;
+	}
+
 	/* Create platform_device for each entity in the topology */
 	dcmipp->subdevs = devm_kcalloc(&pdev->dev, dcmipp->pipe_cfg->num_ents,
 				       sizeof(*dcmipp->subdevs), GFP_KERNEL);
@@ -620,6 +740,7 @@ static __maybe_unused int dcmipp_runtime
 	struct dcmipp_device *dcmipp = dev_get_drvdata(dev);
 
 	clk_disable_unprepare(dcmipp->kclk);
+	clk_disable_unprepare(dcmipp->mclk);
 
 	return 0;
 }
@@ -629,6 +750,10 @@ static __maybe_unused int dcmipp_runtime
 	struct dcmipp_device *dcmipp = dev_get_drvdata(dev);
 	int ret;
 
+	ret = clk_prepare_enable(dcmipp->mclk);
+	if (ret)
+		dev_err(dev, "%s: Failed to prepare_enable clock\n", __func__);
+
 	ret = clk_prepare_enable(dcmipp->kclk);
 	if (ret)
 		dev_err(dev, "%s: Failed to prepare_enable k clock\n", __func__);
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp.c
@@ -0,0 +1,1009 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/mipi-csi2.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-rect.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+#include "dcmipp-colorconv.h"
+
+#define DCMIPP_ISP_DRV_NAME "dcmipp-isp"
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_P1FSCR (0x804)
+#define DCMIPP_P1FSCR_DTIDA_MASK GENMASK(5, 0)
+#define DCMIPP_P1FSCR_DTIDA_SHIFT 0
+#define DCMIPP_P1FSCR_PIPEDIFF BIT(18)
+#define DCMIPP_P1SRCR (0x820)
+#define DCMIPP_P1SRCR_LASTLINE_SHIFT 0
+#define DCMIPP_P1SRCR_LASTLINE_MASK GENMASK(11, 0)
+#define DCMIPP_P1SRCR_FIRSTLINEDEL_SHIFT 12
+#define DCMIPP_P1SRCR_FIRSTLINEDEL_MASK GENMASK(14, 12)
+#define DCMIPP_P1SRCR_CROPEN BIT(15)
+
+#define DCMIPP_P1BPRCR (0x824)
+#define DCMIPP_P1BPRCR_ENABLE BIT(0)
+#define DCMIPP_P1BPRCR_STRENGTH_SHIFT 1
+#define DCMIPP_P1BPRCR_STRENGTH_MASK GENMASK(3, 1)
+
+#define DCMIPP_P1BPRSR (0x828)
+#define DCMIPP_P1BPRSR_BADCNT_MASK GENMASK(11, 0)
+
+#define DCMIPP_P1DECR (0x830)
+#define DCMIPP_P1DECR_ENABLE BIT(0)
+#define DCMIPP_P1DECR_HDEC_SHIFT 1
+#define DCMIPP_P1DECR_HDEC_MASK GENMASK(2, 1)
+#define DCMIPP_P1DECR_VDEC_SHIFT 3
+#define DCMIPP_P1DECR_VDEC_MASK GENMASK(4, 3)
+
+#define DCMIPP_P1BLCCR (0x840)
+#define DCMIPP_P1BLCCR_ENABLE BIT(0)
+#define DCMIPP_P1BLCCR_BLCB_SHIFT 8
+#define DCMIPP_P1BLCCR_BLCB_MASK GENMASK(15, 8)
+#define DCMIPP_P1BLCCR_BLCG_SHIFT 16
+#define DCMIPP_P1BLCCR_BLCG_MASK GENMASK(23, 16)
+#define DCMIPP_P1BLCCR_BLCR_SHIFT 24
+#define DCMIPP_P1BLCCR_BLCR_MASK GENMASK(31, 24)
+
+#define DCMIPP_P1DMCR (0x870)
+#define DCMIPP_P1DMCR_ENABLE BIT(0)
+#define DCMIPP_P1DMCR_TYPE_SHIFT 1
+#define DCMIPP_P1DMCR_TYPE_MASK GENMASK(2, 1)
+#define DCMIPP_P1DMCR_TYPE_RGGB 0x0
+#define DCMIPP_P1DMCR_TYPE_GRBG 0x1
+#define DCMIPP_P1DMCR_TYPE_GBRG 0x2
+#define DCMIPP_P1DMCR_TYPE_BGGR 0x3
+#define DCMIPP_P1DMCR_PEAK_SHIFT 16
+#define DCMIPP_P1DMCR_PEAK_MASK GENMASK(19, 16)
+#define DCMIPP_P1DMCR_LINEV_SHIFT 20
+#define DCMIPP_P1DMCR_LINEV_MASK GENMASK(23, 20)
+#define DCMIPP_P1DMCR_LINEH_SHIFT 24
+#define DCMIPP_P1DMCR_LINEH_MASK GENMASK(27, 24)
+#define DCMIPP_P1DMCR_EDGE_SHIFT 28
+#define DCMIPP_P1DMCR_EDGE_MASK GENMASK(31, 28)
+
+#define DCMIPP_P1CCCR (0x880)
+#define DCMIPP_P1CCCR_ENABLE BIT(0)
+#define DCMIPP_P1CCCR_TYPE_YUV 0
+#define DCMIPP_P1CCCR_TYPE_RGB BIT(1)
+#define DCMIPP_P1CCCR_CLAMP BIT(2)
+#define DCMIPP_P1CCRR1 (0x884)
+#define DCMIPP_P1CCRR2 (0x888)
+#define DCMIPP_P1CCGR1 (0x88C)
+#define DCMIPP_P1CCGR2 (0x890)
+#define DCMIPP_P1CCBR1 (0x894)
+#define DCMIPP_P1CCBR2 (0x898)
+
+#define DCMIPP_P1CRSZR (0x908)
+#define DCMIPP_P1CRSZR_HSIZE_SHIFT 0
+#define DCMIPP_P1CRSZR_HSIZE_MASK GENMASK(11, 0)
+#define DCMIPP_P1CRSZR_VSIZE_SHIFT 16
+#define DCMIPP_P1CRSZR_VSIZE_MASK GENMASK(27, 16)
+#define DCMIPP_P1CRSZR_ENABLE BIT(31)
+
+#define DCMIPP_P1DSCR (0x910)
+#define DCMIPP_P1DSCR_HDIV_SHIFT 0
+#define DCMIPP_P1DSCR_HDIV_MASK GENMASK(9, 0)
+#define DCMIPP_P1DSCR_VDIV_SHIFT 16
+#define DCMIPP_P1DSCR_VDIV_MASK GENMASK(25, 16)
+#define DCMIPP_P1DSCR_ENABLE BIT(31)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+#define PAD_STR(pad) (IS_SRC((pad))) ? "src" : "sink"
+
+#define ISP_MEDIA_BUS_SINK_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+#define ISP_MEDIA_BUS_SRC_FMT_DEFAULT MEDIA_BUS_FMT_RGB888_1X24
+
+struct dcmipp_isp_pix_map {
+	unsigned int code;
+	unsigned int dt;
+};
+
+#define PIXMAP_MBUS(mbus, datatype) \
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.dt = datatype,		\
+		}
+static const struct dcmipp_isp_pix_map dcmipp_isp_sink_pix_map_list[] = {
+	/* RGB565 */
+	PIXMAP_MBUS(RGB565_2X8_LE, MIPI_CSI2_DT_RGB565),
+	/* YUV422 */
+	PIXMAP_MBUS(YUYV8_2X8, MIPI_CSI2_DT_YUV422_8B),
+	PIXMAP_MBUS(UYVY8_2X8, MIPI_CSI2_DT_YUV422_8B),
+	PIXMAP_MBUS(YVYU8_2X8, MIPI_CSI2_DT_YUV422_8B),
+	PIXMAP_MBUS(VYUY8_2X8, MIPI_CSI2_DT_YUV422_8B),
+	/* GREY */
+	PIXMAP_MBUS(Y8_1X8, 0x00), /* TODO - DT value to be fixed */
+	/* Raw Bayer */
+	/* Raw 8 */
+	PIXMAP_MBUS(SBGGR8_1X8, MIPI_CSI2_DT_RAW8),
+	PIXMAP_MBUS(SGBRG8_1X8, MIPI_CSI2_DT_RAW8),
+	PIXMAP_MBUS(SGRBG8_1X8, MIPI_CSI2_DT_RAW8),
+	PIXMAP_MBUS(SRGGB8_1X8, MIPI_CSI2_DT_RAW8),
+	/* Raw 10 */
+	PIXMAP_MBUS(SBGGR10_1X10, MIPI_CSI2_DT_RAW10),
+	PIXMAP_MBUS(SGBRG10_1X10, MIPI_CSI2_DT_RAW10),
+	PIXMAP_MBUS(SGRBG10_1X10, MIPI_CSI2_DT_RAW10),
+	PIXMAP_MBUS(SRGGB10_1X10, MIPI_CSI2_DT_RAW10),
+	/* Raw 12 */
+	PIXMAP_MBUS(SBGGR12_1X12, MIPI_CSI2_DT_RAW12),
+	PIXMAP_MBUS(SGBRG12_1X12, MIPI_CSI2_DT_RAW12),
+	PIXMAP_MBUS(SGRBG12_1X12, MIPI_CSI2_DT_RAW12),
+	PIXMAP_MBUS(SRGGB12_1X12, MIPI_CSI2_DT_RAW12),
+	/* Raw 14 */
+	PIXMAP_MBUS(SBGGR14_1X14, MIPI_CSI2_DT_RAW14),
+	PIXMAP_MBUS(SGBRG14_1X14, MIPI_CSI2_DT_RAW14),
+	PIXMAP_MBUS(SGRBG14_1X14, MIPI_CSI2_DT_RAW14),
+	PIXMAP_MBUS(SRGGB14_1X14, MIPI_CSI2_DT_RAW14),
+};
+
+static const struct dcmipp_isp_pix_map dcmipp_isp_src_pix_map_list[] = {
+	PIXMAP_MBUS(RGB888_1X24, 0),
+	PIXMAP_MBUS(YUV8_1X24, 0),
+};
+
+static const struct dcmipp_isp_pix_map *
+dcmipp_isp_pix_map_by_index(unsigned int i, unsigned int pad)
+{
+	const struct dcmipp_isp_pix_map *l;
+	unsigned int size;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_isp_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_src_pix_map_list);
+	} else {
+		l = dcmipp_isp_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_sink_pix_map_list);
+	}
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+static const struct dcmipp_isp_pix_map *
+dcmipp_isp_pix_map_by_code(u32 code, unsigned int pad)
+{
+	const struct dcmipp_isp_pix_map *l;
+	unsigned int size;
+	unsigned int i;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_isp_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_src_pix_map_list);
+	} else {
+		l = dcmipp_isp_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_sink_pix_map_list);
+	}
+
+	for (i = 0; i < size; i++) {
+		if (l[i].code == code)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+struct dcmipp_isp_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	struct v4l2_mbus_framefmt sink_fmt;
+	struct v4l2_mbus_framefmt src_fmt;
+	unsigned int decimation;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+	bool streaming;
+	/* Protect this data structure */
+	struct mutex lock;
+
+	void __iomem *regs;
+
+	struct v4l2_ctrl_handler ctrls;
+};
+
+static const struct v4l2_mbus_framefmt fmt_sink_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = ISP_MEDIA_BUS_SINK_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+static const struct v4l2_mbus_framefmt fmt_src_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = ISP_MEDIA_BUS_SRC_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+/*
+ * Functions handling controls
+ */
+#define V4L2_CID_ISP_DEMOSAICING_PEAK	(V4L2_CID_USER_BASE | 0x1001)
+#define V4L2_CID_ISP_DEMOSAICING_LINEH	(V4L2_CID_USER_BASE | 0x1002)
+#define V4L2_CID_ISP_DEMOSAICING_LINEV	(V4L2_CID_USER_BASE | 0x1003)
+#define V4L2_CID_ISP_DEMOSAICING_EDGE	(V4L2_CID_USER_BASE | 0x1004)
+#define V4L2_CID_ISP_BLACKLEVEL		(V4L2_CID_USER_BASE | 0x1005)
+#define V4L2_CID_ISP_BAD_PIXEL		(V4L2_CID_USER_BASE | 0x1006)
+#define V4L2_CID_ISP_BAD_PIXEL_COUNT	(V4L2_CID_USER_BASE | 0x1007)
+
+static int dcmipp_isp_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dcmipp_isp_device *isp =
+			container_of(ctrl->handler, struct dcmipp_isp_device, ctrls);
+
+	if (!isp->streaming)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ISP_DEMOSAICING_PEAK:
+		reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_PEAK_MASK);
+		reg_set(isp, DCMIPP_P1DMCR, ctrl->val << DCMIPP_P1DMCR_PEAK_SHIFT);
+		break;
+	case V4L2_CID_ISP_DEMOSAICING_LINEH:
+		reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_LINEH_MASK);
+		reg_set(isp, DCMIPP_P1DMCR, ctrl->val << DCMIPP_P1DMCR_LINEH_SHIFT);
+		break;
+	case V4L2_CID_ISP_DEMOSAICING_LINEV:
+		reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_LINEV_MASK);
+		reg_set(isp, DCMIPP_P1DMCR, ctrl->val << DCMIPP_P1DMCR_LINEV_SHIFT);
+		break;
+	case V4L2_CID_ISP_DEMOSAICING_EDGE:
+		reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_EDGE_MASK);
+		reg_set(isp, DCMIPP_P1DMCR, ctrl->val << DCMIPP_P1DMCR_EDGE_SHIFT);
+		break;
+	case V4L2_CID_ISP_BLACKLEVEL:
+		reg_write(isp, DCMIPP_P1BLCCR, ctrl->val ?
+			  ((ctrl->val << DCMIPP_P1BLCCR_BLCB_SHIFT) |
+			   (ctrl->val << DCMIPP_P1BLCCR_BLCG_SHIFT) |
+			   (ctrl->val << DCMIPP_P1BLCCR_BLCR_SHIFT) |
+			   DCMIPP_P1BLCCR_ENABLE) : 0);
+		break;
+	case V4L2_CID_ISP_BAD_PIXEL:
+		reg_write(isp, DCMIPP_P1BPRCR, ctrl->val ?
+			   ((ctrl->val - 1) << DCMIPP_P1BPRCR_STRENGTH_SHIFT) |
+			   DCMIPP_P1BPRCR_ENABLE : 0);
+		break;
+	}
+
+	return 0;
+};
+
+static int dcmipp_isp_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dcmipp_isp_device *isp =
+			container_of(ctrl->handler, struct dcmipp_isp_device, ctrls);
+	int ret = 0;
+
+	if (!isp->streaming)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ISP_BAD_PIXEL_COUNT:
+		ctrl->val = reg_read(isp, DCMIPP_P1BPRSR) &
+				     DCMIPP_P1BPRSR_BADCNT_MASK;
+		break;
+	}
+
+	return ret;
+};
+
+static const struct v4l2_ctrl_ops dcmipp_isp_ctrl_ops = {
+	.s_ctrl = dcmipp_isp_s_ctrl,
+};
+
+static const struct v4l2_ctrl_ops dcmipp_isp_get_ctrl_ops = {
+	.g_volatile_ctrl = dcmipp_isp_g_ctrl,
+};
+
+static const struct v4l2_ctrl_config dcmipp_isp_ctrls[] = {
+	{
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_DEMOSAICING_PEAK,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Demosaicing Peak",
+		.min		= 0,
+		.max		= 7,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_DEMOSAICING_LINEH,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Demosaicing Horizontal Line",
+		.min		= 0,
+		.max		= 7,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_DEMOSAICING_LINEV,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Demosaicing Vertical Line",
+		.min		= 0,
+		.max		= 7,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_DEMOSAICING_EDGE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Demosaicing Edge",
+		.min		= 0,
+		.max		= 7,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_BLACKLEVEL,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "BlackLevel (RGB)",
+		.min		= 0,
+		.max		= 255,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_ctrl_ops,
+		.id		= V4L2_CID_ISP_BAD_PIXEL,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Bad Pixel Control",
+		.min		= 0,
+		.max		= 8,
+		.step		= 1,
+		.def		= 0,
+		.flags		= 0,
+	}, {
+		.ops		= &dcmipp_isp_get_ctrl_ops,
+		.id		= V4L2_CID_ISP_BAD_PIXEL_COUNT,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Bad Pixel Count",
+		.min		= 0,
+		.max		= 4095,
+		.step		= 1,
+		.def		= 0,
+		.flags		= V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}
+};
+
+static inline unsigned int dcmipp_isp_compute_decimation(unsigned int orig,
+							 unsigned int req)
+{
+	unsigned int i;
+
+	for (i = 0; i < 4; i++) {
+		if (req >= (orig / (1 << i)))
+			return i;
+	}
+
+	return (i - 1);
+}
+
+static void dcmipp_isp_adjust_fmt(struct v4l2_mbus_framefmt *fmt, u32 pad)
+{
+	const struct dcmipp_isp_pix_map *vpix;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_isp_pix_map_by_code(fmt->code, pad);
+	if (!vpix)
+		fmt->code = IS_SRC(pad) ? fmt_src_default.code :
+					  fmt_sink_default.code;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH) & ~1;
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT);
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = IS_SRC(pad) ? fmt_src_default.field :
+					   fmt_sink_default.field;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_isp_init_cfg(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+
+		mf = v4l2_subdev_get_try_format(sd, state, i);
+		*mf = IS_SRC(i) ? fmt_src_default : fmt_sink_default;
+	}
+
+	return 0;
+}
+
+static int dcmipp_isp_enum_mbus_code(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *state,
+				     struct v4l2_subdev_mbus_code_enum *code)
+{
+	const struct dcmipp_isp_pix_map *vpix;
+
+	vpix = dcmipp_isp_pix_map_by_index(code->index, code->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	code->code = vpix->code;
+
+	return 0;
+}
+
+static int dcmipp_isp_enum_frame_size(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_state *state,
+				      struct v4l2_subdev_frame_size_enum *fse)
+{
+	const struct dcmipp_isp_pix_map *vpix;
+
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_isp_pix_map_by_code(fse->code, fse->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_isp_get_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&isp->lock);
+
+	if (IS_SINK(fmt->pad))
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, 0) :
+			      isp->sink_fmt;
+	else
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, 0) :
+			      isp->src_fmt;
+
+	mutex_unlock(&isp->lock);
+
+	return 0;
+}
+
+#define dcmipp_isp_is_yuv_fmt(a) ({					      \
+	typeof(a) __a = (a);						      \
+	((__a) >= MEDIA_BUS_FMT_Y8_1X8 && (__a) < MEDIA_BUS_FMT_SBGGR8_1X8) ? \
+	 true : false; })
+static int dcmipp_isp_set_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *pad_fmt;
+	int ret = 0;
+
+	mutex_lock(&isp->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		if (isp->streaming) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		if (IS_SINK(fmt->pad))
+			pad_fmt = &isp->sink_fmt;
+		else
+			pad_fmt = &isp->src_fmt;
+
+	} else {
+		pad_fmt = v4l2_subdev_get_try_format(sd, state, 0);
+	}
+
+	dcmipp_isp_adjust_fmt(&fmt->format, fmt->pad);
+
+	if (IS_SINK(fmt->pad) && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		/* When setting sink format, we have to update the src format */
+		isp->src_fmt = fmt->format;
+		if (dcmipp_isp_is_yuv_fmt(fmt->format.code))
+			isp->src_fmt.code = MEDIA_BUS_FMT_YUV8_1X24;
+		else
+			isp->src_fmt.code = MEDIA_BUS_FMT_RGB888_1X24;
+	}
+	/* TODO - we need to update the try src format as well */
+
+	dev_dbg(isp->dev, "%s: %s format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		isp->sd.name,
+		PAD_STR(fmt->pad),
+		/* old */
+		pad_fmt->width, pad_fmt->height, pad_fmt->code,
+		pad_fmt->colorspace, pad_fmt->quantization,
+		pad_fmt->xfer_func, pad_fmt->ycbcr_enc,
+		/* new */
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.colorspace, fmt->format.quantization,
+		fmt->format.xfer_func, fmt->format.ycbcr_enc);
+
+	*pad_fmt = fmt->format;
+
+	/* Update sink pad crop */
+	if (IS_SINK(fmt->pad) && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		isp->crop.top = 0;
+		isp->crop.left = 0;
+		isp->crop.width = fmt->format.width;
+		isp->crop.height = fmt->format.height;
+
+		isp->compose.top = 0;
+		isp->compose.left = 0;
+		isp->compose.width = fmt->format.width;
+		isp->compose.height = fmt->format.height;
+		isp->decimation = 0;
+	}
+
+out:
+	mutex_unlock(&isp->lock);
+
+	return ret;
+}
+
+static struct v4l2_rect
+dcmipp_isp_get_crop_bound(const struct v4l2_mbus_framefmt *fmt)
+{
+	/* Get the crop bounds to clamp the crop rectangle correctly */
+	struct v4l2_rect r = {
+		.left = 0,
+		.top = 0,
+		.width = fmt->width,
+		.height = fmt->height,
+	};
+	return r;
+}
+
+static void dcmipp_isp_adjust_crop(struct v4l2_rect *r,
+				   const struct v4l2_mbus_framefmt *fmt,
+				   unsigned int fmt_width)
+{
+	const struct v4l2_rect src_rect =
+		dcmipp_isp_get_crop_bound(fmt);
+	static struct v4l2_rect crop_min = {
+		.width = DCMIPP_FMT_WIDTH_DEFAULT,
+		.height = 1,
+		.top = 8,
+		.left = 0,
+	};
+
+	/* Disallow rectangles smaller than the minimal one. */
+	crop_min.width = fmt_width;
+	v4l2_rect_set_min_size(r, &crop_min);
+	v4l2_rect_map_inside(r, &src_rect);
+}
+
+static int dcmipp_isp_get_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &isp->sink_fmt;
+		crop = &isp->crop;
+		compose = &isp->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		s->r = *crop;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		s->r = dcmipp_isp_get_crop_bound(sink_fmt);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r = *compose;
+		break;
+	/* TODO - not sure how to define BOUND here */
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dcmipp_isp_set_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+	unsigned int dec;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &isp->sink_fmt;
+		crop = &isp->crop;
+		compose = &isp->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		dcmipp_isp_adjust_crop(&s->r, sink_fmt, isp->sink_fmt.width);
+
+		*crop = s->r;
+
+		/* When we set the crop, this impact as well the compose */
+		*compose = s->r;
+		isp->decimation = 0;
+
+		/*
+		 * In case of setting the crop with ACTIVE set, we need to
+		 * update the source pad size
+		 */
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->src_fmt.width = s->r.width;
+			isp->src_fmt.height = s->r.height;
+		}
+
+		/* TODO - when not in format active, we should also update the
+		 * try src pad format
+		 */
+
+		dev_dbg(isp->dev, "s_selection: crop %ux%u@(%u,%u)\n",
+			crop->width, crop->height, crop->left, crop->top);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r.top = 0;
+		s->r.left = 0;
+		if (s->r.width > crop->width)
+			s->r.width = crop->width;
+		if (s->r.height > crop->height)
+			s->r.height = crop->height;
+		dec = dcmipp_isp_compute_decimation(crop->width, s->r.width);
+		s->r.width = crop->width / (1 << dec);
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->decimation = 0;
+			isp->decimation |= (dec << DCMIPP_P1DECR_HDEC_SHIFT);
+		}
+		dec = dcmipp_isp_compute_decimation(crop->height, s->r.height);
+		s->r.height = crop->height / (1 << dec);
+		if (crop->height % (1 << dec))
+			s->r.height += 1;
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->decimation |= (dec << DCMIPP_P1DECR_VDEC_SHIFT);
+			if (isp->decimation)
+				isp->decimation |= DCMIPP_P1DECR_ENABLE;
+		}
+
+		*compose = s->r;
+
+		/*
+		 * In case of setting the compose with ACTIVE set, we need to
+		 * update the source pad size
+		 */
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->src_fmt.width = s->r.width;
+			isp->src_fmt.height = s->r.height;
+		}
+		/* TODO - when not in format active, we should also update the
+		 * try src pad format
+		 */
+
+		dev_dbg(isp->dev, "s_selection: compose %ux%u@(%u,%u)\n",
+			s->r.width, s->r.height, s->r.left, s->r.top);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_isp_pad_ops = {
+	.init_cfg		= dcmipp_isp_init_cfg,
+	.enum_mbus_code		= dcmipp_isp_enum_mbus_code,
+	.enum_frame_size	= dcmipp_isp_enum_frame_size,
+	.get_fmt		= dcmipp_isp_get_fmt,
+	.set_fmt		= dcmipp_isp_set_fmt,
+	.get_selection		= dcmipp_isp_get_selection,
+	.set_selection		= dcmipp_isp_set_selection,
+};
+
+static void dcmipp_isp_config_demosaicing(struct dcmipp_isp_device *isp)
+{
+	const struct dcmipp_isp_pix_map *vpix =
+		dcmipp_isp_pix_map_by_code(isp->sink_fmt.code, 0);
+	unsigned int val = 0;
+
+	/* Disable demosaicing */
+	reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_ENABLE | DCMIPP_P1DMCR_TYPE_MASK);
+
+	if (vpix->code >= 0x3000 && vpix->code < 0x4000) {
+		dev_info(isp->dev, "Input is RawBayer, enable Demosaicing\n");
+
+		if (vpix->code == MEDIA_BUS_FMT_SBGGR8_1X8 ||
+		    vpix->code == MEDIA_BUS_FMT_SBGGR10_1X10 ||
+		    vpix->code == MEDIA_BUS_FMT_SBGGR12_1X12 ||
+		    vpix->code == MEDIA_BUS_FMT_SBGGR14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_BGGR << DCMIPP_P1DMCR_TYPE_SHIFT;
+		else if (vpix->code == MEDIA_BUS_FMT_SGBRG8_1X8 ||
+			 vpix->code == MEDIA_BUS_FMT_SGBRG10_1X10 ||
+			 vpix->code == MEDIA_BUS_FMT_SGBRG12_1X12 ||
+			 vpix->code == MEDIA_BUS_FMT_SGBRG14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_GBRG << DCMIPP_P1DMCR_TYPE_SHIFT;
+		else if (vpix->code == MEDIA_BUS_FMT_SGRBG8_1X8 ||
+			 vpix->code == MEDIA_BUS_FMT_SGRBG10_1X10 ||
+			 vpix->code == MEDIA_BUS_FMT_SGRBG12_1X12 ||
+			 vpix->code == MEDIA_BUS_FMT_SGRBG14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_GRBG << DCMIPP_P1DMCR_TYPE_SHIFT;
+		else if (vpix->code == MEDIA_BUS_FMT_SRGGB8_1X8 ||
+			 vpix->code == MEDIA_BUS_FMT_SRGGB10_1X10 ||
+			 vpix->code == MEDIA_BUS_FMT_SRGGB12_1X12 ||
+			 vpix->code == MEDIA_BUS_FMT_SRGGB14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_RGGB << DCMIPP_P1DMCR_TYPE_SHIFT;
+
+		val |= DCMIPP_P1DMCR_ENABLE;
+	}
+
+	if (val)
+		reg_set(isp, DCMIPP_P1DMCR, val);
+}
+
+static int dcmipp_isp_colorconv_config(struct dcmipp_isp_device *isp)
+{
+	struct dcmipp_colorconv_config ccconf = { 0 };
+	int i, ret = 0;
+	unsigned int val = 0;
+
+	ret = dcmipp_colorconv_configure(isp->dev, &isp->sink_fmt,
+					 &isp->src_fmt, &ccconf);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < 6; i++)
+		reg_write(isp, DCMIPP_P1CCRR1 + (4 * i), ccconf.conv_matrix[i]);
+
+	if (ccconf.clamping)
+		val |= DCMIPP_P1CCCR_CLAMP;
+	if (!dcmipp_isp_is_yuv_fmt(isp->src_fmt.code))
+		val |= DCMIPP_P1CCCR_TYPE_RGB;
+	if (ccconf.enable)
+		val |= DCMIPP_P1CCCR_ENABLE;
+
+	reg_write(isp, DCMIPP_P1CCCR, val);
+
+	return 0;
+}
+
+static int dcmipp_isp_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	const struct dcmipp_isp_pix_map *vpix =
+		dcmipp_isp_pix_map_by_code(isp->sink_fmt.code, 0);
+	int ret = 0;
+
+	mutex_lock(&isp->lock);
+	if (enable) {
+		/* Configure CSI DataType */
+		reg_clear(isp, DCMIPP_P1FSCR, DCMIPP_P1FSCR_DTIDA_MASK);
+		reg_set(isp, DCMIPP_P1FSCR,
+			vpix->dt << DCMIPP_P1FSCR_DTIDA_SHIFT);
+
+		/* Check if link between ISP & Pipe2 postproc is enabled */
+		if (media_pad_remote_pad_first(&sd->entity.pads[2]))
+			reg_clear(isp, DCMIPP_P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
+		else
+			reg_set(isp, DCMIPP_P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
+
+		/* Configure Statistic Removal */
+		reg_write(isp, DCMIPP_P1SRCR,
+			  ((isp->crop.top << DCMIPP_P1SRCR_FIRSTLINEDEL_SHIFT) |
+			   (isp->crop.height << DCMIPP_P1SRCR_LASTLINE_SHIFT) |
+			   DCMIPP_P1SRCR_CROPEN));
+
+		/* Configure Decimation */
+		reg_write(isp, DCMIPP_P1DECR, isp->decimation);
+
+		/* Configure Exposure */
+		/* Configure Demosaicing */
+		dcmipp_isp_config_demosaicing(isp);
+
+		/* Configure ColorConversion */
+		ret = dcmipp_isp_colorconv_config(isp);
+		if (ret)
+			goto out;
+	}
+
+	isp->streaming = enable;
+
+	mutex_unlock(&isp->lock);
+
+	return v4l2_ctrl_handler_setup(&isp->ctrls);
+
+out:
+	mutex_unlock(&isp->lock);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops dcmipp_isp_video_ops = {
+	.s_stream = dcmipp_isp_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_isp_ops = {
+	.pad = &dcmipp_isp_pad_ops,
+	.video = &dcmipp_isp_video_ops,
+};
+
+/* FIXME */
+static void dcmipp_isp_release(struct v4l2_subdev *sd)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+
+	kfree(isp);
+}
+
+static const struct v4l2_subdev_internal_ops dcmipp_isp_int_ops = {
+	.release = dcmipp_isp_release,
+};
+
+static void dcmipp_isp_comp_unbind(struct device *comp, struct device *master,
+				   void *master_data)
+{
+	struct dcmipp_ent_device *ved = dev_get_drvdata(comp);
+	struct dcmipp_isp_device *isp =
+			container_of(ved, struct dcmipp_isp_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &isp->sd);
+}
+
+static int dcmipp_isp_comp_bind(struct device *comp, struct device *master,
+				void *master_data)
+{
+	struct dcmipp_bind_data *bind_data = master_data;
+	struct dcmipp_platform_data *pdata = comp->platform_data;
+	struct dcmipp_isp_device *isp;
+	int ret, i;
+
+	/* Allocate the isp struct */
+	isp = kzalloc(sizeof(*isp), GFP_KERNEL);
+	if (!isp)
+		return -ENOMEM;
+
+	isp->regs = bind_data->regs;
+
+	/* Initialize the lock */
+	mutex_init(&isp->lock);
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register(&isp->ved, &isp->sd,
+				     bind_data->v4l2_dev,
+				     pdata->entity_name,
+				     MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER, 3,
+				     (const unsigned long[3]) {
+				     MEDIA_PAD_FL_SINK,
+				     MEDIA_PAD_FL_SOURCE,
+				     MEDIA_PAD_FL_SOURCE,
+				     },
+				     &dcmipp_isp_int_ops, &dcmipp_isp_ops,
+				     NULL, NULL);
+	if (ret) {
+		kfree(isp);
+		return ret;
+	}
+
+	dev_set_drvdata(comp, &isp->ved);
+	isp->dev = comp;
+
+	/* Initialize the frame format */
+	isp->sink_fmt = fmt_sink_default;
+	isp->src_fmt = fmt_src_default;
+
+	/* Initialize controls */
+	v4l2_ctrl_handler_init(&isp->ctrls, ARRAY_SIZE(dcmipp_isp_ctrls));
+	isp->ctrls.lock = &isp->lock;
+
+	for (i = 0; i < ARRAY_SIZE(dcmipp_isp_ctrls); i++)
+		v4l2_ctrl_new_custom(&isp->ctrls, &dcmipp_isp_ctrls[i], NULL);
+
+	isp->sd.ctrl_handler = &isp->ctrls;
+	if (isp->ctrls.error) {
+		dev_err(isp->dev, "control initialization error %d\n",
+			isp->ctrls.error);
+		/* TODO - error handling */
+	}
+
+	ret = v4l2_ctrl_handler_setup(&isp->ctrls);
+	if (ret < 0) {
+		dev_err(isp->dev, "Failed to set up control handlers\n");
+		/* TODO - error handling */
+	}
+
+	return 0;
+}
+
+static const struct component_ops dcmipp_isp_comp_ops = {
+	.bind = dcmipp_isp_comp_bind,
+	.unbind = dcmipp_isp_comp_unbind,
+};
+
+static int dcmipp_isp_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dcmipp_isp_comp_ops);
+}
+
+static int dcmipp_isp_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dcmipp_isp_comp_ops);
+
+	return 0;
+}
+
+static const struct platform_device_id dcmipp_isp_driver_ids[] = {
+	{
+		.name           = DCMIPP_ISP_DRV_NAME,
+	},
+	{ }
+};
+
+static struct platform_driver dcmipp_isp_pdrv = {
+	.probe		= dcmipp_isp_probe,
+	.remove		= dcmipp_isp_remove,
+	.id_table	= dcmipp_isp_driver_ids,
+	.driver		= {
+		.name	= DCMIPP_ISP_DRV_NAME,
+	},
+};
+
+module_platform_driver(dcmipp_isp_pdrv);
+
+MODULE_DEVICE_TABLE(platform, dcmipp_isp_driver_ids);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelcap.c
@@ -0,0 +1,1277 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mc.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_PIXELCAP_DRV_NAME "dcmipp-pixelcap"
+
+#define DCMIPP_PRSR (0x1F8)
+/* TODO - CMIER configuration should be done in a common place since it is
+ * common to all pipes and thus should be in core with a dedicated mutex
+ */
+#define DCMIPP_CMIER (0x3F0)
+#define DCMIPP_CMIER_P1FRAMEIE BIT(17)
+#define DCMIPP_CMIER_P1VSYNCIE BIT(18)
+#define DCMIPP_CMIER_P1OVRIE BIT(23)
+#define DCMIPP_CMIER_P2FRAMEIE BIT(25)
+#define DCMIPP_CMIER_P2VSYNCIE BIT(26)
+#define DCMIPP_CMIER_P2OVRIE BIT(31)
+#define DCMIPP_CMIER_PxALL(id) (((id) == 1) ? (DCMIPP_CMIER_P1VSYNCIE |\
+					       DCMIPP_CMIER_P1FRAMEIE |\
+					       DCMIPP_CMIER_P1OVRIE) :\
+					      (DCMIPP_CMIER_P2VSYNCIE |\
+					       DCMIPP_CMIER_P2FRAMEIE |\
+					       DCMIPP_CMIER_P2OVRIE))
+#define DCMIPP_CMSR1 (0x3F4)
+#define DCMIPP_CMSR2 (0x3F8)
+#define DCMIPP_CMSR2_P1FRAMEF BIT(17)
+#define DCMIPP_CMSR2_P1VSYNCF BIT(18)
+#define DCMIPP_CMSR2_P1OVRF BIT(23)
+#define DCMIPP_CMSR2_P2FRAMEF BIT(25)
+#define DCMIPP_CMSR2_P2VSYNCF BIT(26)
+#define DCMIPP_CMSR2_P2OVRF BIT(31)
+#define DCMIPP_CMSR2_PxFRAMEF(id) (((id) == 1) ? DCMIPP_CMSR2_P1FRAMEF :\
+						 DCMIPP_CMSR2_P2FRAMEF)
+#define DCMIPP_CMSR2_PxVSYNCF(id) (((id) == 1) ? DCMIPP_CMSR2_P1VSYNCF :\
+						 DCMIPP_CMSR2_P2VSYNCF)
+#define DCMIPP_CMSR2_PxOVRF(id) (((id) == 1) ? DCMIPP_CMSR2_P1OVRF :\
+					       DCMIPP_CMSR2_P2OVRF)
+#define DCMIPP_CMFCR (0x3FC)
+#define DCMIPP_P1FSCR (0x804)
+#define DCMIPP_P2FSCR (0xC04)
+#define DCMIPP_PxFSCR(id) (((id) == 1) ? DCMIPP_P1FSCR :\
+					 DCMIPP_P2FSCR)
+#define DCMIPP_PxFSCR_PIPEN BIT(31)
+#define DCMIPP_P1FCTCR (0x900)
+#define DCMIPP_P2FCTCR (0xD00)
+#define DCMIPP_PxFCTCR(id) (((id) == 1) ? DCMIPP_P1FCTCR :\
+					  DCMIPP_P2FCTCR)
+#define DCMIPP_PxFCTCR_CPTMODE BIT(2)
+#define DCMIPP_PxFCTCR_CPTREQ BIT(3)
+#define DCMIPP_P1PPM0AR1 (0x9C4)
+#define DCMIPP_P2PPM0AR1 (0xDC4)
+#define DCMIPP_PxPPM0AR1(id) (((id) == 1) ? DCMIPP_P1PPM0AR1 :\
+					    DCMIPP_P2PPM0AR1)
+#define DCMIPP_P1PPM0PR (0x9CC)
+#define DCMIPP_P2PPM0PR (0xDCC)
+#define DCMIPP_PxPPM0PR(id) (((id) == 1) ? DCMIPP_P1PPM0PR :\
+					   DCMIPP_P2PPM0PR)
+#define DCMIPP_P1PPM1AR1 (0x9D4)
+#define DCMIPP_P1PPM1PR (0x9DC)
+#define DCMIPP_P1PPM2AR1 (0x9E4)
+
+#define DCMIPP_P1SR (0x9F8)
+#define DCMIPP_P2SR (0xDF8)
+#define DCMIPP_PxSR(id) (((id) == 1) ? DCMIPP_P1SR :\
+				       DCMIPP_P2SR)
+#define DCMIPP_PxSR_CPTACT BIT(23)
+
+struct dcmipp_pixelcap_pix_map {
+	unsigned int code;
+	u32 pixelformat;
+	u32 plane_nb;
+};
+
+#define PIXMAP_MBUS_PFMT(mbus, fmt, nb_plane)			\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.pixelformat = V4L2_PIX_FMT_##fmt,	\
+			.plane_nb = nb_plane,			\
+		}
+
+static const struct dcmipp_pixelcap_pix_map dcmipp_pixelcap_pix_map_list[] = {
+	/* Coplanar formats are supported on main & aux pipe */
+	PIXMAP_MBUS_PFMT(RGB565_2X8_LE, RGB565, 1),
+	PIXMAP_MBUS_PFMT(YUYV8_2X8, YUYV, 1),
+	PIXMAP_MBUS_PFMT(YVYU8_2X8, YVYU, 1),
+	PIXMAP_MBUS_PFMT(UYVY8_2X8, UYVY, 1),
+	PIXMAP_MBUS_PFMT(VYUY8_2X8, VYUY, 1),
+	PIXMAP_MBUS_PFMT(Y8_1X8, GREY, 1),
+	PIXMAP_MBUS_PFMT(RGB888_1X24, RGB24, 1),
+	PIXMAP_MBUS_PFMT(ARGB8888_1X32, ARGB32, 1),
+	PIXMAP_MBUS_PFMT(AYUV8_1X32, AYUV32, 1),
+
+	/* Semiplanar & planar formats (plane_nb > 1) are only supported on main pipe */
+	PIXMAP_MBUS_PFMT(YUYV8_1_5X8, NV12, 2),   /* FIXME no mbus code for NV12 */
+	PIXMAP_MBUS_PFMT(YVYU8_1_5X8, NV21, 2),   /* FIXME no mbus code for NV21 */
+	PIXMAP_MBUS_PFMT(YUYV8_1X16, NV16, 2),    /* FIXME no mbus code for NV16 */
+	PIXMAP_MBUS_PFMT(YVYU8_1X16, NV61, 2),    /* FIXME no mbus code for NV61 */
+	PIXMAP_MBUS_PFMT(UYVY8_1_5X8, YUV420, 3), /* FIXME no mbus code for YUV420 */
+	PIXMAP_MBUS_PFMT(VYUY8_1_5X8, YVU420, 3), /* FIXME no mbus code for YVU420 */
+};
+
+static const struct dcmipp_pixelcap_pix_map *dcmipp_pixelcap_pix_map_by_pixelformat
+						(u32 pixelformat)
+{
+	const struct dcmipp_pixelcap_pix_map *l = dcmipp_pixelcap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_pixelcap_pix_map_list);
+	unsigned int i;
+
+	for (i = 0; i < size; i++) {
+		if (l[i].pixelformat == pixelformat)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+static const struct dcmipp_pixelcap_pix_map *dcmipp_pixelcap_pix_map_by_index(unsigned int i)
+{
+	const struct dcmipp_pixelcap_pix_map *l = dcmipp_pixelcap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_pixelcap_pix_map_list);
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+struct dcmipp_buf {
+	struct vb2_v4l2_buffer	vb;
+	bool			prepared;
+	dma_addr_t		paddr;
+	size_t			size;
+	dma_addr_t		paddrs[3];
+	u32			strides[3];
+	u64			sizes[3];
+	struct list_head	list;
+};
+
+enum state {
+	STOPPED = 0,
+	WAIT_FOR_BUFFER,
+	RUNNING,
+};
+
+struct dcmipp_pixelcap_device {
+	struct dcmipp_ent_device ved;
+	struct video_device vdev;
+	struct device *dev;
+	struct device *cdev;
+	struct v4l2_pix_format format;
+	struct vb2_queue queue;
+	struct list_head buffers;
+	/* Protects the access of variables shared within the interrupt */
+	spinlock_t irqlock;
+	/* Protect this data structure */
+	struct mutex lock;
+	u32 sequence;
+	struct media_pipeline pipe;
+
+	enum state state;
+
+	struct dcmipp_buf *active;
+
+	void __iomem *regs;
+	struct reset_control *rstc;
+
+	u32 pipe_id;
+
+	u32 cmier;
+	u32 cmsr2;
+
+	int errors_count;
+	int overrun_count;
+	int buffers_count;
+	int vsync_count;
+	int frame_count;
+	int it_count;
+};
+
+static const struct v4l2_pix_format fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.pixelformat = V4L2_PIX_FMT_RGB565,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+struct dcmipp_pixelcap_buffer {
+	/*
+	 * struct vb2_v4l2_buffer must be the first element
+	 * the videobuf2 framework will allocate this struct based on
+	 * buf_struct_size and use the first sizeof(struct vb2_buffer) bytes of
+	 * memory as a vb2_buffer
+	 */
+	struct vb2_v4l2_buffer vb2;
+	struct list_head list;
+};
+
+static inline int frame_size(u32 width, u32 height, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+		return (width * height * 3) / 2;
+	case V4L2_PIX_FMT_GREY:
+		return (width * height);
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+		return (width * height * 2);
+	case V4L2_PIX_FMT_RGB24:
+		return (width * height * 3);
+	case V4L2_PIX_FMT_ARGB32:
+		return (width * height * 4);
+	default:
+		return 0;
+	}
+}
+
+static inline int frame_stride(u32 width, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+	case V4L2_PIX_FMT_GREY:
+		return width;
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+		return (width * 2);
+	case V4L2_PIX_FMT_RGB24:
+		return (width * 3);
+	case V4L2_PIX_FMT_ARGB32:
+		return (width * 4);
+	default:
+		return 0;
+	}
+}
+
+static inline int hdw_pixel_alignment(u32 format)
+{
+	/* 16 bytes alignment required by hardware */
+	switch (format) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+	case V4L2_PIX_FMT_GREY:
+		return 4;/* 2^4 = 16 pixels = 16 bytes */
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+	case V4L2_PIX_FMT_RGB24:
+		return 3;/* 2^3  = 8 pixels = 16 bytes */
+	case V4L2_PIX_FMT_ARGB32:
+		return 2;/* 2^2  = 4 pixels = 16 bytes */
+	default:
+		return 0;
+	}
+}
+
+static inline int frame_planes(dma_addr_t base_addr, dma_addr_t addrs[],
+			       u32 strides[], u64 sizes[],
+			       u32 width, u32 height, u32 format)
+{
+	switch (format) {
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+		addrs[0] = base_addr;
+		strides[0] = width * 2;
+		sizes[0] = strides[0] * height;
+		return 0;
+	case V4L2_PIX_FMT_RGB24:
+		addrs[0] = base_addr;
+		strides[0] = width * 3;
+		sizes[0] = strides[0] * height;
+		return 0;
+	case V4L2_PIX_FMT_ARGB32:
+		addrs[0] = base_addr;
+		strides[0] = width * 4;
+		sizes[0] = strides[0] * height;
+		return 0;
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+		addrs[0] = base_addr;
+		strides[0] = width;
+		sizes[0] = width * height;
+		addrs[1] = addrs[0] + sizes[0];
+		strides[1] = strides[0];
+		sizes[1] = width * height / 2;
+		return 0;
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+		addrs[0] = base_addr;
+		strides[0] = width;
+		sizes[0] = strides[0] * height;
+		addrs[1] = addrs[0] + sizes[0];
+		strides[1] = strides[0];
+		sizes[1] = width * height;
+		return 0;
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+		addrs[0] = base_addr;
+		strides[0] = width;
+		sizes[0] = strides[0] * height;
+		addrs[1] = addrs[0] + sizes[0];
+		strides[1] = strides[0] / 2;
+		sizes[1] = width * height / 4;
+		addrs[2] = addrs[1] + sizes[1];
+		strides[2] = strides[0] / 2;
+		sizes[2] = width * height / 4;
+		return 0;
+	default:
+		return -1;
+	}
+}
+
+static int dcmipp_pixelcap_querycap(struct file *file, void *priv,
+				    struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, DCMIPP_PDEV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", DCMIPP_PDEV_NAME);
+
+	return 0;
+}
+
+static void dcmipp_pixelcap_get_format(struct dcmipp_ent_device *ved,
+				       struct v4l2_pix_format *fmt)
+{
+	struct dcmipp_pixelcap_device *vcap =
+		container_of(ved, struct dcmipp_pixelcap_device, ved);
+
+	*fmt = vcap->format;
+}
+
+static int dcmipp_pixelcap_g_fmt_vid_cap(struct file *file, void *priv,
+					 struct v4l2_format *f)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+
+	f->fmt.pix = vcap->format;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_try_fmt_vid_cap(struct file *file, void *priv,
+					   struct v4l2_format *f)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+	struct v4l2_pix_format *format = &f->fmt.pix;
+	const struct dcmipp_pixelcap_pix_map *vpix;
+	u32 in_w, in_h;
+
+	/* Don't accept a pixelformat that is not on the table */
+	vpix = dcmipp_pixelcap_pix_map_by_pixelformat(format->pixelformat);
+	if (!vpix)
+		format->pixelformat = fmt_default.pixelformat;
+
+	/* Semiplanar & planar formats are only supported on main pipe */
+	if (vpix->plane_nb > 1 && vcap->pipe_id != 1)
+		format->pixelformat = fmt_default.pixelformat;
+
+	/* Adjust width & height */
+	in_w = format->width;
+	in_h = format->height;
+	v4l_bound_align_image(&format->width,
+			      DCMIPP_FRAME_MIN_WIDTH, DCMIPP_FRAME_MAX_WIDTH,
+			      hdw_pixel_alignment(format->pixelformat),
+			      &format->height,
+			      DCMIPP_FRAME_MIN_HEIGHT, DCMIPP_FRAME_MAX_HEIGHT,
+			      hdw_pixel_alignment(format->pixelformat),
+			      0);
+	if (format->width != in_w || format->height != in_h)
+		dev_dbg(vcap->dev,
+			"resolution updated: %dx%d -> %dx%d\n",
+			in_w, in_h, format->width, format->height);
+
+	format->bytesperline = frame_stride(format->width, format->pixelformat);
+	format->sizeimage = frame_size(format->width, format->height, format->pixelformat);
+
+	if (format->field == V4L2_FIELD_ANY)
+		format->field = fmt_default.field;
+
+	dcmipp_colorimetry_clamp(format);
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_s_fmt_vid_cap(struct file *file, void *priv,
+					 struct v4l2_format *f)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+	int ret;
+
+	/* Do not change the format while stream is on */
+	if (vb2_is_busy(&vcap->queue))
+		return -EBUSY;
+
+	ret = dcmipp_pixelcap_try_fmt_vid_cap(file, priv, f);
+	if (ret)
+		return ret;
+
+	dev_dbg(vcap->dev, "%s: format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		vcap->vdev.name,
+		/* old */
+		vcap->format.width, vcap->format.height,
+		vcap->format.pixelformat, vcap->format.colorspace,
+		vcap->format.quantization, vcap->format.xfer_func,
+		vcap->format.ycbcr_enc,
+		/* new */
+		f->fmt.pix.width, f->fmt.pix.height,
+		f->fmt.pix.pixelformat, f->fmt.pix.colorspace,
+		f->fmt.pix.quantization, f->fmt.pix.xfer_func,
+		f->fmt.pix.ycbcr_enc);
+
+	vcap->format = f->fmt.pix;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_enum_fmt_vid_cap(struct file *file, void *priv,
+					    struct v4l2_fmtdesc *f)
+{
+	const struct dcmipp_pixelcap_pix_map *vpix = dcmipp_pixelcap_pix_map_by_index(f->index);
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+
+	vpix = dcmipp_pixelcap_pix_map_by_index(f->index);
+	if (!vpix)
+		return -EINVAL;
+
+	/* Semiplanar & planar formats are only supported on main pipe */
+	if (vpix->plane_nb > 1 && vcap->pipe_id != 1)
+		return -EINVAL;
+
+	f->pixelformat = vpix->pixelformat;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_enum_framesizes(struct file *file, void *fh,
+					   struct v4l2_frmsizeenum *fsize)
+{
+	const struct dcmipp_pixelcap_pix_map *vpix;
+
+	if (fsize->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_pixelcap_pix_map_by_pixelformat(fsize->pixel_format);
+	if (!vpix)
+		return -EINVAL;
+
+	/* TODO - need to differentiate here format of MAIN vs AUX */
+
+	fsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+	fsize->stepwise.min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fsize->stepwise.max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fsize->stepwise.min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fsize->stepwise.max_height = DCMIPP_FRAME_MAX_HEIGHT;
+	fsize->stepwise.step_width = 1;
+	fsize->stepwise.step_height = 1;
+
+	return 0;
+}
+
+/* TODO - based on the explanation text, should also use v4l2_pipeline_link_notify */
+static int dcmipp_pixelcap_open(struct file *file)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+	int ret;
+
+	ret = mutex_lock_interruptible(&vcap->lock);
+	if (ret)
+		return ret;
+
+	ret = v4l2_fh_open(file);
+	if (ret)
+		goto err_unlock;
+
+	ret = v4l2_pipeline_pm_get(&vcap->vdev.entity);
+	if (ret)
+		goto err_close;
+
+	mutex_unlock(&vcap->lock);
+
+	return 0;
+
+err_close:
+	v4l2_fh_release(file);
+err_unlock:
+	mutex_unlock(&vcap->lock);
+
+	return ret;
+}
+
+static int dcmipp_pixelcap_close(struct file *file)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+
+	vb2_fop_release(file);
+
+	v4l2_pipeline_pm_put(&vcap->vdev.entity);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations dcmipp_pixelcap_fops = {
+	.owner		= THIS_MODULE,
+	.open		= dcmipp_pixelcap_open,
+	.release	= dcmipp_pixelcap_close,
+	.read           = vb2_fop_read,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap           = vb2_fop_mmap,
+};
+
+static const struct v4l2_ioctl_ops dcmipp_pixelcap_ioctl_ops = {
+	.vidioc_querycap = dcmipp_pixelcap_querycap,
+
+	.vidioc_g_fmt_vid_cap = dcmipp_pixelcap_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap = dcmipp_pixelcap_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap = dcmipp_pixelcap_try_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_cap = dcmipp_pixelcap_enum_fmt_vid_cap,
+	.vidioc_enum_framesizes = dcmipp_pixelcap_enum_framesizes,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+};
+
+static int dcmipp_pipeline_s_stream(struct dcmipp_pixelcap_device *vcap,
+				    int state)
+{
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	int ret;
+
+	/* Start/stop all entities within pipeline */
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_pad_remote_pad_first(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, state);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(vcap->dev, "%s: \"%s\" failed to %s streaming (%d)\n",
+				__func__, subdev->name,
+				state ? "start" : "stop", ret);
+
+			return ret;
+		}
+
+		dev_dbg(vcap->dev, "\"%s\" is %s\n",
+			subdev->name, state ? "started" : "stopped");
+	}
+
+	return 0;
+}
+
+static int dcmipp_start_capture(struct dcmipp_pixelcap_device *vcap,
+				struct dcmipp_buf *buf)
+{
+	/*
+	 * Set frame addresses
+	 * Those registers are taken into account immediately
+	 */
+	if (buf->paddrs[0]) {
+		reg_write(vcap, DCMIPP_PxPPM0AR1(vcap->pipe_id), buf->paddrs[0]);
+		reg_write(vcap, DCMIPP_PxPPM0PR(vcap->pipe_id), buf->strides[0]);
+	}
+
+	if (buf->paddrs[1]) {
+		reg_write(vcap, DCMIPP_P1PPM1AR1, buf->paddrs[1]);
+		reg_write(vcap, DCMIPP_P1PPM1PR, buf->strides[1]);
+	}
+
+	if (buf->paddrs[2])
+		reg_write(vcap, DCMIPP_P1PPM2AR1, buf->paddrs[2]);
+
+	/* Capture request */
+	reg_set(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTREQ);
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_start_streaming(struct vb2_queue *vq,
+					   unsigned int count)
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vq);
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct dcmipp_buf *buf, *node;
+	int ret;
+
+	vcap->sequence = 0;
+	vcap->errors_count = 0;
+	vcap->overrun_count = 0;
+	vcap->buffers_count = 0;
+	vcap->vsync_count = 0;
+	vcap->frame_count = 0;
+	vcap->it_count = 0;
+
+	ret = pm_runtime_get_sync(vcap->cdev);
+	if (ret < 0) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, cannot get sync (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/* Start the media pipeline */
+	ret = media_pipeline_start(entity, &vcap->pipe);
+	if (ret) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, media pipeline start error (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/* Start all the elements within pipeline */
+	ret = dcmipp_pipeline_s_stream(vcap, 1);
+	if (ret)
+		goto err_media_pipeline_stop;
+
+/* TODO - CMIER configuration should be done in a common place since it is
+ * common to all pipes and thus should be in core with a dedicated mutex
+ */
+	/* Enable interruptions */
+	vcap->cmier |= DCMIPP_CMIER_PxALL(vcap->pipe_id);
+	reg_set(vcap, DCMIPP_CMIER, vcap->cmier);
+
+	/* Snapshot mode */
+	reg_set(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTMODE);
+
+	/* Enable pipe at the end of programming */
+	reg_set(vcap, DCMIPP_PxFSCR(vcap->pipe_id), DCMIPP_PxFSCR_PIPEN);
+
+	/*
+	 * Start capture if at least one buffer has been queued,
+	 * otherwise start is deferred at next buffer queueing
+	 */
+	buf = list_first_entry_or_null(&vcap->buffers, typeof(*buf), list);
+	if (!buf) {
+		dev_dbg(vcap->dev, "Start streaming is deferred to next buffer queueing\n");
+		vcap->active = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		return 0;
+	}
+	vcap->active = buf;
+	dev_dbg(vcap->dev, "Start active [%d] %p phy=%pad\n",
+		buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	vcap->state = RUNNING;
+
+	/* Start capture */
+	ret = dcmipp_start_capture(vcap, buf);
+	if (ret)
+		goto err_media_pipeline_stop;
+
+	return 0;
+
+err_media_pipeline_stop:
+	media_pipeline_stop(entity->pads);
+err_pm_put:
+	pm_runtime_put(vcap->cdev);
+	spin_lock_irq(&vcap->irqlock);
+	/*
+	 * Return all buffers to vb2 in QUEUED state.
+	 * This will give ownership back to userspace
+	 */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);
+	}
+	vcap->active = NULL;
+	spin_unlock_irq(&vcap->irqlock);
+
+	return ret;
+}
+
+static void dcmipp_dump_status(struct dcmipp_pixelcap_device *vcap)
+{
+	struct device *dev = vcap->dev;
+
+	dev_dbg(dev, "[DCMIPP_PRSR]  =%#10.8x\n", reg_read(vcap, DCMIPP_PRSR));
+	dev_dbg(dev, "[DCMIPP_PxSR] =%#10.8x\n", reg_read(vcap, DCMIPP_PxSR(vcap->pipe_id)));
+	dev_dbg(dev, "[DCMIPP_CMSR1] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR1));
+	dev_dbg(dev, "[DCMIPP_CMSR2] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR2));
+}
+
+/*
+ * Stop the stream engine. Any remaining buffers in the stream queue are
+ * dequeued and passed on to the vb2 framework marked as STATE_ERROR.
+ */
+static void dcmipp_pixelcap_stop_streaming(struct vb2_queue *vq)
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vq);
+	struct dcmipp_buf *buf, *node;
+	int ret;
+	u32 status;
+
+	dcmipp_pipeline_s_stream(vcap, 0);
+
+	/* Stop the media pipeline */
+	media_pipeline_stop(vcap->vdev.entity.pads);
+
+/* TODO - CMIER configuration should be done in a common place since it is
+ * common to all pipes and thus should be in core with a dedicated mutex
+ */
+
+	/* Disable interruptions */
+	reg_clear(vcap, DCMIPP_CMIER, vcap->cmier);
+
+	/* Stop capture */
+	reg_clear(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTREQ);
+
+	/* Wait until CPTACT become 0 */
+	ret = readl_relaxed_poll_timeout(vcap->regs + DCMIPP_PxSR(vcap->pipe_id),
+					 status,
+					 !(status & DCMIPP_PxSR_CPTACT),
+					 20, 1000);
+	if (ret)
+		dev_warn(vcap->dev, "Timeout when stopping\n");
+
+	/* Disable pipe */
+	reg_clear(vcap, DCMIPP_PxFSCR(vcap->pipe_id), DCMIPP_PxFSCR_PIPEN);
+
+	spin_lock_irq(&vcap->irqlock);
+
+	/* Return all queued buffers to vb2 in ERROR state */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	INIT_LIST_HEAD(&vcap->buffers);
+
+	vcap->active = NULL;
+	vcap->state = STOPPED;
+
+	dcmipp_dump_status(vcap);
+
+	spin_unlock_irq(&vcap->irqlock);
+
+	pm_runtime_put(vcap->cdev);
+
+	if (ret) {
+		/* Reset IP on timeout */
+		if (reset_control_assert(vcap->rstc))
+			dev_warn(vcap->dev, "Failed to assert the reset line\n");
+
+		usleep_range(3000, 5000);
+
+		if (reset_control_deassert(vcap->rstc))
+			dev_warn(vcap->dev, "Failed to deassert the reset line\n");
+	}
+
+	if (vcap->errors_count)
+		dev_warn(vcap->dev, "Some errors found while streaming: errors=%d (overrun=%d), buffers=%d\n",
+			 vcap->errors_count, vcap->overrun_count,
+			 vcap->buffers_count);
+	dev_dbg(vcap->dev, "Stop streaming, errors=%d (overrun=%d), vsync=%d, frame=%d, buffers=%d, it=%d\n",
+		vcap->errors_count, vcap->overrun_count,
+		vcap->vsync_count,
+		vcap->frame_count, vcap->buffers_count,
+		vcap->it_count);
+}
+
+static int dcmipp_pixelcap_buf_prepare(struct vb2_buffer *vb)
+{
+	struct dcmipp_pixelcap_device *vcap =  vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+	struct v4l2_pix_format *format = &vcap->format;
+	unsigned long size;
+	int ret;
+
+	size = format->sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		dev_err(vcap->dev, "%s data will not fit into plane (%lu < %lu)\n",
+			__func__, vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	vb2_set_plane_payload(vb, 0, size);
+
+	if (!buf->prepared) {
+		/* Get memory addresses */
+		buf->paddr =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		buf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);
+
+		ret = frame_planes(buf->paddr,
+				   buf->paddrs, buf->strides, buf->sizes,
+				   format->width, format->height,
+				   format->pixelformat);
+		if (ret) {
+			dev_err(vcap->dev, "%s: Unsupported pixel format (%x)\n",
+				__func__, format->pixelformat);
+			return ret;
+		}
+
+		/* Check for 16 bytes alignment required by hardware */
+		WARN_ON(buf->paddrs[0] & 15);
+		WARN_ON(buf->strides[0] & 15);
+		WARN_ON(buf->paddrs[1] & 15);
+		WARN_ON(buf->strides[1] & 15);
+		WARN_ON(buf->paddrs[2] & 15);
+
+		buf->prepared = true;
+
+		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
+
+		dev_dbg(vcap->dev, "buffer[%d] phy=%pad size=%zu\n",
+			vb->index, &buf->paddr, buf->size);
+	}
+
+	return 0;
+}
+
+static void dcmipp_pixelcap_buf_queue(struct vb2_buffer *vb2_buf)
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vb2_buf->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2_buf);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	spin_lock_irq(&vcap->irqlock);
+	list_add_tail(&buf->list, &vcap->buffers);
+
+	if (vcap->state == WAIT_FOR_BUFFER) {
+		vcap->active = buf;
+		dev_dbg(vcap->dev, "Start active [%d] %p phy=%pad\n",
+			buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+		vcap->state = RUNNING;
+
+		dev_dbg(vcap->dev, "Starting capture on buffer[%d] queued\n",
+			buf->vb.vb2_buf.index);
+
+		spin_unlock_irq(&vcap->irqlock);
+		if (dcmipp_start_capture(vcap, buf))
+			dev_err(vcap->dev, "%s: Cannot restart capture on new buffer\n",
+				__func__);
+		return;
+	}
+
+	spin_unlock_irq(&vcap->irqlock);
+}
+
+static int dcmipp_pixelcap_queue_setup(struct vb2_queue *vq,
+				       unsigned int *nbuffers,
+				       unsigned int *nplanes,
+				       unsigned int sizes[],
+				       struct device *alloc_devs[])
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vq);
+	unsigned int size;
+
+	size = vcap->format.sizeimage;
+
+	/* Make sure the image size is large enough */
+	if (*nplanes)
+		return sizes[0] < vcap->format.sizeimage ? -EINVAL : 0;
+
+	*nplanes = 1;
+	sizes[0] = vcap->format.sizeimage;
+
+	dev_dbg(vcap->dev, "Setup queue, count=%d, size=%d\n",
+		*nbuffers, size);
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	INIT_LIST_HEAD(&buf->list);
+
+	return 0;
+}
+
+static const struct vb2_ops dcmipp_pixelcap_qops = {
+	.start_streaming	= dcmipp_pixelcap_start_streaming,
+	.stop_streaming		= dcmipp_pixelcap_stop_streaming,
+	.buf_init		= dcmipp_pixelcap_buf_init,
+	.buf_prepare		= dcmipp_pixelcap_buf_prepare,
+	.buf_queue		= dcmipp_pixelcap_buf_queue,
+	.queue_setup		= dcmipp_pixelcap_queue_setup,
+	/*
+	 * Since q->lock is set we can use the standard
+	 * vb2_ops_wait_prepare/finish helper functions.
+	 */
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+};
+
+static const struct media_entity_operations dcmipp_pixelcap_mops = {
+	.link_validate		= dcmipp_link_validate,
+};
+
+static void dcmipp_pixelcap_release(struct video_device *vdev)
+{
+	struct dcmipp_pixelcap_device *vcap =
+		container_of(vdev, struct dcmipp_pixelcap_device, vdev);
+
+	dcmipp_pads_cleanup(vcap->ved.pads);
+	kfree(vcap);
+}
+
+static void dcmipp_pixelcap_comp_unbind(struct device *comp,
+					struct device *master,
+					void *master_data)
+{
+	struct dcmipp_ent_device *ved = dev_get_drvdata(comp);
+	struct dcmipp_pixelcap_device *vcap =
+		container_of(ved, struct dcmipp_pixelcap_device, ved);
+
+	media_entity_cleanup(ved->ent);
+	vb2_video_unregister_device(&vcap->vdev);
+}
+
+static void dcmipp_buffer_done(struct dcmipp_pixelcap_device *vcap,
+			       struct dcmipp_buf *buf,
+			       size_t bytesused,
+			       int err)
+{
+	struct vb2_v4l2_buffer *vbuf;
+
+	if (!buf)
+		return;
+
+	list_del_init(&buf->list);
+
+	vbuf = &buf->vb;
+
+	vbuf->sequence = vcap->sequence++;
+	vbuf->field = V4L2_FIELD_NONE;
+	vbuf->vb2_buf.timestamp = ktime_get_ns();
+	vb2_set_plane_payload(&vbuf->vb2_buf, 0, bytesused);
+	vb2_buffer_done(&vbuf->vb2_buf,
+			err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+
+	vcap->buffers_count++;
+	vcap->active = NULL;
+}
+
+/* irqlock must be held */
+static void
+dcmipp_pixelcap_prepare_next_frame(struct dcmipp_pixelcap_device *vcap)
+{
+	struct dcmipp_buf *buf;
+
+	/* Configure address register with next buffer */
+	buf = list_first_entry_or_null(&vcap->buffers, typeof(*buf), list);
+	if (!buf) {
+		dev_dbg(vcap->dev, "Capture restart is deferred to next buffer queueing\n");
+		vcap->active = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		return;
+	}
+	vcap->active = buf;
+
+	/*
+	 * Set frame addresses
+	 * Those registers are shadowed and will be taken into
+	 * account on next VSYNC (start of next frame)
+	 */
+	if (buf->paddrs[0])
+		reg_write(vcap, DCMIPP_PxPPM0AR1(vcap->pipe_id), buf->paddrs[0]);
+
+	if (buf->paddrs[1])
+		reg_write(vcap, DCMIPP_P1PPM1AR1, buf->paddrs[1]);
+
+	if (buf->paddrs[2])
+		reg_write(vcap, DCMIPP_P1PPM2AR1, buf->paddrs[2]);
+
+	/* Capture request */
+	reg_set(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTREQ);
+}
+
+/* irqlock must be held */
+static void dcmipp_pixelcap_process_frame(struct dcmipp_pixelcap_device *vcap)
+{
+	int err = 0;
+	struct dcmipp_buf *buf = vcap->active;
+
+	if (!buf) {
+		dev_dbg(vcap->dev, "skip NULL active frame\n");
+		return;
+	}
+
+	dcmipp_buffer_done(vcap, buf, vcap->format.sizeimage, err);
+
+	dcmipp_pixelcap_prepare_next_frame(vcap);
+}
+
+static irqreturn_t dcmipp_pixelcap_irq_thread(int irq, void *arg)
+{
+	struct dcmipp_pixelcap_device *vcap =
+			container_of(arg, struct dcmipp_pixelcap_device, ved);
+	u32 cmsr2_pxframef;
+	u32 cmsr2_pxvsyncf;
+	u32 cmsr2_pxovrf;
+
+	spin_lock_irq(&vcap->irqlock);
+
+	cmsr2_pxovrf = DCMIPP_CMSR2_PxOVRF(vcap->pipe_id);
+	cmsr2_pxvsyncf = DCMIPP_CMSR2_PxVSYNCF(vcap->pipe_id);
+	cmsr2_pxframef = DCMIPP_CMSR2_PxFRAMEF(vcap->pipe_id);
+
+	if (vcap->cmsr2 & cmsr2_pxovrf) {
+		vcap->overrun_count++;
+		spin_unlock_irq(&vcap->irqlock);
+		return IRQ_HANDLED;
+	}
+
+	if (vcap->cmsr2 & cmsr2_pxframef &&
+	    vcap->cmsr2 & cmsr2_pxvsyncf) {
+		/* If both IT FRAME and VSYNC are received together
+		 * buffers will be corrupted, skip this frame
+		 */
+		vcap->errors_count++;
+		spin_unlock_irq(&vcap->irqlock);
+		return IRQ_HANDLED;
+	}
+
+	if (vcap->cmsr2 & cmsr2_pxframef) {
+		vcap->frame_count++;
+
+		dcmipp_pixelcap_process_frame(vcap);
+	}
+
+	if (vcap->cmsr2 & cmsr2_pxvsyncf)
+		vcap->vsync_count++;
+
+	spin_unlock_irq(&vcap->irqlock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dcmipp_pixelcap_irq_callback(int irq, void *arg)
+{
+	struct dcmipp_pixelcap_device *vcap =
+			container_of(arg, struct dcmipp_pixelcap_device, ved);
+
+	vcap->cmsr2 = reg_read(vcap, DCMIPP_CMSR2);
+	vcap->cmsr2 = vcap->cmsr2 & vcap->cmier;
+
+	vcap->it_count++;
+
+	/* Clear interrupt */
+	reg_write(vcap, DCMIPP_CMFCR, vcap->cmsr2);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static int dcmipp_name_to_pipe_id(const char *name)
+{
+	if (strstr(name, "main"))
+		return 1;
+	else if (strstr(name, "aux"))
+		return 2;
+	else
+		return -EINVAL;
+}
+
+static int dcmipp_pixelcap_comp_bind(struct device *comp, struct device *master,
+				     void *master_data)
+{
+	struct dcmipp_bind_data *bind_data = master_data;
+	struct dcmipp_platform_data *pdata = comp->platform_data;
+	struct dcmipp_pixelcap_device *vcap;
+	struct v4l2_pix_format *format;
+	struct video_device *vdev;
+	struct vb2_queue *q;
+	int ret = 0;
+
+	/* Allocate the dcmipp_cap_device struct */
+	vcap = kzalloc(sizeof(*vcap), GFP_KERNEL);
+	if (!vcap)
+		return -ENOMEM;
+
+	/* Retrieve the pipe_id */
+	vcap->pipe_id = dcmipp_name_to_pipe_id(pdata->entity_name);
+	if (vcap->pipe_id != 1 && vcap->pipe_id != 2) {
+		dev_err(comp, "failed to retrieve pipe_id\n");
+		goto err_free_vcap;
+	}
+	/* Allocate the pads */
+	vcap->ved.pads =
+		dcmipp_pads_init(1, (const unsigned long[1]) {MEDIA_PAD_FL_SINK});
+	if (IS_ERR(vcap->ved.pads)) {
+		ret = PTR_ERR(vcap->ved.pads);
+		goto err_free_vcap;
+	}
+
+	/* Initialize the media entity */
+	vcap->vdev.entity.name = pdata->entity_name;
+	vcap->vdev.entity.function = MEDIA_ENT_F_IO_V4L;
+	ret = media_entity_pads_init(&vcap->vdev.entity,
+				     1, vcap->ved.pads);
+	if (ret)
+		goto err_clean_pads;
+
+	/* Initialize the lock */
+	mutex_init(&vcap->lock);
+
+	/* Initialize the vb2 queue */
+	q = &vcap->queue;
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;
+	q->lock = &vcap->lock;
+	q->drv_priv = vcap;
+	q->buf_struct_size = sizeof(struct dcmipp_buf);
+	q->ops = &dcmipp_pixelcap_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->min_buffers_needed = 1;
+	q->dev = comp;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(comp, "%s: vb2 queue init failed (err=%d)\n",
+			pdata->entity_name, ret);
+		goto err_clean_m_ent;
+	}
+
+	/* Initialize buffer list and its lock */
+	INIT_LIST_HEAD(&vcap->buffers);
+	spin_lock_init(&vcap->irqlock);
+
+	/* Set default frame format */
+	vcap->format = fmt_default;
+	format = &vcap->format;
+	format->bytesperline = frame_stride(format->width, format->pixelformat);
+	format->sizeimage = frame_size(format->width, format->height, format->pixelformat);
+
+	/* Fill the dcmipp_ent_device struct */
+	vcap->ved.ent = &vcap->vdev.entity;
+	vcap->ved.vdev_get_format = dcmipp_pixelcap_get_format;
+	vcap->ved.handler = dcmipp_pixelcap_irq_callback;
+	vcap->ved.thread_fn = dcmipp_pixelcap_irq_thread;
+	dev_set_drvdata(comp, &vcap->ved);
+	vcap->dev = comp;
+	vcap->regs = bind_data->regs;
+	vcap->rstc = bind_data->rstc;
+	vcap->cdev = master;
+
+	/* Initialize the video_device struct */
+	vdev = &vcap->vdev;
+	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |
+			    V4L2_CAP_READWRITE;
+	vdev->entity.ops = &dcmipp_pixelcap_mops;
+	vdev->release = dcmipp_pixelcap_release;
+	vdev->fops = &dcmipp_pixelcap_fops;
+	vdev->ioctl_ops = &dcmipp_pixelcap_ioctl_ops;
+	vdev->lock = &vcap->lock;
+	vdev->queue = q;
+	vdev->v4l2_dev = bind_data->v4l2_dev;
+	strscpy(vdev->name, pdata->entity_name, sizeof(vdev->name));
+	video_set_drvdata(vdev, &vcap->ved);
+
+	/* Register the video_device with the v4l2 and the media framework */
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(comp, "%s: video register failed (err=%d)\n",
+			vcap->vdev.name, ret);
+		goto err_clean_m_ent;
+	}
+
+	return 0;
+
+err_clean_m_ent:
+	media_entity_cleanup(&vcap->vdev.entity);
+err_clean_pads:
+	dcmipp_pads_cleanup(vcap->ved.pads);
+err_free_vcap:
+	kfree(vcap);
+
+	return ret;
+}
+
+static const struct component_ops dcmipp_pixelcap_comp_ops = {
+	.bind = dcmipp_pixelcap_comp_bind,
+	.unbind = dcmipp_pixelcap_comp_unbind,
+};
+
+static int dcmipp_pixelcap_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dcmipp_pixelcap_comp_ops);
+}
+
+static int dcmipp_pixelcap_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dcmipp_pixelcap_comp_ops);
+
+	return 0;
+}
+
+static const struct platform_device_id dcmipp_pixelcap_driver_ids[] = {
+	{
+		.name	= DCMIPP_PIXELCAP_DRV_NAME,
+	},
+	{ }
+};
+
+static struct platform_driver dcmipp_pixelcap_pdrv = {
+	.probe		= dcmipp_pixelcap_probe,
+	.remove		= dcmipp_pixelcap_remove,
+	.id_table	= dcmipp_pixelcap_driver_ids,
+	.driver		= {
+		.name	= DCMIPP_PIXELCAP_DRV_NAME,
+	},
+};
+
+module_platform_driver(dcmipp_pixelcap_pdrv);
+
+MODULE_DEVICE_TABLE(platform, dcmipp_pixelcap_driver_ids);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelproc.c
@@ -0,0 +1,900 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-rect.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+#include "dcmipp-colorconv.h"
+
+#define DCMIPP_PIXELPROC_DRV_NAME "dcmipp-pixelproc"
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_P1FCTCR (0x900)
+#define DCMIPP_P2FCTCR (0xD00)
+#define DCMIPP_PxFCTCR(id) (((id) == 1) ? DCMIPP_P1FCTCR :\
+			   DCMIPP_P2FCTCR)
+#define DCMIPP_PxFCTCR_FRATE_MASK GENMASK(1, 0)
+#define DCMIPP_P1CRSTR (0x904)
+#define DCMIPP_P2CRSTR (0xD04)
+#define DCMIPP_PxCRSTR(id) (((id) == 1) ? DCMIPP_P1CRSTR :\
+			   DCMIPP_P2CRSTR)
+#define DCMIPP_PxCRSTR_HSTART_SHIFT	0
+#define DCMIPP_PxCRSTR_VSTART_SHIFT	16
+#define DCMIPP_P1CRSZR (0x908)
+#define DCMIPP_P2CRSZR (0xD08)
+#define DCMIPP_PxCRSZR(id) (((id) == 1) ? DCMIPP_P1CRSZR :\
+			   DCMIPP_P2CRSZR)
+#define DCMIPP_PxCRSZR_ENABLE BIT(31)
+#define DCMIPP_PxCRSZR_HSIZE_SHIFT	0
+#define DCMIPP_PxCRSZR_VSIZE_SHIFT	16
+
+#define DCMIPP_P1DSCR (0x910)
+#define DCMIPP_P2DSCR (0xD10)
+#define DCMIPP_PxDSCR(id) (((id) == 1) ? DCMIPP_P1DSCR :\
+			   DCMIPP_P2DSCR)
+#define DCMIPP_PxDSCR_HDIV_SHIFT 0
+#define DCMIPP_PxDSCR_HDIV_MASK GENMASK(9, 0)
+#define DCMIPP_PxDSCR_VDIV_SHIFT 16
+#define DCMIPP_PxDSCR_VDIV_MASK GENMASK(25, 16)
+#define DCMIPP_PxDSCR_ENABLE BIT(31)
+
+#define DCMIPP_P1DSRTIOR (0x914)
+#define DCMIPP_P2DSRTIOR (0xD14)
+#define DCMIPP_PxDSRTIOR(id) (((id) == 1) ? DCMIPP_P1DSRTIOR :\
+			   DCMIPP_P2DSRTIOR)
+#define DCMIPP_PxDSRTIOR_HRATIO_SHIFT 0
+#define DCMIPP_PxDSRTIOR_HRATIO_MASK GENMASK(15, 0)
+#define DCMIPP_PxDSRTIOR_VRATIO_SHIFT 16
+#define DCMIPP_PxDSRTIOR_VRATIO_MASK GENMASK(31, 16)
+
+#define DCMIPP_P1DSSZR (0x918)
+#define DCMIPP_P2DSSZR (0xD18)
+#define DCMIPP_PxDSSZR(id) (((id) == 1) ? DCMIPP_P1DSSZR :\
+			   DCMIPP_P2DSSZR)
+#define DCMIPP_PxDSSZR_HSIZE_SHIFT 0
+#define DCMIPP_PxDSSZR_HSIZE_MASK GENMASK(11, 0)
+#define DCMIPP_PxDSSZR_VSIZE_SHIFT 16
+#define DCMIPP_PxDSSZR_VSIZE_MASK GENMASK(27, 16)
+
+#define DCMIPP_P1GMCR (0x970)
+#define DCMIPP_P2GMCR (0x970)
+#define DCMIPP_PxGMCR(id) (((id) == 1) ? DCMIPP_P1GMCR :\
+			   DCMIPP_P2GMCR)
+#define DCMIPP_PxGMCR_ENABLE BIT(0)
+
+#define DCMIPP_P1YUVCR (0x980)
+#define DCMIPP_P1YUVCR_ENABLE BIT(0)
+#define DCMIPP_P1YUVCR_TYPE_YUV 0
+#define DCMIPP_P1YUVCR_TYPE_RGB BIT(1)
+#define DCMIPP_P1YUVCR_CLAMP BIT(2)
+#define DCMIPP_P1YUVRR1 (0x984)
+#define DCMIPP_P1YUVRR2 (0x988)
+#define DCMIPP_P1YUVGR1 (0x98C)
+#define DCMIPP_P1YUVGR2 (0x990)
+#define DCMIPP_P1YUVBR1 (0x994)
+#define DCMIPP_P1YUVBR2 (0x998)
+
+#define DCMIPP_P1PPCR (0x9C0)
+#define DCMIPP_P2PPCR (0xDC0)
+#define DCMIPP_PxPPCR(id) (((id) == 1) ? DCMIPP_P1PPCR :\
+			   DCMIPP_P2PPCR)
+#define DCMIPP_PxPPCR_FORMAT_SHIFT 0
+#define DCMIPP_PxPPCR_FORMAT_MASK GENMASK(3, 0)
+#define DCMIPP_PxPPCR_FORMAT_RGB888_OR_YUV444_1BUFFER 0x0
+#define DCMIPP_PxPPCR_FORMAT_RGB565 0x1
+#define DCMIPP_PxPPCR_FORMAT_ARGB8888 0x2
+#define DCMIPP_PxPPCR_FORMAT_RGBA8888 0x3
+#define DCMIPP_PxPPCR_FORMAT_Y8 0x4
+#define DCMIPP_PxPPCR_FORMAT_YUV444 0x5
+#define DCMIPP_PxPPCR_FORMAT_YUYV 0x6
+#define DCMIPP_P1PPCR_FORMAT_NV61 0x7
+#define DCMIPP_P1PPCR_FORMAT_NV21 0x8
+#define DCMIPP_P1PPCR_FORMAT_YV12 0x9
+#define DCMIPP_PxPPCR_FORMAT_UYVY 0xa
+
+#define DCMIPP_PxPPCR_SWAPRB BIT(4)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+#define PAD_STR(pad) (IS_SRC((pad))) ? "src" : "sink"
+
+#define PIXELPROC_MEDIA_BUS_SRC_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+#define PIXELPROC_MEDIA_BUS_SINK_FMT_DEFAULT MEDIA_BUS_FMT_RGB888_1X24
+
+struct dcmipp_pixelproc_pix_map {
+	unsigned int code;
+	unsigned int ppcr_fmt;
+	unsigned int swap_uv;
+};
+
+#define PIXMAP_MBUS_PPCR_SWAPUV(mbus, pp_code, swap)	\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.ppcr_fmt = pp_code,	\
+			.swap_uv = swap,	\
+		}
+static const struct dcmipp_pixelproc_pix_map dcmipp_pixelproc_sink_pix_map_list[] = {
+	PIXMAP_MBUS_PPCR_SWAPUV(RGB888_1X24, 0, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YUV8_1X24, 0, 0),
+};
+
+static const struct dcmipp_pixelproc_pix_map dcmipp_pixelproc_src_pix_map_list[] = {
+	PIXMAP_MBUS_PPCR_SWAPUV(RGB888_1X24, DCMIPP_PxPPCR_FORMAT_RGB888_OR_YUV444_1BUFFER, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(RGB565_2X8_LE, DCMIPP_PxPPCR_FORMAT_RGB565, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YUYV8_2X8, DCMIPP_PxPPCR_FORMAT_YUYV, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YVYU8_2X8, DCMIPP_PxPPCR_FORMAT_YUYV, 1),
+	PIXMAP_MBUS_PPCR_SWAPUV(UYVY8_2X8, DCMIPP_PxPPCR_FORMAT_UYVY, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(VYUY8_2X8, DCMIPP_PxPPCR_FORMAT_UYVY, 1),
+	PIXMAP_MBUS_PPCR_SWAPUV(Y8_1X8, DCMIPP_PxPPCR_FORMAT_Y8, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YUYV8_1_5X8, DCMIPP_P1PPCR_FORMAT_NV21, 0), /* FIXME no mbus code for semiplanar (NV12) */
+	PIXMAP_MBUS_PPCR_SWAPUV(YVYU8_1_5X8, DCMIPP_P1PPCR_FORMAT_NV21, 1), /* FIXME no mbus code for semiplanar (NV21) */
+	PIXMAP_MBUS_PPCR_SWAPUV(YUYV8_1X16,  DCMIPP_P1PPCR_FORMAT_NV61, 0), /* FIXME no mbus code for semiplanar (NV16)*/
+	PIXMAP_MBUS_PPCR_SWAPUV(YVYU8_1X16,  DCMIPP_P1PPCR_FORMAT_NV61, 1), /* FIXME no mbus code for semiplanar (NV61)*/
+	PIXMAP_MBUS_PPCR_SWAPUV(UYVY8_1_5X8, DCMIPP_P1PPCR_FORMAT_YV12, 0), /* FIXME no mbus code for planar (I420/YU12)*/
+	PIXMAP_MBUS_PPCR_SWAPUV(VYUY8_1_5X8, DCMIPP_P1PPCR_FORMAT_YV12, 1), /* FIXME no mbus code for planar (YV12)*/
+};
+
+static const struct dcmipp_pixelproc_pix_map *
+dcmipp_pixelproc_pix_map_by_index(unsigned int i, unsigned int pad)
+{
+	const struct dcmipp_pixelproc_pix_map *l;
+	unsigned int size;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_pixelproc_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_src_pix_map_list);
+	} else {
+		l = dcmipp_pixelproc_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_sink_pix_map_list);
+	}
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+static const struct dcmipp_pixelproc_pix_map *
+dcmipp_pixelproc_pix_map_by_code(u32 code, unsigned int pad)
+{
+	const struct dcmipp_pixelproc_pix_map *l;
+	unsigned int size;
+	unsigned int i;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_pixelproc_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_src_pix_map_list);
+	} else {
+		l = dcmipp_pixelproc_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_sink_pix_map_list);
+	}
+
+	for (i = 0; i < size; i++) {
+		if (l[i].code == code)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+struct dcmipp_pixelproc_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	struct v4l2_mbus_framefmt sink_fmt;
+	struct v4l2_mbus_framefmt src_fmt;
+	bool streaming;
+	/* Protect this data structure */
+	struct mutex lock;
+
+	void __iomem *regs;
+	struct v4l2_ctrl_handler ctrls;
+
+	u32 pipe_id;
+
+	struct v4l2_fract sink_interval;
+	unsigned int frate;
+	u32 src_code;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+};
+
+static const struct v4l2_mbus_framefmt fmt_sink_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = PIXELPROC_MEDIA_BUS_SINK_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+static const struct v4l2_mbus_framefmt fmt_src_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = PIXELPROC_MEDIA_BUS_SRC_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+};
+
+static const struct v4l2_rect crop_min = {
+	.width = DCMIPP_FRAME_MIN_WIDTH,
+	.height = DCMIPP_FRAME_MIN_HEIGHT,
+	.top = 0,
+	.left = 0,
+};
+
+#define DCMIPP_MAX_DOWNSIZE_RATIO 8
+
+/*
+ * Functions handling controls
+ */
+#define V4L2_CID_PIXELPROC_GAMMA_CORRECTION	(V4L2_CID_USER_BASE | 0x1001)
+
+static int dcmipp_pixelproc_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dcmipp_pixelproc_device *pixelproc =
+		container_of(ctrl->handler,
+			     struct dcmipp_pixelproc_device, ctrls);
+	int ret = 0;
+
+	mutex_lock(&pixelproc->lock);
+
+	if (pixelproc->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	switch (ctrl->id) {
+	case V4L2_CID_PIXELPROC_GAMMA_CORRECTION:
+		reg_write(pixelproc, DCMIPP_PxGMCR(pixelproc->pipe_id),
+			  (ctrl->val ? DCMIPP_PxGMCR_ENABLE : 0));
+		break;
+	}
+
+out:
+	mutex_unlock(&pixelproc->lock);
+	return ret;
+};
+
+static const struct v4l2_ctrl_ops dcmipp_pixelproc_ctrl_ops = {
+	.s_ctrl = dcmipp_pixelproc_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config dcmipp_pixelproc_ctrls[] = {
+	{
+		.ops		= &dcmipp_pixelproc_ctrl_ops,
+		.id		= V4L2_CID_PIXELPROC_GAMMA_CORRECTION,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Gamma correction",
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+	}
+};
+
+static struct v4l2_rect
+dcmipp_pixelproc_get_crop_bound(const struct v4l2_mbus_framefmt *fmt)
+{
+	/* Get the crop bounds to clamp the crop rectangle correctly */
+	struct v4l2_rect r = {
+		.left = 0,
+		.top = 0,
+		.width = fmt->width,
+		.height = fmt->height,
+	};
+	return r;
+}
+
+static void dcmipp_pixelproc_adjust_crop(struct v4l2_rect *r,
+					 const struct v4l2_mbus_framefmt *fmt)
+{
+	const struct v4l2_rect src_rect =
+		dcmipp_pixelproc_get_crop_bound(fmt);
+
+	/* Disallow rectangles smaller than the minimal one. */
+	v4l2_rect_set_min_size(r, &crop_min);
+	v4l2_rect_map_inside(r, &src_rect);
+}
+
+static void dcmipp_pixelproc_adjust_fmt(struct v4l2_mbus_framefmt *fmt, u32 pad)
+{
+	const struct dcmipp_pixelproc_pix_map *vpix;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_pixelproc_pix_map_by_code(fmt->code, pad);
+	if (!vpix)
+		fmt->code = IS_SRC(pad) ? fmt_src_default.code :
+					  fmt_sink_default.code;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH) & ~1;
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT);
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = IS_SRC(pad) ? fmt_src_default.field :
+					   fmt_sink_default.field;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_pixelproc_init_cfg(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+
+		mf = v4l2_subdev_get_try_format(sd, state, i);
+		*mf = IS_SRC(i) ? fmt_src_default : fmt_sink_default;
+	}
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_enum_mbus_code(struct v4l2_subdev *sd,
+					   struct v4l2_subdev_state *state,
+					   struct v4l2_subdev_mbus_code_enum *code)
+{
+	const struct dcmipp_pixelproc_pix_map *vpix;
+
+	vpix = dcmipp_pixelproc_pix_map_by_index(code->index, code->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	code->code = vpix->code;
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_enum_frame_size(struct v4l2_subdev *sd,
+					    struct v4l2_subdev_state *state,
+					    struct v4l2_subdev_frame_size_enum *fse)
+{
+	const struct dcmipp_pixelproc_pix_map *vpix;
+
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_pixelproc_pix_map_by_code(fse->code, fse->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_get_fmt(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&pixelproc->lock);
+
+	if (IS_SINK(fmt->pad))
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, 0) :
+			      pixelproc->sink_fmt;
+	else
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, 0) :
+			      pixelproc->src_fmt;
+
+	mutex_unlock(&pixelproc->lock);
+
+	return 0;
+}
+
+#define dcmipp_pixelproc_is_yuv_fmt(a) ({				      \
+	typeof(a) __a = (a);						      \
+	((__a) >= MEDIA_BUS_FMT_Y8_1X8 && (__a) < MEDIA_BUS_FMT_SBGGR8_1X8) ? \
+	 true : false; })
+static int dcmipp_pixelproc_set_fmt(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *pad_fmt;
+	int ret = 0;
+
+	mutex_lock(&pixelproc->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		if (pixelproc->streaming) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		if (IS_SINK(fmt->pad))
+			pad_fmt = &pixelproc->sink_fmt;
+		else
+			pad_fmt = &pixelproc->src_fmt;
+
+	} else {
+		pad_fmt = v4l2_subdev_get_try_format(sd, state, 0);
+	}
+
+	dcmipp_pixelproc_adjust_fmt(&fmt->format, fmt->pad);
+
+	dev_dbg(pixelproc->dev, "%s: %s format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		pixelproc->sd.name,
+		PAD_STR(fmt->pad),
+		/* old */
+		pad_fmt->width, pad_fmt->height, pad_fmt->code,
+		pad_fmt->colorspace, pad_fmt->quantization,
+		pad_fmt->xfer_func, pad_fmt->ycbcr_enc,
+		/* new */
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.colorspace, fmt->format.quantization,
+		fmt->format.xfer_func, fmt->format.ycbcr_enc);
+
+	*pad_fmt = fmt->format;
+
+	/* Update sink pad crop - compose */
+	if (IS_SINK(fmt->pad) && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		/* Update sink pad crop */
+		pixelproc->crop.top = 0;
+		pixelproc->crop.left = 0;
+		pixelproc->crop.width = fmt->format.width;
+		pixelproc->crop.height = fmt->format.height;
+
+		pixelproc->compose.top = 0;
+		pixelproc->compose.left = 0;
+		pixelproc->compose.width = fmt->format.width;
+		pixelproc->compose.height = fmt->format.height;
+
+		/* Update src pad format & size */
+		pixelproc->src_fmt = fmt_src_default;
+		pixelproc->src_fmt.code =
+			dcmipp_pixelproc_is_yuv_fmt(fmt->format.code) ?
+				MEDIA_BUS_FMT_YUYV8_2X8 :
+				MEDIA_BUS_FMT_RGB565_2X8_LE;
+		pixelproc->src_fmt.width = fmt->format.width;
+		pixelproc->src_fmt.height = fmt->format.height;
+	}
+
+out:
+	mutex_unlock(&pixelproc->lock);
+
+	return ret;
+}
+
+static int dcmipp_pixelproc_get_selection(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_state *state,
+					  struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &pixelproc->sink_fmt;
+		crop = &pixelproc->crop;
+		compose = &pixelproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		s->r = *crop;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		s->r = dcmipp_pixelproc_get_crop_bound(sink_fmt);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r = *compose;
+		break;
+	/* TODO - not sure how to define BOUND here */
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_set_selection(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_state *state,
+					  struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &pixelproc->sink_fmt;
+		crop = &pixelproc->crop;
+		compose = &pixelproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		dcmipp_pixelproc_adjust_crop(&s->r, sink_fmt);
+
+		*crop = s->r;
+
+		/* Setting the crop also set the compose identically */
+		*compose = *crop;
+
+		/*
+		 * In case of setting the crop with ACTIVE set, we need to
+		 * update the source pad size
+		 */
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			pixelproc->src_fmt.width = s->r.width;
+			pixelproc->src_fmt.height = s->r.height;
+		}
+		/* TODO - when not in format active, we should also update the
+		 * try src pad format
+		 */
+
+		dev_dbg(pixelproc->dev, "s_selection: crop %ux%u@(%u,%u)\n",
+			crop->width, crop->height, crop->left, crop->top);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		if (s->r.width > crop->width)
+			s->r.width = crop->width;
+		else if (s->r.width < (crop->width / DCMIPP_MAX_DOWNSIZE_RATIO))
+			s->r.width = crop->width / DCMIPP_MAX_DOWNSIZE_RATIO;
+
+		if (s->r.height > crop->height)
+			s->r.height = crop->height;
+		else if (s->r.height < (crop->height / DCMIPP_MAX_DOWNSIZE_RATIO))
+			s->r.height = crop->width / DCMIPP_MAX_DOWNSIZE_RATIO;
+		s->r.top = 0;
+		s->r.left = 0;
+
+		*compose = s->r;
+
+		/*
+		 * In case of setting the compose with ACTIVE set, we need to
+		 * update the source pad size
+		 */
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			pixelproc->src_fmt.width = s->r.width;
+			pixelproc->src_fmt.height = s->r.height;
+		}
+		/* TODO - when not in format active, we should also update the
+		 * try src pad format
+		 */
+
+		dev_dbg(pixelproc->dev, "s_selection: compose %ux%u@(%u,%u)\n",
+			s->r.width, s->r.height, s->r.left, s->r.top);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_pixelproc_pad_ops = {
+	.init_cfg		= dcmipp_pixelproc_init_cfg,
+	.enum_mbus_code		= dcmipp_pixelproc_enum_mbus_code,
+	.enum_frame_size	= dcmipp_pixelproc_enum_frame_size,
+	.get_fmt		= dcmipp_pixelproc_get_fmt,
+	.set_fmt		= dcmipp_pixelproc_set_fmt,
+	.get_selection		= dcmipp_pixelproc_get_selection,
+	.set_selection		= dcmipp_pixelproc_set_selection,
+};
+
+static int
+dcmipp_pixelproc_colorconv_config(struct dcmipp_pixelproc_device *pixelproc)
+{
+	struct dcmipp_colorconv_config ccconf = { 0 };
+	int i, ret = 0;
+	unsigned int val = 0;
+
+	ret = dcmipp_colorconv_configure(pixelproc->dev, &pixelproc->sink_fmt,
+					 &pixelproc->src_fmt, &ccconf);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < 6; i++)
+		reg_write(pixelproc, DCMIPP_P1YUVRR1 + (4 * i),
+			  ccconf.conv_matrix[i]);
+
+	if (ccconf.clamping)
+		val |= DCMIPP_P1YUVCR_CLAMP;
+	if (!dcmipp_pixelproc_is_yuv_fmt(pixelproc->src_fmt.code))
+		val |= DCMIPP_P1YUVCR_TYPE_RGB;
+	if (ccconf.enable)
+		val |= DCMIPP_P1YUVCR_ENABLE;
+
+	reg_write(pixelproc, DCMIPP_P1YUVCR, val);
+
+	return 0;
+}
+
+#define DCMIPP_PIXELPROC_HVRATIO_CONS	8192
+#define DCMIPP_PIXELPROC_HVRATIO_MAX	65535
+#define DCMIPP_PIXELPROC_HVDIV_CONS	1024
+#define DCMIPP_PIXELPROC_HVDIV_MAX	1023
+static void
+dcmipp_pixelproc_set_downsize(struct dcmipp_pixelproc_device *pixelproc)
+{
+	unsigned int hratio, vratio, hdiv, vdiv;
+
+	hratio = (pixelproc->crop.width - 1) * DCMIPP_PIXELPROC_HVRATIO_CONS /
+		 (pixelproc->compose.width - 1);
+	if (hratio > DCMIPP_PIXELPROC_HVRATIO_MAX)
+		hratio = DCMIPP_PIXELPROC_HVRATIO_MAX;
+	vratio = (pixelproc->crop.height - 1) * DCMIPP_PIXELPROC_HVRATIO_CONS /
+		 (pixelproc->compose.height - 1);
+	if (vratio > DCMIPP_PIXELPROC_HVRATIO_MAX)
+		vratio = DCMIPP_PIXELPROC_HVRATIO_MAX;
+	hdiv = (DCMIPP_PIXELPROC_HVDIV_CONS * pixelproc->compose.width) /
+		pixelproc->crop.width;
+	if (hdiv > DCMIPP_PIXELPROC_HVDIV_MAX)
+		hdiv = DCMIPP_PIXELPROC_HVDIV_MAX;
+	vdiv = (DCMIPP_PIXELPROC_HVDIV_CONS * pixelproc->compose.height) /
+		pixelproc->crop.height;
+	if (vdiv > DCMIPP_PIXELPROC_HVDIV_MAX)
+		vdiv = DCMIPP_PIXELPROC_HVDIV_MAX;
+
+	dev_dbg(pixelproc->dev, "%s: downsize config: hratio: 0x%x, vratio: 0x%x, hdiv: 0x%x, vdiv: 0x%x\n",
+		pixelproc->sd.name,
+		hratio, vratio,
+		hdiv, vdiv);
+
+	reg_clear(pixelproc, DCMIPP_PxDSCR(pixelproc->pipe_id),
+		  DCMIPP_PxDSCR_ENABLE);
+	reg_write(pixelproc, DCMIPP_PxDSRTIOR(pixelproc->pipe_id),
+		  (hratio << DCMIPP_PxDSRTIOR_HRATIO_SHIFT) |
+		  (vratio << DCMIPP_PxDSRTIOR_VRATIO_SHIFT));
+	reg_write(pixelproc, DCMIPP_PxDSSZR(pixelproc->pipe_id),
+		  (pixelproc->compose.width << DCMIPP_PxDSSZR_HSIZE_SHIFT) |
+		  (pixelproc->compose.height << DCMIPP_PxDSSZR_VSIZE_SHIFT));
+	reg_write(pixelproc, DCMIPP_PxDSCR(pixelproc->pipe_id),
+		  (hdiv << DCMIPP_PxDSCR_HDIV_SHIFT) |
+		  (vdiv << DCMIPP_PxDSCR_VDIV_SHIFT) |
+		  DCMIPP_PxDSCR_ENABLE);
+}
+
+static int dcmipp_pixelproc_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	const struct dcmipp_pixelproc_pix_map *vpix;
+	int ret = 0;
+	unsigned int val;
+
+	mutex_lock(&pixelproc->lock);
+	if (enable) {
+		/* TODO - need to add framerate control */
+
+		/* Configure cropping */
+		reg_write(pixelproc, DCMIPP_PxCRSTR(pixelproc->pipe_id),
+			  (pixelproc->crop.top << DCMIPP_PxCRSTR_VSTART_SHIFT) |
+			  (pixelproc->crop.left << DCMIPP_PxCRSTR_HSTART_SHIFT));
+		reg_write(pixelproc, DCMIPP_PxCRSZR(pixelproc->pipe_id),
+			  (pixelproc->crop.width << DCMIPP_PxCRSZR_HSIZE_SHIFT) |
+			  (pixelproc->crop.height << DCMIPP_PxCRSZR_VSIZE_SHIFT) |
+			  DCMIPP_PxCRSZR_ENABLE);
+
+		/* Configure downsize */
+		dcmipp_pixelproc_set_downsize(pixelproc);
+
+		/* Configure YUV Conversion (if applicable) */
+		if (pixelproc->pipe_id == 1) {
+			ret = dcmipp_pixelproc_colorconv_config(pixelproc);
+			if (ret)
+				goto out;
+		}
+
+		/* Setup the PixelPacker based on the src pad format */
+		vpix = dcmipp_pixelproc_pix_map_by_code(pixelproc->src_fmt.code, 1);
+		if (!vpix) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		val = vpix->ppcr_fmt;
+		if (vpix->swap_uv)
+			val |= DCMIPP_PxPPCR_SWAPRB;
+
+		reg_write(pixelproc, DCMIPP_PxPPCR(pixelproc->pipe_id), val);
+	}
+
+out:
+	mutex_unlock(&pixelproc->lock);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops dcmipp_pixelproc_video_ops = {
+	.s_stream = dcmipp_pixelproc_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_pixelproc_ops = {
+	.pad = &dcmipp_pixelproc_pad_ops,
+	.video = &dcmipp_pixelproc_video_ops,
+};
+
+/* FIXME */
+static void dcmipp_pixelproc_release(struct v4l2_subdev *sd)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+
+	kfree(pixelproc);
+}
+
+static const struct v4l2_subdev_internal_ops dcmipp_pixelproc_int_ops = {
+	.release = dcmipp_pixelproc_release,
+};
+
+static void
+dcmipp_pixelproc_comp_unbind(struct device *comp, struct device *master,
+			     void *master_data)
+{
+	struct dcmipp_ent_device *ved = dev_get_drvdata(comp);
+	struct dcmipp_pixelproc_device *pixelproc =
+			container_of(ved, struct dcmipp_pixelproc_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &pixelproc->sd);
+}
+
+static int dcmipp_name_to_pipe_id(const char *name)
+{
+	if (strstr(name, "main"))
+		return 1;
+	else if (strstr(name, "aux"))
+		return 2;
+	else
+		return -EINVAL;
+}
+
+static int
+dcmipp_pixelproc_comp_bind(struct device *comp, struct device *master,
+			   void *master_data)
+{
+	struct dcmipp_bind_data *bind_data = master_data;
+	struct dcmipp_platform_data *pdata = comp->platform_data;
+	struct dcmipp_pixelproc_device *pixelproc;
+	int ret, i;
+
+	/* Allocate the pixelproc struct */
+	pixelproc = kzalloc(sizeof(*pixelproc), GFP_KERNEL);
+	if (!pixelproc)
+		return -ENOMEM;
+
+	pixelproc->regs = bind_data->regs;
+
+	/* Initialize the lock */
+	mutex_init(&pixelproc->lock);
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register(&pixelproc->ved, &pixelproc->sd,
+				     bind_data->v4l2_dev,
+				     pdata->entity_name,
+				     MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER, 2,
+				     (const unsigned long[2]) {
+				     MEDIA_PAD_FL_SINK,
+				     MEDIA_PAD_FL_SOURCE,
+				     },
+				     &dcmipp_pixelproc_int_ops, &dcmipp_pixelproc_ops,
+				     NULL, NULL);
+	if (ret) {
+		kfree(pixelproc);
+		return ret;
+	}
+
+	dev_set_drvdata(comp, &pixelproc->ved);
+	pixelproc->dev = comp;
+
+	/* Pipe identifier */
+	pixelproc->pipe_id = dcmipp_name_to_pipe_id(pdata->entity_name);
+	if (pixelproc->pipe_id != 1 && pixelproc->pipe_id != 2) {
+		dev_err(comp, "failed to retrieve pipe_id\n");
+		/* TODO - fix error handling */
+		return -1;
+	}
+
+	/* Initialize the frame format */
+	pixelproc->sink_fmt = fmt_sink_default;
+	pixelproc->src_fmt = fmt_src_default;
+	pixelproc->crop.top = 0;
+	pixelproc->crop.left = 0;
+	pixelproc->crop.width = DCMIPP_FMT_WIDTH_DEFAULT;
+	pixelproc->crop.height = DCMIPP_FMT_HEIGHT_DEFAULT;
+	pixelproc->compose.top = 0;
+	pixelproc->compose.left = 0;
+	pixelproc->compose.width = DCMIPP_FMT_WIDTH_DEFAULT;
+	pixelproc->compose.height = DCMIPP_FMT_HEIGHT_DEFAULT;
+
+	/* Initialize controls */
+	v4l2_ctrl_handler_init(&pixelproc->ctrls,
+			       ARRAY_SIZE(dcmipp_pixelproc_ctrls));
+
+	for (i = 0; i < ARRAY_SIZE(dcmipp_pixelproc_ctrls); i++)
+		v4l2_ctrl_new_custom(&pixelproc->ctrls,
+				     &dcmipp_pixelproc_ctrls[i], NULL);
+
+	pixelproc->sd.ctrl_handler = &pixelproc->ctrls;
+	if (pixelproc->ctrls.error) {
+		dev_err(pixelproc->dev, "control initialization error %d\n",
+			pixelproc->ctrls.error);
+		/* TODO - error handling */
+	}
+
+	return 0;
+}
+
+static const struct component_ops dcmipp_pixelproc_comp_ops = {
+	.bind = dcmipp_pixelproc_comp_bind,
+	.unbind = dcmipp_pixelproc_comp_unbind,
+};
+
+static int dcmipp_pixelproc_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &dcmipp_pixelproc_comp_ops);
+}
+
+static int dcmipp_pixelproc_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &dcmipp_pixelproc_comp_ops);
+
+	return 0;
+}
+
+static const struct platform_device_id dcmipp_pixelproc_driver_ids[] = {
+	{
+		.name           = DCMIPP_PIXELPROC_DRV_NAME,
+	},
+	{ }
+};
+
+static struct platform_driver dcmipp_pixelproc_pdrv = {
+	.probe		= dcmipp_pixelproc_probe,
+	.remove		= dcmipp_pixelproc_remove,
+	.id_table	= dcmipp_pixelproc_driver_ids,
+	.driver		= {
+		.name	= DCMIPP_PIXELPROC_DRV_NAME,
+	},
+};
+
+module_platform_driver(dcmipp_pixelproc_pdrv);
+
+MODULE_DEVICE_TABLE(platform, dcmipp_pixelproc_driver_ids);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
