From e8a3f1c630077ab5301cee1bb845970279e272ee Mon Sep 17 00:00:00 2001
From: Pankaj Dev <pankaj.dev@st.com>
Date: Thu, 28 Mar 2024 15:56:41 +0530
Subject: [PATCH 1082/1141] usb: dwc3: Fix for xhci-reset stuck issue with dwc3

Patch provided by Synopsys with following comment :
The change we have here is to keep both the GUSB3PIPECTL.SUSPENDENABLE
and GUSB2PHYCFG.SUSPENDUSB20 bits clear when switching mode, only to
restore them after the controller initialization completes.
For host mode, the host controller initialization described in xHCI spec
section 4.2 describe the last step of the initialization is to turn on
the Run/Stop bit. This is what we tried with drd_susphy_v2. This patch
will resolve this issue. The change touches some xhci files, not the
core files, and it will be available in linux mainline in the future

Change-Id: I6b08f16d6fc2d660c56d0ddea4f67c13e844f1c3
Signed-off-by: Pankaj Dev <pankaj.dev@st.com>
Reviewed-on: https://gerrit.st.com/c/mpu/oe/st/linux-stm32/+/370114
Reviewed-by: Fabrice GASNIER <fabrice.gasnier@foss.st.com>
Domain-Review: Fabrice GASNIER <fabrice.gasnier@foss.st.com>
---
 drivers/usb/dwc3/core.c      | 38 ++++++++++++++++++++++--------------
 drivers/usb/dwc3/core.h      |  4 ++++
 drivers/usb/dwc3/gadget.c    |  1 +
 drivers/usb/dwc3/host.c      | 35 +++++++++++++++++++++++++++++++++
 drivers/usb/host/xhci-plat.c | 18 ++++++++++++++++-
 drivers/usb/host/xhci-plat.h |  2 ++
 6 files changed, 82 insertions(+), 16 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index da02bfcde3ff..dbf74a735cf8 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -104,6 +104,27 @@ static int dwc3_get_dr_mode(struct dwc3 *dwc)
 	return 0;
 }
 
+void dwc3_enable_susphy(struct dwc3 *dwc, bool enable)
+{
+	u32 reg;
+
+	reg = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));
+	if (enable && !dwc->dis_u3_susphy_quirk)
+		reg |= DWC3_GUSB3PIPECTL_SUSPHY;
+	else
+		reg &= ~DWC3_GUSB3PIPECTL_SUSPHY;
+
+	dwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), reg);
+
+	reg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
+	if (enable && !dwc->dis_u2_susphy_quirk)
+		reg |= DWC3_GUSB2PHYCFG_SUSPHY;
+	else
+		reg &= ~DWC3_GUSB2PHYCFG_SUSPHY;
+
+	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
+}
+
 void dwc3_set_prtcap(struct dwc3 *dwc, u32 mode)
 {
 	u32 reg;
@@ -156,6 +177,8 @@ static void __dwc3_set_mode(struct work_struct *work)
 	if (desired_dr_role == DWC3_GCTL_PRTCAP_OTG && dwc->edev)
 		goto out;
 
+	dwc3_enable_susphy(dwc, false);
+
 	switch (dwc->current_dr_role) {
 	case DWC3_GCTL_PRTCAP_HOST:
 		dwc3_host_exit(dwc);
@@ -1252,21 +1275,6 @@ static int dwc3_core_init(struct dwc3 *dwc)
 	if (ret)
 		goto err1;
 
-	if (hw_mode == DWC3_GHWPARAMS0_MODE_DRD &&
-	    !DWC3_VER_IS_WITHIN(DWC3, ANY, 194A)) {
-		if (!dwc->dis_u3_susphy_quirk) {
-			reg = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));
-			reg |= DWC3_GUSB3PIPECTL_SUSPHY;
-			dwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), reg);
-		}
-
-		if (!dwc->dis_u2_susphy_quirk) {
-			reg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
-			reg |= DWC3_GUSB2PHYCFG_SUSPHY;
-			dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
-		}
-	}
-
 	dwc3_core_setup_global_control(dwc);
 	dwc3_core_num_eps(dwc);
 
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 9d793264526c..f199fb28cff1 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -978,6 +978,7 @@ struct dwc3_scratchpad_array {
  * @ep0_usb_req: dummy req used while handling STD USB requests
  * @scratch_addr: dma address of scratchbuf
  * @ep0_in_setup: one control transfer is completed and enter setup phase
+ * @xhci_plat_data: private data for xhci callback
  * @lock: for synchronizing
  * @mutex: for mode switching
  * @dev: pointer to our struct device
@@ -1138,6 +1139,8 @@ struct dwc3 {
 	struct dwc3_request	ep0_usb_req;
 	struct completion	ep0_in_setup;
 
+	void			*xhci_plat_data;
+
 	/* device lock */
 	spinlock_t		lock;
 
@@ -1561,6 +1564,7 @@ int dwc3_event_buffers_setup(struct dwc3 *dwc);
 void dwc3_event_buffers_cleanup(struct dwc3 *dwc);
 
 int dwc3_core_soft_reset(struct dwc3 *dwc);
+void dwc3_enable_susphy(struct dwc3 *dwc, bool enable);
 
 #if IS_ENABLED(CONFIG_USB_DWC3_HOST) || IS_ENABLED(CONFIG_USB_DWC3_DUAL_ROLE)
 int dwc3_host_init(struct dwc3 *dwc);
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index b134110cc2ed..a4180a791548 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -2831,6 +2831,7 @@ static int __dwc3_gadget_start(struct dwc3 *dwc)
 	dwc3_ep0_out_start(dwc);
 
 	dwc3_gadget_enable_irq(dwc);
+	dwc3_enable_susphy(dwc, true);
 
 	return 0;
 
diff --git a/drivers/usb/dwc3/host.c b/drivers/usb/dwc3/host.c
index f4d8e80c4c34..f0b22b1aabbb 100644
--- a/drivers/usb/dwc3/host.c
+++ b/drivers/usb/dwc3/host.c
@@ -11,8 +11,32 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 
+#include "../host/xhci-plat.h"
+
+#include "io.h"
 #include "core.h"
 
+static void dwc3_xhci_post_plat_start(struct usb_hcd *hcd)
+{
+	struct platform_device *pdev;
+	struct xhci_plat_priv *priv;
+	struct dwc3 *dwc;
+
+	if (!usb_hcd_is_primary_hcd(hcd))
+		return;
+
+	pdev = to_platform_device(hcd->self.controller);
+	priv = dev_get_platdata(&pdev->dev);
+
+	dwc = priv->data;
+
+	/* Only apply to DRD mode */
+	if (DWC3_GHWPARAMS0_MODE(dwc->hwparams.hwparams0) != DWC3_GHWPARAMS0_MODE_DRD)
+		return;
+
+	dwc3_enable_susphy(dwc, true);
+}
+
 static void dwc3_host_fill_xhci_irq_res(struct dwc3 *dwc,
 					int irq, char *name)
 {
@@ -68,6 +92,8 @@ int dwc3_host_init(struct dwc3 *dwc)
 {
 	struct property_entry	props[5];
 	struct platform_device	*xhci;
+	struct xhci_plat_priv dwc3_xhci_plat_data = { 0 };
+
 	int			ret, irq;
 	int			prop_idx = 0;
 
@@ -122,9 +148,18 @@ int dwc3_host_init(struct dwc3 *dwc)
 		}
 	}
 
+	dwc3_xhci_plat_data.post_plat_start = dwc3_xhci_post_plat_start;
+	dwc3_xhci_plat_data.data = dwc;
+
+	ret = platform_device_add_data(xhci, &dwc3_xhci_plat_data,
+				       sizeof(struct xhci_plat_priv));
+	if (ret)
+		goto err;
+
 	ret = platform_device_add(xhci);
 	if (ret) {
 		dev_err(dwc->dev, "failed to register xHCI device\n");
+		kfree(dwc->xhci_plat_data);
 		goto err;
 	}
 
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index b387d39bfb81..0f48be40cf53 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -44,6 +44,14 @@ static void xhci_priv_plat_start(struct usb_hcd *hcd)
 		priv->plat_start(hcd);
 }
 
+static void xhci_priv_post_plat_start(struct usb_hcd *hcd)
+{
+	struct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);
+
+	if (priv->post_plat_start)
+		priv->post_plat_start(hcd);
+}
+
 static int xhci_priv_init_quirk(struct usb_hcd *hcd)
 {
 	struct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);
@@ -101,8 +109,16 @@ static int xhci_plat_setup(struct usb_hcd *hcd)
 
 static int xhci_plat_start(struct usb_hcd *hcd)
 {
+	int ret;
+
 	xhci_priv_plat_start(hcd);
-	return xhci_run(hcd);
+	ret = xhci_run(hcd);
+	if (ret)
+		return ret;
+
+	xhci_priv_post_plat_start(hcd);
+
+	return 0;
 }
 
 #ifdef CONFIG_OF
diff --git a/drivers/usb/host/xhci-plat.h b/drivers/usb/host/xhci-plat.h
index 1fb149d1fbce..df6705a1e15e 100644
--- a/drivers/usb/host/xhci-plat.h
+++ b/drivers/usb/host/xhci-plat.h
@@ -14,9 +14,11 @@ struct xhci_plat_priv {
 	const char *firmware_name;
 	unsigned long long quirks;
 	void (*plat_start)(struct usb_hcd *);
+	void (*post_plat_start)(struct usb_hcd *);
 	int (*init_quirk)(struct usb_hcd *);
 	int (*suspend_quirk)(struct usb_hcd *);
 	int (*resume_quirk)(struct usb_hcd *);
+	void *data;
 };
 
 #define hcd_to_xhci_priv(h) ((struct xhci_plat_priv *)hcd_to_xhci(h)->priv)
-- 
2.39.2

