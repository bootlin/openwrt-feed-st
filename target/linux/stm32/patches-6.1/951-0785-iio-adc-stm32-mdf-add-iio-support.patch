From c3ccedf886302f264f0019fdb1737d95d701b846 Mon Sep 17 00:00:00 2001
From: Olivier Moysan <olivier.moysan@foss.st.com>
Date: Thu, 4 Jan 2024 15:18:22 +0100
Subject: [PATCH 0785/1141] iio: adc: stm32-mdf: add iio support

Add IIO support to STM32 MDF.

NOT_UPSTREAMABLE

This version is not compatible with the SD modulator driver,
as the MDF IIO device is implemented as a channel provider.
(The SD modulator is currently a channel provider)
For time being the MDF device is not connected to a SD modulator
device, in the device tree.

Due to this restriction the scaling is not yet supported.
The MDF and SD modulator drivers have to adopt new IIO backend
framework to allow scaling support.

Signed-off-by: Olivier Moysan <olivier.moysan@foss.st.com>
Change-Id: I0f7d3bdb6941efdaf333f4932ad21a415b80521d
Reviewed-on: https://gerrit.st.com/c/mpu/oe/st/linux-stm32/+/350254
ACI: CITOOLS <MDG-smet-aci-reviews@list.st.com>
Reviewed-by: Fabrice GASNIER <fabrice.gasnier@foss.st.com>
Domain-Review: Fabrice GASNIER <fabrice.gasnier@foss.st.com>
---
 drivers/iio/adc/stm32-mdf-adc.c  | 1280 +++++++++++++++++++-----------
 drivers/iio/adc/stm32-mdf-core.c |   70 +-
 drivers/iio/adc/stm32-mdf.h      |   11 +-
 3 files changed, 861 insertions(+), 500 deletions(-)

--- a/drivers/iio/adc/stm32-mdf-adc.c
+++ b/drivers/iio/adc/stm32-mdf-adc.c
@@ -19,6 +19,7 @@
 #include <linux/iio/trigger_consumer.h>
 #include <linux/iio/triggered_buffer.h>
 #include <linux/interrupt.h>
+#include <linux/jiffies.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
@@ -30,6 +31,13 @@
 #define STM32_MDF_ITF_MAX 8
 #define STM32_MDF_DATA_RES 24
 #define STM32_MDF_HPF_BYPASS -1
+#define STM32_MDF_TIMEOUT_MS msecs_to_jiffies(100)
+#define MDF_DEFAULT_SAMPLING_FREQ 1024
+
+#define MDF_IS_FILTER0(adc)			(!((adc)->fl_id))
+#define MDF_IS_INTERLEAVED_FILT(adc)		((adc)->interleaved)
+#define MDF_IS_INTERLEAVED_FILT_NOT_0(adc)	({ typeof(adc) x = (adc);\
+						MDF_IS_INTERLEAVED_FILT(x) && !MDF_IS_FILTER0(x); })
 
 struct stm32_mdf_dev_data {
 	int type;
@@ -46,6 +54,7 @@ struct stm32_mdf_dev_data {
  * @dma_chan: filter dma channel pointer
  * @dev_data: mdf device data pointer
  * @sitf: pointer to serial interface feeding the filter
+ * @completion: completion for conversion
  * @dma_buf: physical dma address
  * @phys_addr: mdf physical address
  * @cb: iio consumer callback function pointer
@@ -57,13 +66,15 @@ struct stm32_mdf_dev_data {
  * @decim_cic: CIC filter decimation ratio
  * @bufi: dma buffer current position
  * @buf_sz: dma buffer size
+ * @buffer: buffer pointer for raw conversion
  * @cicmode: cic filter order
  * @hpf_cutoff: high pass filter cut-off frequency
- * @sync: syncchronous mode
  * @delay: microphone delay
+ * @datsrc: data source path
  * @rx_buf: dma buffer pointer
  * @rsflt_bypass: reshape filter bypass flag
- * @trigger: TRGO trigger flag
+ * @synced: synchronous flag
+ * @trgo: TRGO trigger flag
  * @interleaved: interleave flag
  */
 struct stm32_mdf_adc {
@@ -75,6 +86,7 @@ struct stm32_mdf_adc {
 	struct dma_chan *dma_chan;
 	const struct stm32_mdf_dev_data *dev_data;
 	struct stm32_mdf_sitf *sitf;
+	struct completion completion;
 	dma_addr_t dma_buf;
 	phys_addr_t phys_addr;
 	int (*cb)(const void *data, size_t size, void *cb_priv);
@@ -86,13 +98,15 @@ struct stm32_mdf_adc {
 	unsigned int decim_cic;
 	unsigned int bufi;
 	unsigned int buf_sz;
+	u32 *buffer;
 	u32 cicmode;
 	u32 hpf_cutoff;
-	u32 sync;
 	u32 delay;
+	u32 datsrc;
 	u8 *rx_buf;
 	bool rsflt_bypass;
-	bool trigger;
+	bool synced;
+	bool trgo;
 	bool interleaved;
 };
 
@@ -106,12 +120,12 @@ struct stm32_mdf_log10 {
 	unsigned int log;
 };
 
-enum sd_converter_type {
+enum stm32_mdf_converter_type {
 	STM32_MDF_AUDIO,
 	STM32_MDF_IIO,
 };
 
-enum stm32_data_src_type {
+enum stm32_mdf_data_src_type {
 	STM32_MDF_DATSRC_BSMX,
 	STM32_MDF_DATSRC_UNSUPPORTED,
 	STM32_MDF_DATSRC_ADCITF1,
@@ -119,20 +133,60 @@ enum stm32_data_src_type {
 	STM32_MDF_DATSRC_NB,
 };
 
-enum stm32_acq_mode {
+enum stm32_mdf_acq_mode {
 	STM32_MDF_ACQ_MODE_ASYNC_CONT,
 	STM32_MDF_ACQ_MODE_ASYNC_SINGLE_SHOT,
 	STM32_MDF_ACQ_MODE_SYNC_CONT,
+	STM32_MDF_ACQ_MODE_SYNC_SINGLE_SHOT,
 	STM32_MDF_ACQ_MODE_WINDOW_CONT,
 	STM32_MDF_ACQ_MODE_SYNC_SNAPSHOT,
 	STM32_MDF_ACQ_MODE_NB,
 };
 
-enum stm32_trig_src {
+enum stm32_trig_type {
 	STM32_MDF_TRGSRC_TRGO,
+	STM32_MDF_TRGSRC_OLD,
+	STM32_MDF_TRGSRC_EXT,
 	STM32_MDF_TRGSRC_NB,
 };
 
+enum stm32_trig_sens {
+	STM32_MDF_TRGSENS_RISING_EDGE,
+	STM32_MDF_TRGSENS_FALLING_EDGE,
+};
+
+enum stm32_trig_src {
+	STM32_MDF_TRGSRC_TIM1_TRGO2 = 0x2,
+	STM32_MDF_TRGSRC_TIM8_TRGO2,
+	STM32_MDF_TRGSRC_TIM20_TRGO2,
+	STM32_MDF_TRGSRC_TIM16_OC1,
+	STM32_MDF_TRGSRC_TIM6_TRGO,
+	STM32_MDF_TRGSRC_TIM7_TRGO,
+	STM32_MDF_TRGSRC_EXTI11,
+	STM32_MDF_TRGSRC_EXTI15,
+	STM32_MDF_TRGSRC_LPTIM1_CH1,
+	STM32_MDF_TRGSRC_LPTIM2_CH1,
+	STM32_MDF_TRGSRC_LPTIM3_CH1,
+};
+
+struct stm32_mdf_ext_trig_src {
+	const char *name;
+	unsigned int trgsrc;
+};
+
+static const struct stm32_mdf_ext_trig_src stm32_mdf_trigs[] = {
+	{ TIM1_TRGO2, STM32_MDF_TRGSRC_TIM1_TRGO2 },
+	{ TIM8_TRGO2, STM32_MDF_TRGSRC_TIM8_TRGO2 },
+	{ TIM20_TRGO2, STM32_MDF_TRGSRC_TIM20_TRGO2 },
+	{ TIM16_OC1, STM32_MDF_TRGSRC_TIM16_OC1 },
+	{ TIM6_TRGO, STM32_MDF_TRGSRC_TIM6_TRGO },
+	{ TIM7_TRGO, STM32_MDF_TRGSRC_TIM7_TRGO },
+	{ LPTIM1_CH1, STM32_MDF_TRGSRC_LPTIM1_CH1 },
+	{ LPTIM2_CH1, STM32_MDF_TRGSRC_LPTIM2_CH1 },
+	{ LPTIM3_CH1, STM32_MDF_TRGSRC_LPTIM3_CH1 },
+	{},
+};
+
 static const unsigned int stm32_mdf_hpf_cutoff_ratio[] = {
 	625, 1250, 2500, 9500
 };
@@ -201,7 +255,7 @@ static const struct stm32_mdf_log10 stm3
 	{113, 2053}, {127, 2104}
 };
 
-static bool stm32_mdf_readable_reg(struct device *dev, unsigned int reg)
+static bool stm32_mdf_adc_readable_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
 	case MDF_BSMXCR_REG:
@@ -217,27 +271,32 @@ static bool stm32_mdf_readable_reg(struc
 	case MDF_DFLTIER_REG:
 	case MDF_DFLTISR_REG:
 	case MDF_OECCR_REG:
-	case MDF_SNPSxDR:
-	case MDF_DLTDR_REG:
+	case MDF_SNPSDR:
+	case MDF_DFLTDR_REG:
 		return true;
 	default:
 		return false;
 	}
 }
 
-static bool stm32_mdf_volatile_reg(struct device *dev, unsigned int reg)
+static bool stm32_mdf_adc_volatile_reg(struct device *dev, unsigned int reg)
 {
+	/*
+	 * In MDF_DFLTCR_REG register only DFLTACTIVE & DFLTRUN bits are volatile.
+	 * MDF_DFLTCR_REG is not marked as volatible to ease the suspend/resume case, and benefit
+	 * from the regcache API. Access to volatile bits is managed specifically instead.
+	 */
 	switch (reg) {
 	case MDF_DFLTISR_REG:
-	case MDF_SNPSxDR:
-	case MDF_DLTDR_REG:
+	case MDF_SNPSDR:
+	case MDF_DFLTDR_REG:
 		return true;
 	default:
 		return false;
 	}
 }
 
-static bool stm32_mdf_writeable_reg(struct device *dev, unsigned int reg)
+static bool stm32_mdf_adc_writeable_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
 	case MDF_BSMXCR_REG:
@@ -263,27 +322,15 @@ static const struct regmap_config stm32_
 	.reg_bits = 32,
 	.val_bits = 32,
 	.reg_stride = sizeof(u32),
-	.max_register = MDF_DLTDR_REG,
-	.readable_reg = stm32_mdf_readable_reg,
-	.volatile_reg = stm32_mdf_volatile_reg,
-	.writeable_reg = stm32_mdf_writeable_reg,
-	.num_reg_defaults_raw = MDF_DLTDR_REG / sizeof(u32) + 1,
+	.max_register = MDF_DFLTDR_REG,
+	.readable_reg = stm32_mdf_adc_readable_reg,
+	.volatile_reg = stm32_mdf_adc_volatile_reg,
+	.writeable_reg = stm32_mdf_adc_writeable_reg,
+	.num_reg_defaults_raw = MDF_DFLTDR_REG / sizeof(u32) + 1,
 	.cache_type = REGCACHE_FLAT,
 	.fast_io = true,
 };
 
-static struct stm32_mdf_adc *stm32_mdf_get_filter_by_id(struct stm32_mdf *mdf, unsigned int fl_id)
-{
-	struct stm32_mdf_adc *adc;
-
-	/* Look for filter data from filter id */
-	list_for_each_entry(adc, &mdf->filter_list, entry)
-		if (adc->fl_id == fl_id)
-			return adc;
-
-	return NULL;
-}
-
 static struct stm32_mdf_adc *stm32_mdf_get_filter_by_handle(struct stm32_mdf *mdf,
 							    struct fwnode_handle *node)
 {
@@ -297,55 +344,380 @@ static struct stm32_mdf_adc *stm32_mdf_g
 	return NULL;
 }
 
-static int stm32_mdf_start_filter(struct stm32_mdf_adc *adc)
+static int stm32_mdf_adc_start_filter(struct stm32_mdf_adc *adc)
 {
 	struct stm32_mdf_adc *adc_inter;
 	struct stm32_mdf *mdf = adc->mdf;
 	u32 val;
 
+	if (MDF_IS_FILTER0(adc))
+		list_for_each_entry(adc_inter, &mdf->filter_list, entry)
+			if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter))
+				stm32_mdf_adc_start_filter(adc_inter);
+
+	/* Check filter status. Bypass cache to access volatile MDF_DFLTCR_ACTIVE bit */
+	regcache_cache_bypass(adc->regmap, true);
 	regmap_read(adc->regmap, MDF_DFLTCR_REG, &val);
+	regcache_cache_bypass(adc->regmap, false);
 	if (val & MDF_DFLTCR_ACTIVE) {
 		dev_err(adc->dev, "Filter [%d] is already running\n", adc->fl_id);
 		return -EBUSY;
 	}
 
-	if (!adc->fl_id && adc->mdf->nb_interleave) {
-		list_for_each_entry(adc_inter, &mdf->filter_list, entry) {
-			if (!adc_inter->interleaved)
-				continue;
-
-			regmap_read(adc_inter->regmap, MDF_DFLTCR_REG, &val);
-			if (val & MDF_DFLTCR_ACTIVE) {
-				dev_err(adc_inter->dev, "Filter [%d] is already running\n",
-					adc_inter->fl_id);
-				return -EBUSY;
-			}
+	return regmap_set_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+}
 
-			regmap_set_bits(adc_inter->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+static void stm32_mdf_adc_stop_filter(struct stm32_mdf_adc *adc)
+{
+	struct stm32_mdf_adc *adc_inter;
+	struct stm32_mdf *mdf = adc->mdf;
+
+	regmap_clear_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+
+	if (MDF_IS_FILTER0(adc))
+		list_for_each_entry(adc_inter, &mdf->filter_list, entry)
+			if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter))
+				stm32_mdf_adc_stop_filter(adc_inter);
+}
+
+static int stm32_mdf_adc_get_trig(struct iio_dev *indio_dev, struct iio_trigger *trig)
+{
+	int i;
+
+	/* lookup triggers registered by stm32 timer trigger driver */
+	for (i = 0; stm32_mdf_trigs[i].name; i++) {
+		/**
+		 * Checking both stm32 timer trigger type and trig name
+		 * should be safe against arbitrary trigger names.
+		 */
+		if ((is_stm32_timer_trigger(trig) ||
+		     is_stm32_lptim_trigger(trig)) &&
+		     !strcmp(stm32_mdf_trigs[i].name, trig->name)) {
+			dev_dbg(&indio_dev->dev, "Trigger [%d] found\n", i);
+			return stm32_mdf_trigs[i].trgsrc;
 		}
 	}
 
-	return regmap_set_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+	return -EINVAL;
 }
 
-static void stm32_mdf_stop_filter(struct stm32_mdf_adc *adc)
+static int stm32_mdf_adc_filter_set_trig(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct iio_trigger *trig = indio_dev->trig;
+	u32 trgsrc = 0;
+	/* set trigger polarity to rising edge by default */
+	u32 trgsens = STM32_MDF_TRGSENS_RISING_EDGE;
+	int ret;
+
+	if (trig) {
+		ret = stm32_mdf_adc_get_trig(indio_dev, trig);
+		if (ret < 0)
+			return ret;
+	}
+
+	dev_dbg(adc->dev, "Set trigger source [%d] on filter [%d]\n", trgsrc, adc->fl_id);
+
+	return regmap_update_bits(adc->regmap, MDF_DFLTCR_REG,
+				  MDF_DFLTCR_TRGSRC_MASK | MDF_DFLTCR_TRGSENS,
+				  MDF_DFLTCR_TRGSRC(trgsrc) | MDF_DFLTCR_TRGSENS_SET(trgsens));
+}
+
+static void stm32_mdf_adc_filter_clear_trig(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	regmap_update_bits(adc->regmap, MDF_DFLTCR_REG,
+			   MDF_DFLTCR_TRGSRC_MASK | MDF_DFLTCR_TRGSENS, 0);
+}
+
+static int stm32_mdf_adc_filter_set_mode(struct stm32_mdf_adc *adc, bool cont)
 {
 	struct stm32_mdf_adc *adc_inter;
-	struct stm32_mdf *mdf = adc->mdf;
+	struct iio_dev *indio_dev = dev_get_drvdata(adc->dev);
+	struct iio_trigger *trig = indio_dev->trig;
+	u32 mode;
+
+	if (MDF_IS_FILTER0(adc)) {
+		list_for_each_entry(adc_inter, &adc->mdf->filter_list, entry) {
+			if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter))
+				stm32_mdf_adc_filter_set_mode(adc_inter, cont);
+		}
+	}
+
+	if (adc->synced || MDF_IS_INTERLEAVED_FILT(adc) || trig) {
+		if (cont)
+			mode = STM32_MDF_ACQ_MODE_SYNC_CONT;
+		else
+			mode = STM32_MDF_ACQ_MODE_SYNC_SINGLE_SHOT;
+	} else {
+		if (cont)
+			mode = STM32_MDF_ACQ_MODE_ASYNC_CONT;
+		else
+			mode = STM32_MDF_ACQ_MODE_ASYNC_SINGLE_SHOT;
+	}
+
+	dev_dbg(adc->dev, "Set mode [0x%x] on filter [%d]\n", mode, adc->fl_id);
+
+	return regmap_update_bits(adc->regmap, MDF_DFLTCR_REG,
+				  MDF_DFLTCR_ACQMOD_MASK, MDF_DFLTCR_ACQMOD(mode));
+}
+
+static int stm32_mdf_adc_compute_scale(struct device *dev, unsigned int decim,
+				       unsigned int order, unsigned int data_size)
+{
+	unsigned long max = ARRAY_SIZE(stm32_mdf_log_table);
+	unsigned int prime_factors[16];
+	unsigned int num, div, logd;
+	int i, j, scale;
+
+	/* Decompose decimation ratio D, as prime number factors, to compute log10(D) */
+	j = 0;
+	num = decim;
+	while (num > 1) {
+		i = 0;
+		while (i < max) {
+			div = stm32_mdf_log_table[i].raw;
+			if (!(num % div)) {
+				prime_factors[j] = stm32_mdf_log_table[i].log;
+				num = num / div;
+				j++;
+				break;
+			}
+			i++;
+		}
+		if (i == max) {
+			dev_warn(dev, "Failed to set scale. Output signal may saturate.\n");
+			return 0;
+		}
+	}
+
+	for (i = 0; i < j; i++)
+		logd += prime_factors[i];
 
-	if (!adc->fl_id && mdf->nb_interleave) {
-		list_for_each_entry(adc_inter, &mdf->filter_list, entry) {
-			if (!adc_inter->interleaved)
-				continue;
+	/* scale = 20 * ((DS - 1) * log10(2) - NF * log10(D)) */
+	scale = 20 * ((data_size - 1) * stm32_mdf_log_table[0].log - order * logd);
 
-			regmap_clear_bits(adc_inter->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+	return scale;
+}
+
+static int stm32_mdf_adc_apply_filters_config(struct stm32_mdf_adc *adc, unsigned int scale)
+{
+	struct stm32_mdf_adc *adc_inter;
+	u32 msk, val;
+	int ret, cnt = 0;
+
+	/* Apply conf from filter0 to interleaved filters if any */
+	if (MDF_IS_FILTER0(adc) && adc->mdf->nb_interleave) {
+		list_for_each_entry(adc_inter, &adc->mdf->filter_list, entry) {
+			if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter)) {
+				adc_inter->datsrc = adc->datsrc;
+				adc_inter->cicmode = adc->cicmode;
+				adc_inter->decim_cic = adc->decim_cic;
+				adc_inter->hpf_cutoff = adc->hpf_cutoff;
+
+				stm32_mdf_adc_apply_filters_config(adc_inter, scale);
+				cnt++;
+			}
+		}
+		if (cnt != adc->mdf->nb_interleave - 1) {
+			dev_err(adc->dev, "Interleaved filter number [%d] / expected [%d]\n",
+				cnt, adc->mdf->nb_interleave - 1);
+			return -EINVAL;
 		}
 	}
 
-	regmap_clear_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+	/* Configure delay */
+	ret = regmap_update_bits(adc->regmap, MDF_DLYCR_REG, MDF_DLYCR_SKPDLY_MASK, adc->delay);
+	if (ret)
+		return ret;
+
+	/* Configure CICR */
+	msk = MDF_SITFCR_SCKSRC_MASK | MDF_DFLTCICR_CICMOD_MASK |
+	      MDF_DFLTCICR_MCICD_MASK | MDF_DFLTCICR_SCALE_MASK;
+	val = MDF_SITFCR_SCKSRC(adc->datsrc) | MDF_DFLTCICR_CICMOD(adc->cicmode) |
+	      MDF_DFLTCICR_MCICD(adc->decim_cic - 1) | MDF_DFLTCICR_SCALE(scale);
+
+	ret = regmap_update_bits(adc->regmap, MDF_DFLTCICR_REG, msk, val);
+	if (ret)
+		return ret;
+
+	/* Configure RSFR & HPF */
+	if (adc->hpf_cutoff == STM32_MDF_HPF_BYPASS)
+		val = MDF_DFLTRSFR_HPFBYP;
+	else
+		val = MDF_DFLTRSFR_HPFC(adc->hpf_cutoff);
+	val |= adc->rsflt_bypass ? MDF_DFLTRSFR_RSFLTBYP : 0;
+	msk = MDF_DFLTRSFR_RSFLTBYP | MDF_DFLTRSFR_HPFBYP | MDF_DFLTRSFR_HPFC_MASK;
+
+	return regmap_update_bits(adc->regmap, MDF_DFLTRSFR_REG, msk, val);
+}
+
+static int stm32_mdf_adc_set_filters_config(struct iio_dev *indio_dev, unsigned int decim)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct device *dev = &indio_dev->dev;
+	unsigned int decim_cic, decim_rsflt = 1;
+	unsigned int data_size = STM32_MDF_DATA_RES, order = adc->cicmode;
+	int i, log, scale, max_scale;
+
+	if (!adc->rsflt_bypass) {
+		decim_rsflt = 4;
+		data_size -= 2;
+
+		/* Check if total decimation factor is a multiple of reshape filter decimation */
+		if (decim % decim_rsflt) {
+			dev_err(dev, "Total decimation factor [%d] not multiple of [%d]\n",
+				decim, decim_rsflt);
+			return -EINVAL;
+		}
+	}
+
+	decim_cic = DIV_ROUND_CLOSEST(decim, decim_rsflt);
+	if (decim_cic < MDF_DFLTCICR_MCICD_MIN ||
+	    decim_cic > stm32_mdf_cic_max_decim_sitf[order]) {
+		dev_err(dev, "Decimation factor [%d] out of range for CIC filter order [%d]\n",
+			decim_cic, adc->cicmode);
+		return -EINVAL;
+	}
+
+	/*
+	 * Compute scaling:
+	 * max scale = 20 * log10( 2 exp DS / D exp NF )
+	 * - DS = max data size at scale output (RSFLT on: DS = 22 / RSFLT off: DS = 24)
+	 * - NF = Main CIC filter order
+	 */
+	if (is_power_of_2(decim_cic)) {
+		/*
+		 * Decimation ratio is a power of 2: D = 2 exp n
+		 * max scale = 20 * (DS - n * NF) * log10(2)
+		 */
+		log = stm32_mdf_log_table[0].log;
+
+		/* Compute max scale (dB) * 1000 */
+		max_scale = (20 * (data_size - 1 - (order * (fls(decim_cic) - 1))) * log);
+	} else {
+		/*
+		 * Decimation ratio is not a power of 2
+		 * max scale = 20 * ((DS - 1) * log10(2) - NF * log10(D))
+		 */
+		max_scale = stm32_mdf_adc_compute_scale(dev, decim_cic, order, data_size);
+	}
+
+	dev_dbg(dev, "Filter order [%d], decimation [%d], data size [%d], max scale [%d]\n",
+		order, decim_cic, data_size, max_scale / 1000);
+
+	/*
+	 * Find scale register setting.
+	 * Limit max_scale accuracy to first decimal for comparison with scale table values.
+	 */
+	max_scale = DIV_ROUND_CLOSEST(max_scale, 100);
+	i = ARRAY_SIZE(stm32_mdf_scale_table) - 1;
+	while (i > 0) {
+		if (stm32_mdf_scale_table[i].gain < max_scale)
+			break;
+		i--;
+	};
+	scale = stm32_mdf_scale_table[i].scale;
+	adc->decim_cic = decim_cic;
+
+	dev_dbg(dev, "Set scale to [%d] dB: [0x%x]\n", stm32_mdf_scale_table[i].gain / 10, scale);
+
+	return stm32_mdf_adc_apply_filters_config(adc, scale);
+}
+
+static int stm32_mdf_adc_check_clock_config(struct stm32_mdf_adc *adc, unsigned long sck_freq)
+{
+	unsigned int ratio;
+	unsigned int decim_ratio;
+
+	ratio = DIV_ROUND_CLOSEST(adc->mdf->fproc, sck_freq);
+	decim_ratio = DIV_ROUND_CLOSEST(24, adc->decim_cic);
+
+	if ((adc->sitf->mode == STM32_MDF_MODE_SPI && ratio <= 4) ||
+	    (adc->sitf->mode == STM32_MDF_MODE_LF_SPI && ratio <= 2))
+		goto err;
+
+	if (adc->rsflt_bypass && ratio <= decim_ratio)
+		goto err;
+
+	return 0;
+
+err:
+	dev_err(adc->dev, "Wrong Fproc/Fsck ratio [%d] for sitf mode [%d] with RSFLT [%s]\n",
+		ratio, adc->sitf->mode, adc->rsflt_bypass ? "off" : "on");
+
+	return -EINVAL;
+}
+
+static int mdf_adc_set_samp_freq(struct iio_dev *indio_dev,
+				 unsigned long sample_freq)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	unsigned int decim_ratio;
+	unsigned long delta, delta_ppm, sck_freq;
+	int ret;
+
+	sck_freq = clk_get_rate(adc->sitf->sck);
+	if (!sck_freq) {
+		dev_err(&indio_dev->dev, "Unexpected serial clock frequency: 0Hz\n");
+		return -EINVAL;
+	}
+
+	decim_ratio = DIV_ROUND_CLOSEST(sck_freq, sample_freq);
+
+	delta = abs(sck_freq - (decim_ratio * sample_freq));
+	delta_ppm = (1000000 * delta) / sck_freq;
+	if (delta_ppm > 1000)
+		dev_warn(&indio_dev->dev, "Sample rate deviation [%lu] ppm: [%lu] vs [%lu] Hz\n",
+			 delta_ppm, sck_freq / decim_ratio, sample_freq);
+	else if (delta)
+		dev_dbg(&indio_dev->dev, "Sample rate deviation [%lu] ppm: [%lu] vs [%lu] Hz\n",
+			delta_ppm, sck_freq / decim_ratio, sample_freq);
+
+	ret = stm32_mdf_adc_set_filters_config(indio_dev, decim_ratio);
+	if (ret < 0)
+		return ret;
+
+	ret = stm32_mdf_adc_check_clock_config(adc, sck_freq);
+	if (ret < 0)
+		return ret;
+
+	adc->sample_freq = DIV_ROUND_CLOSEST(sck_freq, decim_ratio);
+	adc->decim_ratio = decim_ratio;
+
+	return 0;
+}
+
+static int stm32_mdf_adc_start_mdf(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int ret;
+
+	ret = clk_prepare_enable(adc->sitf->sck);
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "Failed to enable clock %s\n",
+			__clk_get_name(adc->sitf->sck));
+		return ret;
+	}
+
+	ret = stm32_mdf_core_start_mdf(adc->mdf);
+	if (ret < 0)
+		clk_disable_unprepare(adc->sitf->sck);
+
+	return ret;
+}
+
+static void stm32_mdf_adc_stop_mdf(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	stm32_mdf_core_stop_mdf(adc->mdf);
+
+	clk_disable_unprepare(adc->sitf->sck);
 }
 
-static int stm32_mdf_start_conv(struct iio_dev *indio_dev)
+static int stm32_mdf_adc_start_conv(struct iio_dev *indio_dev)
 {
 	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
 	int ret;
@@ -354,12 +726,26 @@ static int stm32_mdf_start_conv(struct i
 	if (ret < 0)
 		return ret;
 
-	ret = stm32_mdf_start_filter(adc);
+	/*
+	 * In audio use cases the sampling frequency is always provided on stream startup.
+	 * In analog use cases the sampling frequency may not be already set in IIO sysfs.
+	 * Set a default frequency here, if frequency is not yet defined.
+	 * Note: The filters configuration is applied when the sampling frequency is set.
+	 * This involves that all the filters are already probed in interleaved case,
+	 * before setting the sampling frequency.
+	 */
+	if (!adc->sample_freq) {
+		ret = mdf_adc_set_samp_freq(indio_dev, MDF_DEFAULT_SAMPLING_FREQ);
+		if (ret < 0)
+			goto stop_sitf;
+	}
+
+	ret = stm32_mdf_adc_start_filter(adc);
 	if (ret < 0)
 		goto stop_sitf;
 
-	if (adc->trigger) {
-		ret = stm32_mdf_trigger(adc->mdf);
+	if (adc->trgo) {
+		ret = stm32_mdf_core_trigger(adc->mdf);
 		if (ret < 0)
 			goto stop_filter;
 	}
@@ -367,18 +753,18 @@ static int stm32_mdf_start_conv(struct i
 	return 0;
 
 stop_filter:
-	stm32_mdf_stop_filter(adc);
+	stm32_mdf_adc_stop_filter(adc);
 stop_sitf:
 	stm32_mdf_sitf_stop(adc->sitf);
 
 	return ret;
 }
 
-static void stm32_mdf_stop_conv(struct iio_dev *indio_dev)
+static void stm32_mdf_adc_stop_conv(struct iio_dev *indio_dev)
 {
 	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
 
-	stm32_mdf_stop_filter(adc);
+	stm32_mdf_adc_stop_filter(adc);
 
 	stm32_mdf_sitf_stop(adc->sitf);
 }
@@ -406,7 +792,7 @@ static unsigned int stm32_mdf_adc_dma_re
 	return 0;
 }
 
-static void stm32_mdf_dma_buffer_done(void *data)
+static void stm32_mdf_adc_dma_buffer_done(void *data)
 {
 	struct iio_dev *indio_dev = data;
 	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
@@ -417,7 +803,7 @@ static void stm32_mdf_dma_buffer_done(vo
 	old_pos = adc->bufi;
 
 	while (available >= indio_dev->scan_bytes) {
-		available -= indio_dev->scan_bytes;
+		s32 *buffer = (s32 *)&adc->rx_buf[adc->bufi];
 		adc->bufi += indio_dev->scan_bytes;
 		if (adc->bufi >= adc->buf_sz) {
 			if (adc->cb)
@@ -425,6 +811,9 @@ static void stm32_mdf_dma_buffer_done(vo
 			adc->bufi = 0;
 			old_pos = 0;
 		}
+		if (adc->dev_data->type == STM32_MDF_IIO)
+			iio_push_to_buffers(indio_dev, buffer);
+		available -= indio_dev->scan_bytes;
 	}
 	if (adc->cb)
 		adc->cb(&adc->rx_buf[old_pos], adc->bufi - old_pos, adc->cb_priv);
@@ -434,7 +823,7 @@ static int stm32_mdf_adc_dma_start(struc
 {
 	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
 	struct dma_slave_config config = {
-		.src_addr = (dma_addr_t)adc->phys_addr + MDF_DLTDR_REG,
+		.src_addr = (dma_addr_t)adc->phys_addr + MDF_DFLTDR_REG,
 		.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,
 	};
 	struct dma_async_tx_descriptor *desc;
@@ -456,7 +845,7 @@ static int stm32_mdf_adc_dma_start(struc
 	if (!desc)
 		return -EBUSY;
 
-	desc->callback = stm32_mdf_dma_buffer_done;
+	desc->callback = stm32_mdf_adc_dma_buffer_done;
 	desc->callback_param = indio_dev;
 
 	ret = dma_submit_error(dmaengine_submit(desc));
@@ -474,7 +863,7 @@ static int stm32_mdf_adc_dma_start(struc
 	return 0;
 
 err_stop_dma:
-	dmaengine_terminate_all(adc->dma_chan);
+	dmaengine_terminate_sync(adc->dma_chan);
 
 	return ret;
 }
@@ -488,10 +877,10 @@ static void stm32_mdf_adc_dma_stop(struc
 
 	regmap_clear_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DMAEN);
 
-	dmaengine_terminate_all(adc->dma_chan);
+	dmaengine_terminate_sync(adc->dma_chan);
 }
 
-static int stm32_mdf_postenable(struct iio_dev *indio_dev)
+static int stm32_mdf_adc_postenable(struct iio_dev *indio_dev)
 {
 	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
 	int ret;
@@ -499,20 +888,14 @@ static int stm32_mdf_postenable(struct i
 	/* Reset adc buffer index */
 	adc->bufi = 0;
 
-	ret = stm32_mdf_start_mdf(adc->mdf);
+	ret = stm32_mdf_adc_start_mdf(indio_dev);
 	if (ret < 0)
 		return ret;
 
-	/* Enable CCKx clock if configured as output */
-	ret = clk_prepare_enable(adc->sitf->sck);
-	if (ret < 0) {
-		dev_err(&indio_dev->dev, "Failed to enable clock %s\n",
-			__clk_get_name(adc->sitf->sck));
-		goto err_stop_mdf;
-	}
+	stm32_mdf_adc_filter_set_mode(adc, true);
 
-	regmap_set_bits(adc->regmap, MDF_DFLTISR_REG,
-			MDF_DFLTISR_DOVRF_MASK | MDF_DFLTISR_SATF_MASK);
+	regmap_clear_bits(adc->regmap, MDF_DFLTISR_REG,
+			  MDF_DFLTISR_DOVRF_MASK | MDF_DFLTISR_SATF_MASK);
 
 	regmap_set_bits(adc->regmap, MDF_DFLTIER_REG,
 			MDF_DFLTIER_DOVRIE_MASK | MDF_DFLTIER_SATIE_MASK);
@@ -520,49 +903,52 @@ static int stm32_mdf_postenable(struct i
 	ret = stm32_mdf_adc_dma_start(indio_dev);
 	if (ret) {
 		dev_err(&indio_dev->dev, "Can't start DMA\n");
-		goto err_stop_clk;
+		goto err_dma;
 	}
 
-	ret = stm32_mdf_start_conv(indio_dev);
+	ret = stm32_mdf_adc_filter_set_trig(indio_dev);
+	if (ret < 0)
+		goto err_trig;
+
+	ret = stm32_mdf_adc_start_conv(indio_dev);
 	if (ret) {
 		dev_err(&indio_dev->dev, "Can't start conversion\n");
-		goto err_stop_dma;
+		goto err_conv;
 	}
 
 	return 0;
 
-err_stop_dma:
+err_conv:
+	stm32_mdf_adc_filter_clear_trig(indio_dev);
+err_trig:
 	stm32_mdf_adc_dma_stop(indio_dev);
-err_stop_clk:
-	clk_disable_unprepare(adc->sitf->sck);
-err_stop_mdf:
-	stm32_mdf_stop_mdf(adc->mdf);
+err_dma:
+	stm32_mdf_adc_stop_mdf(indio_dev);
 
 	return ret;
 }
 
-static int stm32_mdf_predisable(struct iio_dev *indio_dev)
+static int stm32_mdf_adc_predisable(struct iio_dev *indio_dev)
 {
 	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
 
-	stm32_mdf_stop_conv(indio_dev);
+	stm32_mdf_adc_stop_conv(indio_dev);
+
+	stm32_mdf_adc_filter_clear_trig(indio_dev);
 
 	stm32_mdf_adc_dma_stop(indio_dev);
 
 	regmap_clear_bits(adc->regmap, MDF_DFLTIER_REG,
 			  MDF_DFLTIER_DOVRIE_MASK | MDF_DFLTIER_SATIE_MASK);
 
-	/* Disable CCKx clock if configured as output */
-	clk_disable_unprepare(adc->sitf->sck);
-
-	stm32_mdf_stop_mdf(adc->mdf);
+	stm32_mdf_adc_stop_mdf(indio_dev);
 
 	return 0;
 }
 
 static const struct iio_buffer_setup_ops stm32_mdf_buffer_setup_ops = {
-	.postenable = &stm32_mdf_postenable,
-	.predisable = &stm32_mdf_predisable,
+	.postenable = &stm32_mdf_adc_postenable,
+	.predisable = &stm32_mdf_adc_predisable,
 };
 
 static void stm32_mdf_dma_release(struct iio_dev *indio_dev)
@@ -579,12 +965,12 @@ static void stm32_mdf_dma_release(struct
 static int stm32_mdf_dma_request(struct device *dev, struct iio_dev *indio_dev)
 {
 	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct dma_chan *dma_chan;
 
-	adc->dma_chan = dma_request_chan(dev, "rx");
-	if (IS_ERR(adc->dma_chan)) {
-		adc->dma_chan = NULL;
-		return PTR_ERR(adc->dma_chan);
-	}
+	dma_chan = dma_request_chan(dev, "rx");
+	if (IS_ERR(dma_chan))
+		return PTR_ERR(dma_chan) ? PTR_ERR(dma_chan) : -ENODEV;
+	adc->dma_chan = dma_chan;
 
 	adc->rx_buf = dma_alloc_coherent(adc->dma_chan->device->dev,
 					 MDF_DMA_BUFFER_SIZE, &adc->dma_buf, GFP_KERNEL);
@@ -599,273 +985,142 @@ static int stm32_mdf_dma_request(struct
 	return 0;
 }
 
-static int stm32_mdf_adc_chan_init_one(struct iio_dev *indio_dev,
-				       struct iio_chan_spec *ch)
+static int stm32_mdf_channel_parse_of(struct iio_dev *indio_dev, struct fwnode_handle *node,
+				      struct iio_chan_spec *ch)
 {
-	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
-
-	ch->type = IIO_VOLTAGE;
-	ch->indexed = 1;
-	ch->channel = adc->fl_id;
+	int ret;
 
-	ch->scan_type.sign = 's';
-	ch->scan_type.realbits = STM32_MDF_DATA_RES;
-	ch->scan_type.storagebits = 32;
+	ret = fwnode_property_read_u32(node, "reg", &ch->channel);
+	if (ret < 0)
+		dev_err(&indio_dev->dev, "Missing channel index %d\n", ret);
 
-	return 0;
+	return ret;
 }
 
-static int stm32_mdf_audio_init(struct device *dev, struct iio_dev *indio_dev)
+static int stm32_mdf_adc_chan_init_one(struct iio_dev *indio_dev, struct fwnode_handle *node,
+				       struct iio_chan_spec *ch, int idx)
 {
-	struct iio_chan_spec *ch;
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
 	int ret;
 
-	ch = devm_kzalloc(&indio_dev->dev, sizeof(*ch), GFP_KERNEL);
-	if (!ch)
-		return -ENOMEM;
-
-	ret = stm32_mdf_adc_chan_init_one(indio_dev, ch);
-	if (ret < 0) {
-		dev_err(&indio_dev->dev, "Channels init failed\n");
-		return ret;
+	if (adc->dev_data->type == STM32_MDF_IIO) {
+		ret = stm32_mdf_channel_parse_of(indio_dev, node, ch);
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "Failed to parse channel [%d]\n", idx);
+			return ret;
+		}
 	}
-	ch->info_mask_separate = BIT(IIO_CHAN_INFO_SAMP_FREQ);
 
-	indio_dev->num_channels = 1;
-	indio_dev->channels = ch;
+	ch->type = IIO_VOLTAGE;
+	ch->indexed = 1;
+	ch->scan_index = idx;
 
-	ret = stm32_mdf_dma_request(dev, indio_dev);
-	if (ret) {
-		dev_err(&indio_dev->dev, "Failed to get dma: %d\n", ret);
-		return ret;
-	}
+	ch->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	ch->info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ);
+	ch->scan_type.sign = 's';
+	if (adc->dev_data->type == STM32_MDF_IIO)
+		ch->scan_type.shift = 8;
+	ch->scan_type.realbits = STM32_MDF_DATA_RES;
+	ch->scan_type.storagebits = 32;
 
 	return 0;
 }
 
-static int stm32_mdf_compute_scale(struct device *dev, unsigned int decim,
-				   unsigned int order, unsigned int data_size)
+static int stm32_mdf_adc_chan_init(struct iio_dev *indio_dev, struct iio_chan_spec *channels)
 {
-	unsigned long max = ARRAY_SIZE(stm32_mdf_log_table);
-	unsigned int prime_factors[16];
-	unsigned int num, div, logd = 0;
-	int i, j, scale;
+	struct fwnode_handle *child;
+	int chan_idx = 0, ret;
 
-	/* Decompose decimation ratio D, as prime number factors, to compute log10(D) */
-	j = 0;
-	num = decim;
-	while (num > 1) {
-		i = 0;
-		while (i < max) {
-			div = stm32_mdf_log_table[i].raw;
-			if (!(num % div)) {
-				prime_factors[j] = stm32_mdf_log_table[i].log;
-				num = num / div;
-				j++;
-				break;
-			}
-			i++;
-		}
-		if (i == max) {
-			dev_warn(dev, "Failed to set scale. Output signal may saturate.\n");
-			return 0;
+	device_for_each_child_node(indio_dev->dev.parent, child) {
+		ret = stm32_mdf_adc_chan_init_one(indio_dev, child, &channels[chan_idx], chan_idx);
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "Channels [%d] init failed\n", chan_idx);
+			goto err;
 		}
+
+		chan_idx++;
 	}
 
-	for (i = 0; i < j; i++)
-		logd += prime_factors[i];
+	return chan_idx;
 
-	/* scale = 20 * ((DS - 1) * log10(2) - NF * log10(D)) */
-	scale = 20 * ((data_size - 1) * stm32_mdf_log_table[0].log - order * logd);
+err:
+	fwnode_handle_put(child);
 
-	return scale;
+	return ret;
 }
 
-static int stm32_mdf_config_filter(struct iio_dev *indio_dev, unsigned int decim)
+static int stm32_mdf_set_watermark(struct iio_dev *indio_dev, unsigned int val)
 {
-	struct stm32_mdf_adc *adc = iio_priv(indio_dev), *adc_inter;
-	struct stm32_mdf *mdf = adc->mdf;
-	struct device *dev = &indio_dev->dev;
-	unsigned int decim_cic, decim_rsflt = 1;
-	unsigned int data_size = STM32_MDF_DATA_RES, order = adc->cicmode;
-	int i, log, ret, scale, max_scale;
-
-	if (!adc->rsflt_bypass) {
-		decim_rsflt = 4;
-		data_size -= 2;
-
-		/* Check if total decimation factor is a multiple of reshape filter decimation */
-		if (decim % decim_rsflt) {
-			dev_err(dev, "Total decimation factor [%d] not multiple of [%d]\n",
-				decim, decim_rsflt);
-			return -EINVAL;
-		}
-	}
-
-	decim_cic = DIV_ROUND_CLOSEST(decim, decim_rsflt);
-	if (decim_cic < MDF_DFLTCICR_MCICD_MIN ||
-	    decim_cic > stm32_mdf_cic_max_decim_sitf[order]) {
-		dev_err(dev, "Decimation factor [%d] out of range for CIC filter order [%d]\n",
-			decim_cic, adc->cicmode);
-		return -EINVAL;
-	}
-
-	/*
-	 * Compute scaling:
-	 * max scale = 20 * log10( 2 exp DS / D exp NF )
-	 * - DS = max data size at scale output (RSFLT on: DS = 22 / RSFLT off: DS = 24)
-	 * - NF = Main CIC filter order
-	 */
-	if (is_power_of_2(decim_cic)) {
-		/*
-		 * Decimation ratio is a power of 2: D = 2 exp n
-		 * max scale = 20 * (DS - n * NF) * log10(2)
-		 */
-		log = stm32_mdf_log_table[0].log;
-
-		/* Compute max scale (dB) * 1000 */
-		max_scale = (20 * (data_size - 1 - (order * (fls(decim_cic) - 1))) * log);
-	} else {
-		/*
-		 * Decimation ratio is not a power of 2
-		 * max scale = 20 * ((DS - 1) * log10(2) - NF * log10(D))
-		 */
-		max_scale = stm32_mdf_compute_scale(dev, decim_cic, order, data_size);
-	}
-
-	dev_dbg(dev, "Filter order [%d], decimation [%d], data size [%d], max scale [%d]\n",
-		order, decim_cic, data_size, max_scale / 1000);
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	unsigned int watermark = MDF_DMA_BUFFER_SIZE / 2;
+	unsigned int rx_buf_sz = MDF_DMA_BUFFER_SIZE;
 
 	/*
-	 * Find scale register setting.
-	 * Limit max_scale accuracy to first decimal for comparison with scale table values.
+	 * DMA cyclic transfers are used, buffer is split into two periods.
+	 * There should be :
+	 * - always one buffer (period) DMA is working on
+	 * - one buffer (period) driver pushed to ASoC side.
 	 */
-	max_scale = DIV_ROUND_CLOSEST(max_scale, 100);
-	i = ARRAY_SIZE(stm32_mdf_scale_table) - 1;
-	while (i > 0) {
-		if (stm32_mdf_scale_table[i].gain < max_scale)
-			break;
-		i--;
-	};
-	scale = stm32_mdf_scale_table[i].scale;
-	adc->decim_cic = decim_cic;
-
-	dev_dbg(dev, "Set scale to [%d] dB: [0x%x]\n", stm32_mdf_scale_table[i].gain / 10, scale);
-
-	/* Configure CICR */
-	ret = regmap_update_bits(adc->regmap, MDF_DFLTCICR_REG,
-				 MDF_DFLTCICR_MCICD_MASK | MDF_DFLTCICR_SCALE_MASK,
-				 MDF_DFLTCICR_MCICD(decim_cic - 1) | MDF_DFLTCICR_SCALE(scale));
-	if (ret)
-		return ret;
-
-	/* If not filter 0, no need to check interleave. leave now */
-	if (adc->fl_id)
-		return 0;
-
-	/* Apply conf to interleaved filters if any */
-	for (i = 1; i < mdf->nb_interleave; i++) {
-		adc_inter = stm32_mdf_get_filter_by_id(mdf, i);
-		if (!adc_inter) {
-			dev_err(dev, "Filter [%d] not registered\n", i);
-			return -EINVAL;
-		}
-
-		ret = regmap_update_bits(adc_inter->regmap, MDF_DFLTCICR_REG,
-					 MDF_DFLTCICR_MCICD_MASK | MDF_DFLTCICR_SCALE_MASK,
-					 MDF_DFLTCICR_MCICD(decim_cic - 1) |
-					 MDF_DFLTCICR_SCALE(scale));
-		if (ret)
-			return ret;
-	}
+	watermark = min(watermark, val * (unsigned int)(sizeof(u32)));
+	adc->buf_sz = min(rx_buf_sz, watermark * 2);
 
 	return 0;
 }
 
-static int stm32_mdf_check_clock_config(struct stm32_mdf_adc *adc, unsigned long sck_freq)
-{
-	unsigned int ratio;
-	unsigned int decim_ratio;
-
-	ratio = DIV_ROUND_CLOSEST(adc->mdf->fproc, sck_freq);
-	decim_ratio = DIV_ROUND_CLOSEST(24, adc->decim_cic);
-
-	if ((adc->sitf->mode == STM32_MDF_MODE_SPI && ratio <= 4) ||
-	    (adc->sitf->mode == STM32_MDF_MODE_LF_SPI && ratio <= 2))
-		goto err;
-
-	if (adc->rsflt_bypass && ratio <= decim_ratio)
-		goto err;
-
-	return 0;
-
-err:
-	dev_err(adc->dev, "Wrong Fproc/Fsck ratio [%d] for sitf mode [%d] with RSFLT [%s]\n",
-		ratio, adc->sitf->mode, adc->rsflt_bypass ? "off" : "on");
-
-	return -EINVAL;
-}
-
-static int mdf_adc_set_samp_freq(struct iio_dev *indio_dev,
-				 unsigned long sample_freq)
+static int stm32_mdf_adc_single_conv(struct iio_dev *indio_dev,
+				     const struct iio_chan_spec *chan, int *res)
 {
 	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
-	unsigned int decim_ratio;
-	unsigned long delta, delta_ppm, sck_freq;
+	long timeout;
 	int ret;
 
-	sck_freq = clk_get_rate(adc->sitf->sck);
-	if (!sck_freq) {
-		dev_err(&indio_dev->dev, "Unexpected serial clock frequency: 0Hz\n");
-		return -EINVAL;
-	}
-
-	decim_ratio = DIV_ROUND_CLOSEST(sck_freq, sample_freq);
+	reinit_completion(&adc->completion);
 
-	delta = abs(sck_freq - (decim_ratio * sample_freq));
-	delta_ppm = (1000000 * delta) / sck_freq;
-	if (delta_ppm > 1000)
-		dev_warn(&indio_dev->dev, "Sample rate deviation [%lu] ppm: [%lu] vs [%lu] Hz\n",
-			 delta_ppm, sck_freq / decim_ratio, sample_freq);
-	else if (delta)
-		dev_dbg(&indio_dev->dev, "Sample rate deviation [%lu] ppm: [%lu] vs [%lu] Hz\n",
-			delta_ppm, sck_freq / decim_ratio, sample_freq);
-
-	ret = stm32_mdf_config_filter(indio_dev, decim_ratio);
+	ret = stm32_mdf_adc_start_mdf(indio_dev);
 	if (ret < 0)
 		return ret;
 
-	ret = stm32_mdf_check_clock_config(adc, sck_freq);
+	ret = regmap_update_bits(adc->regmap, MDF_DFLTIER_REG,
+				 MDF_DFLTIER_FTHIE_MASK, MDF_DFLTIER_FTHIE_MASK);
 	if (ret < 0)
-		return ret;
+		goto err_conv;
 
-	adc->sample_freq = sck_freq / decim_ratio;
-	adc->decim_ratio = decim_ratio;
+	stm32_mdf_adc_filter_set_mode(adc, false);
 
-	return 0;
-}
+	ret = stm32_mdf_adc_start_conv(indio_dev);
+	if (ret < 0) {
+		regmap_update_bits(adc->regmap, MDF_DFLTIER_REG, MDF_DFLTIER_FTHIE_MASK, 0);
+		goto err_conv;
+	}
 
-static int stm32_mdf_set_watermark(struct iio_dev *indio_dev, unsigned int val)
-{
-	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
-	unsigned int watermark = MDF_DMA_BUFFER_SIZE / 2;
-	unsigned int rx_buf_sz = MDF_DMA_BUFFER_SIZE;
+	timeout = wait_for_completion_interruptible_timeout(&adc->completion, STM32_MDF_TIMEOUT_MS);
 
-	/*
-	 * DMA cyclic transfers are used, buffer is split into two periods.
-	 * There should be :
-	 * - always one buffer (period) DMA is working on
-	 * - one buffer (period) driver pushed to ASoC side.
-	 */
-	watermark = min(watermark, val * (unsigned int)(sizeof(u32)));
-	adc->buf_sz = min(rx_buf_sz, watermark * 2);
+	regmap_update_bits(adc->regmap, MDF_DFLTIER_REG, MDF_DFLTIER_FTHIE_MASK, 0);
 
-	return 0;
+	if (timeout == 0) {
+		dev_err(&indio_dev->dev, "Timeout reached on channel [%d]", chan->channel);
+		ret = -ETIMEDOUT;
+	} else if (timeout < 0) {
+		ret = timeout;
+	} else {
+		ret = IIO_VAL_INT;
+	}
+
+	if (MDF_IS_INTERLEAVED_FILT(adc))
+		*res = adc->buffer[chan->channel];
+	else
+		*res = adc->buffer[0];
+
+	stm32_mdf_adc_stop_conv(indio_dev);
+
+err_conv:
+	stm32_mdf_adc_stop_mdf(indio_dev);
+
+	return ret;
 }
 
-static int stm32_mdf_write_raw(struct iio_dev *indio_dev,
-			       struct iio_chan_spec const *chan, int val,
-			       int val2, long mask)
+static int stm32_mdf_adc_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,
+				   int val, int val2, long mask)
 {
 	int ret;
 
@@ -887,13 +1142,23 @@ static int stm32_mdf_write_raw(struct ii
 	return -EINVAL;
 }
 
-static int stm32_mdf_read_raw(struct iio_dev *indio_dev,
-			      struct iio_chan_spec const *chan, int *val,
-			      int *val2, long mask)
+static int stm32_mdf_adc_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,
+				  int *val, int *val2, long mask)
 {
 	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int ret;
 
 	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+
+		ret = stm32_mdf_adc_single_conv(indio_dev, chan, val);
+
+		iio_device_release_direct_mode(indio_dev);
+		return IIO_VAL_INT;
+
 	case IIO_CHAN_INFO_SAMP_FREQ:
 		*val = adc->sample_freq;
 
@@ -905,15 +1170,23 @@ static int stm32_mdf_read_raw(struct iio
 
 static const struct iio_info stm32_mdf_info_audio = {
 	.hwfifo_set_watermark = stm32_mdf_set_watermark,
-	.write_raw = stm32_mdf_write_raw,
-	.read_raw = stm32_mdf_read_raw,
+	.write_raw = stm32_mdf_adc_write_raw,
+	.read_raw = stm32_mdf_adc_read_raw,
+};
+
+static const struct iio_info stm32_mdf_info_adc = {
+	.hwfifo_set_watermark = stm32_mdf_set_watermark,
+	.write_raw = stm32_mdf_adc_write_raw,
+	.read_raw = stm32_mdf_adc_read_raw,
+	.validate_trigger = stm32_mdf_adc_get_trig,
 };
 
 static irqreturn_t stm32_mdf_irq(int irq, void *arg)
 {
 	struct iio_dev *indio_dev = arg;
-	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev), *adc_inter;
 	struct regmap *regmap = adc->regmap;
+	u32 *ptr = adc->buffer;
 	u32 isr, ier, flags;
 
 	regmap_read(regmap, MDF_DFLTISR_REG, &isr);
@@ -923,6 +1196,18 @@ static irqreturn_t stm32_mdf_irq(int irq
 	if (!flags)
 		return IRQ_NONE;
 
+	if (flags & MDF_DFLTISR_FTHF_MASK) {
+		/* Reading the data register clear the IRQ status */
+		regmap_read(regmap, MDF_DFLTDR_REG, ptr++);
+
+		if (MDF_IS_FILTER0(adc))
+			list_for_each_entry(adc_inter, &adc->mdf->filter_list, entry)
+				if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter))
+					regmap_read(regmap, MDF_DFLTDR_REG, ptr++);
+
+		complete(&adc->completion);
+	}
+
 	if (flags & MDF_DFLTISR_DOVRF_MASK) {
 		dev_warn(&indio_dev->dev, "Data overflow detected\n");
 		regmap_set_bits(regmap, MDF_DFLTISR_REG, MDF_DFLTISR_DOVRF_MASK);
@@ -944,6 +1229,104 @@ static irqreturn_t stm32_mdf_irq(int irq
 	return IRQ_HANDLED;
 }
 
+static int stm32_mdf_audio_init(struct device *dev, struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct iio_chan_spec *ch;
+	int ret;
+
+	ch = devm_kzalloc(&indio_dev->dev, sizeof(*ch), GFP_KERNEL);
+	if (!ch)
+		return -ENOMEM;
+
+	ret = stm32_mdf_adc_chan_init(indio_dev, ch);
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "Channels init failed\n");
+		return ret;
+	}
+	indio_dev->num_channels = 1;
+	indio_dev->channels = ch;
+
+	ret = stm32_mdf_dma_request(dev, indio_dev);
+	if (ret) {
+		dev_err(&indio_dev->dev, "Failed to get dma: %d\n", ret);
+		return ret;
+	}
+
+	ret =  stm32_mdf_adc_filter_set_mode(adc, true);
+	if (ret)
+		stm32_mdf_dma_release(indio_dev);
+
+	return ret;
+}
+
+static int stm32_mdf_adc_init(struct device *dev, struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct iio_chan_spec *ch = NULL;
+	unsigned int num_ch;
+	int ret;
+
+	num_ch = device_get_child_node_count(indio_dev->dev.parent);
+	if (num_ch) {
+		/* Filter0 may have several channels in interleaved mode */
+		if (num_ch > 1) {
+			if (!MDF_IS_FILTER0(adc)) {
+				dev_err(dev, "Too many channels for filter [%d]\n", adc->fl_id);
+				return -EINVAL;
+			} else if (num_ch != adc->mdf->nb_interleave) {
+				dev_err(dev, "Unexpected channels number for filter0: [%d]\n",
+					num_ch);
+				return -EINVAL;
+			}
+		}
+
+		ch = devm_kzalloc(&indio_dev->dev, num_ch * sizeof(*ch), GFP_KERNEL);
+		if (!ch)
+			return -ENOMEM;
+
+		ret = stm32_mdf_adc_chan_init(indio_dev, ch);
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "Channels init failed\n");
+			return ret;
+		}
+	}
+
+	indio_dev->num_channels = num_ch;
+	indio_dev->channels = ch;
+
+	init_completion(&adc->completion);
+
+	/* Optionally request DMA */
+	ret = stm32_mdf_dma_request(dev, indio_dev);
+	if (ret) {
+		if (ret != -ENODEV)
+			return dev_err_probe(dev, ret, "DMA channel request failed with\n");
+
+		dev_dbg(dev, "No DMA support\n");
+		return 0;
+	}
+
+	ret = iio_triggered_buffer_setup(indio_dev,
+					 &iio_pollfunc_store_time, NULL,
+					 &stm32_mdf_buffer_setup_ops);
+	if (ret) {
+		stm32_mdf_dma_release(indio_dev);
+		dev_err(&indio_dev->dev, "buffer setup failed\n");
+		return ret;
+	}
+
+	/* lptimer/timer hardware triggers */
+	indio_dev->modes |= INDIO_HARDWARE_TRIGGERED;
+
+	return 0;
+}
+
+static const struct stm32_mdf_dev_data stm32h7_mdf_adc_data = {
+	.type = STM32_MDF_IIO,
+	.init = stm32_mdf_adc_init,
+};
+
 static const struct stm32_mdf_dev_data stm32_mdf_audio_data = {
 	.type = STM32_MDF_AUDIO,
 	.init = stm32_mdf_audio_init,
@@ -1004,6 +1387,10 @@ EXPORT_SYMBOL_GPL(stm32_mdf_release_buff
 
 static const struct of_device_id stm32_mdf_adc_match[] = {
 	{
+		.compatible = "st,stm32mp25-mdf-adc",
+		.data = &stm32h7_mdf_adc_data,
+	},
+	{
 		.compatible = "st,stm32mp25-mdf-dmic",
 		.data = &stm32_mdf_audio_data,
 	},
@@ -1032,7 +1419,7 @@ static int stm32_mdf_get_sitf(struct dev
 	return 0;
 }
 
-static int stm32_mdf_get_filter_config(struct device *dev, struct stm32_mdf_adc *adc)
+static int stm32_mdf_get_filters_config(struct device *dev, struct stm32_mdf_adc *adc)
 {
 	int i, ret;
 	u32 val;
@@ -1067,8 +1454,8 @@ static int stm32_mdf_get_filter_config(s
 		}
 	}
 
-	dev_dbg(dev, "Filter [%d] config: rsflt [%s], hpf [%s]\n", adc->fl_id,
-		adc->rsflt_bypass ? "off" : "on",
+	dev_dbg(dev, "Filter [%d] config: cic mode [%d], rsflt [%s], hpf [%s]\n", adc->fl_id,
+		adc->cicmode, adc->rsflt_bypass ? "off" : "on",
 		adc->hpf_cutoff == STM32_MDF_HPF_BYPASS ? "off" : "on");
 
 	return 0;
@@ -1077,13 +1464,12 @@ static int stm32_mdf_get_filter_config(s
 static int stm32_mdf_adc_parse_of(struct platform_device *pdev, struct stm32_mdf_adc *adc)
 {
 	struct device *dev = &pdev->dev;
-	struct stm32_mdf_adc *adc0, *adcm;
+	struct stm32_mdf_adc *adcm;
 	struct fwnode_handle *sitf_node;
 	struct fwnode_handle *filt_node;
 	struct fwnode_reference_args args;
-	int i, ret, stream;
-	u32 datsrc, bsmx;
-	u32 idx, cicr_msk, cicr, rsfr, rsfr_msk, val;
+	int i, ret, stream, buf_size = 1;
+	u32 idx, bsmx, val;
 
 	ret = device_property_read_u32(dev, "reg", &idx);
 	if (ret) {
@@ -1109,23 +1495,14 @@ static int stm32_mdf_adc_parse_of(struct
 			dev_err(dev, "Failed to get filter sync handle %ld\n", PTR_ERR(filt_node));
 			return PTR_ERR(filt_node);
 		}
+		adc->synced = true;
 
 		adcm = stm32_mdf_get_filter_by_handle(adc->mdf, filt_node);
 		if (!adcm)
 			return dev_err_probe(dev, -EPROBE_DEFER, "Failed to get filter synchro\n");
 
-		/* Syncho master filter is the TRGO trigger source */
-		adcm->trigger = true;
-
-		/* Configure synchro master filter */
-		ret = regmap_update_bits(adcm->regmap, MDF_DFLTCR_REG,
-					 MDF_DFLTCR_ACQMOD_MASK | MDF_DFLTCR_TRGSRC_MASK,
-					 MDF_DFLTCR_ACQMOD(STM32_MDF_ACQ_MODE_SYNC_CONT) |
-					 MDF_DFLTCR_TRGSRC(STM32_MDF_TRGSRC_TRGO));
-		if (ret)
-			return ret;
-
-		adc->sync = STM32_MDF_ACQ_MODE_SYNC_CONT;
+		/* The Synchronized master filter is the TRGO trigger source */
+		adcm->trgo = true;
 	}
 
 	if (device_property_present(&pdev->dev, "st,delay")) {
@@ -1138,11 +1515,10 @@ static int stm32_mdf_adc_parse_of(struct
 	}
 
 	/*
-	 * If nb_interleave is set to "n" not null, the filters in range [1..n] share their
-	 * configuration with filter 0. In this case copy config from filter 0,
-	 * instead of parsing DT.
+	 * In interleave mode the filters in range [1..n] share their configuration with filter 0.
+	 * In this case, use config from filter 0, instead of parsing DT.
 	 */
-	if (adc->fl_id && adc->fl_id < adc->mdf->nb_interleave) {
+	if (!MDF_IS_FILTER0(adc) && adc->fl_id < adc->mdf->nb_interleave) {
 		/* Check if filter is in interleave filter list */
 		for (i = 0; i < adc->mdf->nb_interleave; i++) {
 			if (adc->mdf->fh_interleave[i] == adc->node) {
@@ -1155,25 +1531,23 @@ static int stm32_mdf_adc_parse_of(struct
 			dev_err(dev, "Filter [%d] not in interleave property\n", adc->fl_id);
 			return -EINVAL;
 		}
-
-		/* For interleaved channels, copy filter config from filter 0 */
-		adc0 = stm32_mdf_get_filter_by_id(adc->mdf, 0);
-		if (!adc0)
-			return -EPROBE_DEFER;
-
-		adc->cicmode = adc0->cicmode;
-		adc->rsflt_bypass = adc0->rsflt_bypass;
-		adc->hpf_cutoff = adc0->hpf_cutoff;
 	} else {
-		ret = stm32_mdf_get_filter_config(dev, adc);
+		ret = stm32_mdf_get_filters_config(dev, adc);
 		if (ret)
 			return ret;
 
-		/* Filter 0 is the TRGO trigger source in interleave mode */
-		if (!adc->fl_id && adc->mdf->nb_interleave)
-			adc->trigger = true;
+		if (MDF_IS_FILTER0(adc) && adc->mdf->nb_interleave) {
+			/* Filter 0 is the TRGO trigger source in interleave mode */
+			adc->trgo = true;
+			adc->interleaved = true;
+			buf_size = adc->mdf->nb_interleave;
+		}
 	}
 
+	adc->buffer = kcalloc(buf_size, sizeof(u32), GFP_KERNEL);
+	if (!adc->buffer)
+		return -ENOMEM;
+
 	/* Retrieve serial interface */
 	ret = fwnode_property_get_reference_args(dev_fwnode(dev), "st,sitf", NULL, 1, 0, &args);
 	if (ret) {
@@ -1196,44 +1570,13 @@ static int stm32_mdf_adc_parse_of(struct
 
 	bsmx = adc->sitf->id * 2 + stream;
 
-	dev_dbg(dev, "Digital filter [%d] linked to sitf [%d]\n",
-		adc->fl_id, adc->sitf->id);
+	dev_dbg(dev, "Digital filter [%d] linked to sitf [%d]\n", adc->fl_id, adc->sitf->id);
 
 	/* Only support BSMX filter source right now */
-	datsrc = STM32_MDF_DATSRC_BSMX;
+	adc->datsrc = STM32_MDF_DATSRC_BSMX;
 
 	list_add(&adc->entry, &adc->mdf->filter_list);
 
-	/* Configure CICR */
-	cicr_msk = MDF_DFLTCICR_CICMOD_MASK | MDF_SITFCR_SCKSRC_MASK;
-	cicr = MDF_SITFCR_SCKSRC(datsrc) | MDF_DFLTCICR_CICMOD(adc->cicmode);
-
-	regmap_update_bits(adc->regmap, MDF_DFLTCICR_REG, cicr_msk, cicr);
-
-	/*
-	 * Set sync continuous acquisition mode & TRGO trigger source for:
-	 * - Interleave mode
-	 * - Synchronuous continuous mode
-	 */
-	if (adc->fl_id < adc->mdf->nb_interleave || adc->sync == STM32_MDF_ACQ_MODE_SYNC_CONT)
-		regmap_update_bits(adc->regmap, MDF_DFLTCR_REG,
-				   MDF_DFLTCR_ACQMOD_MASK | MDF_DFLTCR_TRGSRC_MASK,
-				   MDF_DFLTCR_ACQMOD(STM32_MDF_ACQ_MODE_SYNC_CONT) |
-				   MDF_DFLTCR_TRGSRC(STM32_MDF_TRGSRC_TRGO));
-
-	/* Configure RSFR */
-	if (adc->hpf_cutoff == STM32_MDF_HPF_BYPASS)
-		rsfr = MDF_DFLTRSFR_HPFBYP;
-	else
-		rsfr = MDF_DFLTRSFR_HPFC(adc->hpf_cutoff);
-	rsfr |= adc->rsflt_bypass ? MDF_DFLTRSFR_RSFLTBYP : 0;
-	rsfr_msk = MDF_DFLTRSFR_RSFLTBYP | MDF_DFLTRSFR_HPFBYP | MDF_DFLTRSFR_HPFC_MASK;
-
-	regmap_update_bits(adc->regmap, MDF_DFLTRSFR_REG, rsfr_msk, rsfr);
-
-	/* Configure delay */
-	regmap_update_bits(adc->regmap, MDF_DLYCR_REG, MDF_DLYCR_SKPDLY_MASK, adc->delay);
-
 	/* Configure BSMXCR */
 	regmap_update_bits(adc->regmap, MDF_BSMXCR_REG,
 			   MDF_BSMXCR_BSSEL_MASK, MDF_BSMXCR_BSSEL(bsmx));
@@ -1258,6 +1601,7 @@ static int stm32_mdf_adc_probe(struct pl
 		dev_err(dev, "Failed to allocate IIO device\n");
 		return -ENOMEM;
 	}
+	iio->modes = INDIO_DIRECT_MODE;
 
 	adc = iio_priv(iio);
 	adc->mdf = dev_get_drvdata(dev->parent);
@@ -1289,6 +1633,8 @@ static int stm32_mdf_adc_probe(struct pl
 
 	if (dev_data->type == STM32_MDF_AUDIO)
 		iio->info = &stm32_mdf_info_audio;
+	else
+		iio->info = &stm32_mdf_info_adc;
 	iio->name = dev_name(&pdev->dev);
 
 	adc->dev = dev;
@@ -1297,7 +1643,7 @@ static int stm32_mdf_adc_probe(struct pl
 	if (ret < 0)
 		return ret;
 
-	if (!adc->interleaved) {
+	if (!MDF_IS_INTERLEAVED_FILT_NOT_0(adc)) {
 		ret = iio_device_register(iio);
 		if (ret < 0) {
 			dev_err(dev, "Failed to register IIO device: %d\n", ret);
@@ -1330,7 +1676,7 @@ static int stm32_mdf_adc_remove(struct p
 
 	if (adc->dev_data->type == STM32_MDF_AUDIO)
 		of_platform_depopulate(&pdev->dev);
-	if (!adc->interleaved)
+	if (!MDF_IS_INTERLEAVED_FILT_NOT_0(adc))
 		iio_device_unregister(indio_dev);
 	stm32_mdf_dma_release(indio_dev);
 
@@ -1344,7 +1690,7 @@ static int stm32_mdf_adc_suspend(struct
 	int ret = 0;
 
 	if (iio_buffer_enabled(indio_dev))
-		ret = stm32_mdf_predisable(indio_dev);
+		ret = stm32_mdf_adc_predisable(indio_dev);
 
 	regcache_cache_only(adc->regmap, true);
 	regcache_mark_dirty(adc->regmap);
@@ -1362,7 +1708,7 @@ static int stm32_mdf_adc_resume(struct d
 	ret = regcache_sync(adc->regmap);
 
 	if (!ret && iio_buffer_enabled(indio_dev))
-		ret = stm32_mdf_postenable(indio_dev);
+		ret = stm32_mdf_adc_postenable(indio_dev);
 
 	return ret;
 }
--- a/drivers/iio/adc/stm32-mdf-core.c
+++ b/drivers/iio/adc/stm32-mdf-core.c
@@ -22,7 +22,7 @@
 
 #include "stm32-mdf.h"
 
-static bool stm32_mdf_readable_reg(struct device *dev, unsigned int reg)
+static bool stm32_mdf_core_readable_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
 	case MDF_GCR_REG:
@@ -37,7 +37,7 @@ static bool stm32_mdf_readable_reg(struc
 	}
 }
 
-static bool stm32_mdf_volatile_reg(struct device *dev, unsigned int reg)
+static bool stm32_mdf_core_volatile_reg(struct device *dev, unsigned int reg)
 {
 	/*
 	 * In MDF_CKGCR_REG register only CKGACTIVE bit is volatile. MDF_CKGCR_REG is not marked
@@ -47,7 +47,7 @@ static bool stm32_mdf_volatile_reg(struc
 	return false;
 }
 
-static bool stm32_mdf_writeable_reg(struct device *dev, unsigned int reg)
+static bool stm32_mdf_core_writeable_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
 	case MDF_GCR_REG:
@@ -63,9 +63,9 @@ static const struct regmap_config stm32_
 	.val_bits = 32,
 	.reg_stride = sizeof(u32),
 	.max_register = MDF_SIDR_REG,
-	.readable_reg = stm32_mdf_readable_reg,
-	.volatile_reg = stm32_mdf_volatile_reg,
-	.writeable_reg = stm32_mdf_writeable_reg,
+	.readable_reg = stm32_mdf_core_readable_reg,
+	.volatile_reg = stm32_mdf_core_volatile_reg,
+	.writeable_reg = stm32_mdf_core_writeable_reg,
 	.num_reg_defaults_raw = MDF_SIDR_REG / sizeof(u32) + 1,
 	.fast_io = true,
 	.cache_type = REGCACHE_FLAT,
@@ -80,7 +80,7 @@ static const struct regmap_config stm32_
  * @base: mdf registers base cpu address
  * @phys_base: mdf registers base physical address
  * @n_active_ch: number of active channels
- * @lock: lock to manage clock provider
+ * @lock: lock to manage common resources
  * @cck_freq: output cck clocks frequencies array
  */
 struct stm32_mdf_priv {
@@ -91,7 +91,7 @@ struct stm32_mdf_priv {
 	void __iomem *base;
 	phys_addr_t phys_base;
 	atomic_t n_active_ch;
-	spinlock_t lock; /* Manage clock provider race conditions */
+	spinlock_t lock; /* Manage common resources race conditions */
 	unsigned long cck_freq;
 };
 
@@ -102,7 +102,7 @@ static inline struct stm32_mdf_priv *to_
 	return container_of(mdf, struct stm32_mdf_priv, mdf);
 }
 
-int stm32_mdf_start_mdf(struct stm32_mdf *mdf)
+int stm32_mdf_core_start_mdf(struct stm32_mdf *mdf)
 {
 	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
 	struct device *dev = &priv->pdev->dev;
@@ -139,25 +139,39 @@ err:
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(stm32_mdf_start_mdf);
+EXPORT_SYMBOL_GPL(stm32_mdf_core_start_mdf);
 
-int stm32_mdf_trigger(struct stm32_mdf *mdf)
+int stm32_mdf_core_trigger(struct stm32_mdf *mdf)
 {
 	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
 	int ret;
+	u32 val;
+
+	spin_lock(&priv->lock);
 
-	/* Bypass cache to ensure TRGO bit is actually set on each write access */
+	/* Bypass cache to access TRGO volatile bit */
 	regcache_cache_bypass(priv->regmap, true);
+
+	ret = regmap_read(priv->regmap, MDF_GCR_REG, &val);
+	if (ret < 0)
+		goto err;
+
+	if (val & MDF_GCR_TRGO) {
+		ret = -EBUSY;
+		goto err;
+	}
+
 	ret = regmap_set_bits(priv->regmap, MDF_GCR_REG, MDF_GCR_TRGO);
+
+err:
 	regcache_cache_bypass(priv->regmap, false);
-	if (ret < 0)
-		return ret;
+	spin_unlock(&priv->lock);
 
-	return 0;
+	return ret;
 }
-EXPORT_SYMBOL_GPL(stm32_mdf_trigger);
+EXPORT_SYMBOL_GPL(stm32_mdf_core_trigger);
 
-int stm32_mdf_stop_mdf(struct stm32_mdf *mdf)
+int stm32_mdf_core_stop_mdf(struct stm32_mdf *mdf)
 {
 	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
 	int ret = 0;
@@ -170,11 +184,11 @@ int stm32_mdf_stop_mdf(struct stm32_mdf
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(stm32_mdf_stop_mdf);
+EXPORT_SYMBOL_GPL(stm32_mdf_core_stop_mdf);
 
-static int stm32_mdf_cck_divider_set_rate(struct platform_device *pdev,
-					  struct stm32_mdf_priv *priv,
-					  unsigned long parent_rate)
+static int stm32_mdf_core_cck_divider_set_rate(struct platform_device *pdev,
+					       struct stm32_mdf_priv *priv,
+					       unsigned long parent_rate)
 {
 	struct device *dev = &pdev->dev;
 	unsigned long rate = priv->cck_freq;
@@ -220,7 +234,8 @@ static int stm32_mdf_cck_divider_set_rat
 				  MDF_CKG_PROCDIV(procdiv - 1));
 }
 
-static unsigned long stm32_mdf_cck_divider_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+static unsigned long stm32_mdf_core_cck_divider_recalc_rate(struct clk_hw *hw,
+							    unsigned long parent_rate)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	unsigned int val;
@@ -239,7 +254,7 @@ static unsigned long stm32_mdf_cck_divid
 };
 
 static const struct clk_ops clk_cck_ops = {
-	.recalc_rate = stm32_mdf_cck_divider_recalc_rate,
+	.recalc_rate = stm32_mdf_core_cck_divider_recalc_rate,
 };
 
 static struct clk_regmap clk_cck;
@@ -288,8 +303,6 @@ static int stm32_mdf_core_register_clock
 	if (!clk_data)
 		return -ENOMEM;
 
-	spin_lock_init(&priv->lock);
-
 	of_property_for_each_string(node, "clock-output-names", prop, clk_name) {
 		if (index >= STM32_MDF_MAX_CCK) {
 			dev_err(dev, "Too many cck providers defined\n");
@@ -337,7 +350,7 @@ static int stm32_mdf_core_register_clock
 				  MDF_CKG_CCK1DIR | MDF_CKG_CCK0DIR, ckgcr);
 }
 
-static int stm32_mdf_of_cck_get(struct platform_device *pdev, struct stm32_mdf_priv *priv)
+static int stm32_mdf_core_of_cck_get(struct platform_device *pdev, struct stm32_mdf_priv *priv)
 {
 	struct device *dev = &pdev->dev;
 	u32 freq;
@@ -378,12 +391,12 @@ static int stm32_mdf_core_parse_clocks(s
 	kclk_rate = clk_get_rate(kclk);
 
 	/* CCK0 and CCK1 clocks are optional. Used only in SPI master modes. */
-	ret = stm32_mdf_of_cck_get(pdev, priv);
+	ret = stm32_mdf_core_of_cck_get(pdev, priv);
 	if (ret)
 		return ret;
 
 	if (priv->cck_freq) {
-		ret = stm32_mdf_cck_divider_set_rate(pdev, priv, kclk_rate);
+		ret = stm32_mdf_core_cck_divider_set_rate(pdev, priv, kclk_rate);
 		if (ret) {
 			dev_err(dev, "Failed to set cck rate: %d\n", ret);
 			return ret;
@@ -495,6 +508,7 @@ static int stm32_mdf_core_probe(struct p
 	if (!priv)
 		return -ENOMEM;
 	priv->pdev = pdev;
+	spin_lock_init(&priv->lock);
 
 	priv->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(priv->base))
--- a/drivers/iio/adc/stm32-mdf.h
+++ b/drivers/iio/adc/stm32-mdf.h
@@ -33,8 +33,8 @@
 #define MDF_DFLTIER_REG 0x28
 #define MDF_DFLTISR_REG 0x2C
 #define MDF_OECCR_REG 0x30
-#define MDF_SNPSxDR 0x64
-#define MDF_DLTDR_REG 0x6c
+#define MDF_SNPSDR 0x64
+#define MDF_DFLTDR_REG 0x6c
 
 /* MDF_GCR: Global Control Register */
 #define MDF_GCR_TRGO BIT(0)
@@ -85,6 +85,7 @@
 #define MDF_DFLTCR_ACQMOD_MASK GENMASK(6, 4)
 #define MDF_DFLTCR_ACQMOD(v) FIELD_PREP(MDF_DFLTCR_ACQMOD_MASK, v)
 #define MDF_DFLTCR_TRGSENS BIT(8)
+#define MDF_DFLTCR_TRGSENS_SET(v) FIELD_PREP(MDF_DFLTCR_TRGSENS, v)
 #define MDF_DFLTCR_TRGSRC_MASK GENMASK(15, 12)
 #define MDF_DFLTCR_TRGSRC(v) FIELD_PREP(MDF_DFLTCR_TRGSRC_MASK, v)
 #define MDF_DFLTCR_SNPSFMT BIT(16)
@@ -301,9 +302,9 @@ struct stm32_mdf {
 	unsigned int nb_interleave;
 };
 
-int stm32_mdf_start_mdf(struct stm32_mdf *mdf);
-int stm32_mdf_stop_mdf(struct stm32_mdf *mdf);
-int stm32_mdf_trigger(struct stm32_mdf *mdf);
+int stm32_mdf_core_start_mdf(struct stm32_mdf *mdf);
+int stm32_mdf_core_stop_mdf(struct stm32_mdf *mdf);
+int stm32_mdf_core_trigger(struct stm32_mdf *mdf);
 
 int stm32_mdf_sitf_start(struct stm32_mdf_sitf *sitf);
 int stm32_mdf_sitf_stop(struct stm32_mdf_sitf *sitf);
